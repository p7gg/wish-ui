import { createPolymorphicComponent, focusWithoutScrolling, mergeDefaultProps, mergeRefs, } from "@kobalte/utils";
import { createEffect, onCleanup, Show, splitProps } from "solid-js";
import { DismissableLayer } from "../dismissable-layer";
import { PopperPositioner } from "../popper/popper-positioner";
import { createFocusScope, createHideOutside, createPreventScroll, } from "../primitives";
import { usePopoverContext } from "./popover-context";
/**
 * Contains the content to be rendered when the popover is open.
 */
export const PopoverContent = createPolymorphicComponent(props => {
    let ref;
    const context = usePopoverContext();
    props = mergeDefaultProps({
        as: "div",
        id: context.generateId("content"),
    }, props);
    const [local, others] = splitProps(props, [
        "ref",
        "id",
        "style",
        "onOpenAutoFocus",
        "onCloseAutoFocus",
        "onPointerDownOutside",
        "onFocusOutside",
        "onInteractOutside",
    ]);
    let isRightClickOutside = false;
    let hasInteractedOutside = false;
    const onCloseAutoFocus = (e) => {
        local.onCloseAutoFocus?.(e);
        if (context.isModal()) {
            e.preventDefault();
            if (!isRightClickOutside) {
                focusWithoutScrolling(context.triggerRef());
            }
        }
        else {
            if (!e.defaultPrevented) {
                if (!hasInteractedOutside) {
                    focusWithoutScrolling(context.triggerRef());
                }
                // Always prevent autofocus because we either focus manually or want user agent focus
                e.preventDefault();
            }
            hasInteractedOutside = false;
        }
    };
    const onPointerDownOutside = (e) => {
        local.onPointerDownOutside?.(e);
        if (context.isModal()) {
            isRightClickOutside = e.detail.isContextMenu;
        }
    };
    const onFocusOutside = (e) => {
        local.onFocusOutside?.(e);
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.isModal()) {
            e.preventDefault();
        }
    };
    const onInteractOutside = (e) => {
        local.onInteractOutside?.(e);
        if (!context.isModal() && !e.defaultPrevented) {
            hasInteractedOutside = true;
        }
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: () => !(context.isOpen() && context.isModal()),
        targets: () => (ref ? [ref] : []),
    });
    createPreventScroll({
        isDisabled: () => !(context.isOpen() && context.isModal()),
    });
    createFocusScope({
        trapFocus: () => context.isOpen() && context.isModal(),
        onMountAutoFocus: local.onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
    }, () => ref);
    createEffect(() => onCleanup(context.registerContentId(local.id)));
    return (<Show when={context.shouldMount()}>
      <PopperPositioner>
        <DismissableLayer ref={mergeRefs(el => {
            context.setContentRef(el);
            ref = el;
        }, local.ref)} role="dialog" id={local.id} tabIndex={-1} isDismissed={!context.isOpen()} disableOutsidePointerEvents={context.isOpen() && context.isModal()} excludedElements={[context.triggerRef]} style={{ position: "relative", ...local.style }} aria-labelledby={context.titleId()} aria-describedby={context.descriptionId()} onPointerDownOutside={onPointerDownOutside} onFocusOutside={onFocusOutside} onInteractOutside={onInteractOutside} onDismiss={context.close} {...others}/>
      </PopperPositioner>
    </Show>);
});
