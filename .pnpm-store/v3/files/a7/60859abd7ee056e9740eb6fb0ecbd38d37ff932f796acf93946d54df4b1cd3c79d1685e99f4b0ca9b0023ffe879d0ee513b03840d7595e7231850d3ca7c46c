/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dialog/src/Dialog.tsx
 */
import { createPolymorphicComponent, focusWithoutScrolling, mergeDefaultProps, mergeRefs, } from "@kobalte/utils";
import { createEffect, onCleanup, Show, splitProps } from "solid-js";
import { DismissableLayer } from "../dismissable-layer";
import { createFocusScope, createHideOutside, createPreventScroll, } from "../primitives";
import { useDialogContext } from "./dialog-context";
/**
 * Contains the content to be rendered when the dialog is open.
 */
export const DialogContent = createPolymorphicComponent(props => {
    let ref;
    const context = useDialogContext();
    props = mergeDefaultProps({
        as: "div",
        id: context.generateId("content"),
    }, props);
    const [local, others] = splitProps(props, [
        "ref",
        "id",
        "onOpenAutoFocus",
        "onCloseAutoFocus",
        "onEscapeKeyDown",
        "onPointerDownOutside",
        "onFocusOutside",
        "onInteractOutside",
    ]);
    let hasInteractedOutside = false;
    const onPointerDownOutside = (e) => {
        local.onPointerDownOutside?.(e);
        // If the event is a right-click, we shouldn't close because
        // it is effectively as if we right-clicked the `Overlay`.
        if (context.isModal() && e.detail.isContextMenu) {
            e.preventDefault();
        }
    };
    const onFocusOutside = (e) => {
        local.onFocusOutside?.(e);
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        if (context.isModal()) {
            e.preventDefault();
        }
    };
    const onInteractOutside = (e) => {
        local.onInteractOutside?.(e);
        if (!context.isModal() && !e.defaultPrevented) {
            hasInteractedOutside = true;
        }
    };
    const onCloseAutoFocus = (e) => {
        local.onCloseAutoFocus?.(e);
        if (context.isModal()) {
            e.preventDefault();
            focusWithoutScrolling(context.triggerRef());
        }
        else {
            if (!e.defaultPrevented) {
                if (!hasInteractedOutside) {
                    focusWithoutScrolling(context.triggerRef());
                }
                // Always prevent autofocus because we either focus manually or want user agent focus
                e.preventDefault();
            }
            hasInteractedOutside = false;
        }
    };
    // aria-hide everything except the content (better supported equivalent to setting aria-modal)
    createHideOutside({
        isDisabled: () => !(context.isOpen() && context.isModal()),
        targets: () => (ref ? [ref] : []),
    });
    createPreventScroll({
        isDisabled: () => !(context.isOpen() && context.isModal()),
    });
    createFocusScope({
        trapFocus: () => context.isOpen() && context.isModal(),
        onMountAutoFocus: local.onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
    }, () => ref);
    createEffect(() => onCleanup(context.registerContentId(local.id)));
    return (<Show when={context.shouldMount()}>
      <DismissableLayer ref={mergeRefs(el => (ref = el), local.ref)} role="dialog" id={local.id} tabIndex={-1} isDismissed={!context.isOpen()} disableOutsidePointerEvents={context.isOpen() && context.isModal()} excludedElements={[context.triggerRef]} aria-labelledby={context.titleId()} aria-describedby={context.descriptionId()} onEscapeKeyDown={local.onEscapeKeyDown} onPointerDownOutside={onPointerDownOutside} onFocusOutside={onFocusOutside} onInteractOutside={onInteractOutside} onDismiss={context.close} {...others}/>
    </Show>);
});
