import { Many, ExtractIfPossible, ItemsOf, Directive } from '@solid-primitives/utils';
import { JSX, children, Accessor } from 'solid-js';

declare module "solid-js" {
    namespace JSX {
        interface Directives {
            unmount: (el: Element) => void;
        }
    }
}
type E = JSX.Element;
/**
 * Component properties with types for `ref`
 * ```ts
 * {
 *    ref?: Element | ((el: Element) => void);
 * }
 * ```
 */
interface RefProps<T extends Element> {
    ref?: T | ((el: T) => void);
}
/**
 * Type of resolved JSX elements provided by Solid's `children` helper.
 */
type ResolvedChildren = ReturnType<ReturnType<typeof children>>;
/**
 * Utility for using jsx refs both for local variables and providing it to the `props.ref` for component consumers.
 * @param setRef use this to set local variables
 * @param propsRef for forwarding the ref to `props.ref`
 * @example
 * ```tsx
 * interface ButtonProps {
 *    ref?: HTMLButtonElement | ((el: HTMLButtonElement) => void);
 * }
 * const Button = (props: ButtonProps) => {
 *    let ref!: HTMLButtonElement
 *    onMount(() => {
 *        // use the local ref
 *    })
 *    return <button ref={mergeRefs(el => (ref = el), props.ref)} />
 * }
 *
 * // in consumer's component:
 * let ref!: HTMLButtonElement
 * <Button ref={ref} />
 * ```
 */
declare function mergeRefs<T extends Element>(setRef: (el: T) => void, propsRef: T | ((el: T) => void) | undefined): (el: T) => void;
/**
 * Which elements got added to the array, and which got removed?
 * @param prevList Array before change
 * @param list Array after change
 * @returns `[added items, removed items]`
 */
declare function getChangedItems<T>(prevList: readonly T[], list: readonly T[]): [added: T[], removed: T[]];
/**
 * Which elements got added to the array?
 * @param prevList Array before change
 * @param list Array after change
 * @returns list of added items
 */
declare const getAddedItems: <T>(prevList: readonly T[], list: readonly T[]) => T[];
/**
 * Which elements got removed from the array?
 * @param prevList Array before change
 * @param list Array after change
 * @returns list of removed items
 */
declare const getRemovedItems: <T>(prevList: readonly T[], list: readonly T[]) => T[];
/**
 * Similarly to `children()` helper from `solid-js` will resolve provided {@link value} to a flat list of HTML elements or a single element or `null`. But doesn't create a computation.
 * @param value value to be resolved
 * @returns ```ts
 * HTMLElement | HTMLElement[] | null
 * ```
 */
declare function resolveElements(value: unknown): HTMLElement | HTMLElement[] | null;
/**
 * Reactive signal that filters out non-element items from a signal array.
 * @param fn Array signal
 * @returns Array signal
 * @example
 * const resolved = children(() => props.children);
 * const refs = elements(resolved);
 * refs() // T: Element[]
 * // or narrow down type of the Element
 * const refs = elements(resolved, HTMLElement);
 * refs() // T: HTMLElement[]
 */
declare function elements<S>(fn: Accessor<Many<S>>): Accessor<ExtractIfPossible<S, Element>[]>;
declare function elements<S, T extends (typeof Element)[]>(fn: Accessor<Many<S>>, ...types: T): Accessor<ExtractIfPossible<S, InstanceType<ItemsOf<T>>>[]>;
/**
 * Get signal references to DOM Elements of the reactive input. Which Elements were added, which were removed.
 * @param fn JSX.Element signal
 * @returns `[current elements, added, removed]`
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/refs#refs
 * @example
 * const [elements, added, removed] = refs(children(() => props.children));
 * elements() // => [<button>, <div>, ...]
 * added() // => [...]
 * removed() // => [...]
 */
declare function refs<S>(fn: Accessor<Many<S>>): [
    refs: Accessor<ExtractIfPossible<S, Element>[]>,
    added: Accessor<ExtractIfPossible<S, Element>[]>,
    removed: Accessor<ExtractIfPossible<S, Element>[]>
];
declare function refs<S, T extends (typeof Element)[]>(fn: Accessor<Many<S>>, ...types: T): [
    refs: Accessor<ExtractIfPossible<S, InstanceType<ItemsOf<T>>>[]>,
    added: Accessor<ExtractIfPossible<S, InstanceType<ItemsOf<T>>>[]>,
    removed: Accessor<ExtractIfPossible<S, InstanceType<ItemsOf<T>>>[]>
];
/**
 * A directive that calls handler when the element get's unmounted from DOM.
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/refs#unmount
 */
declare const unmount: Directive<(el: Element) => void>;
/**
 * reactively map removed items from a reactive signal array. If the mapping function return an element signal, this element will be placed in the array returned from primitive.
 * @param list array source
 * @param mapFn function executed on elements removed from the source list. Return element to keep it in the array.
 * @returns array signal of elements from source + mapped removed elements
 * @example
 * const combined = mapRemoved(refs, (ref, i) => {
 *    const [el, setEl] = createSignal(ref);
 *    createEffect(() => {}) // you can create computations in the mapping function
 *    return el; // set the signal to undefined to remove it from array
 * });
 */
declare function mapRemoved<T>(list: Accessor<Many<T>>, mapFn: (v: T, index: Accessor<number>) => Accessor<T | undefined> | undefined | void): Accessor<T[]>;
/**
 * Solid's `children` helper in component form. Access it's children elements by `get` property.
 * @property `get` â€“ get resolved elements, fired every time the children change
 * @example
 * ```tsx
 * const [children, setChildren] = createSignal<ResolvedJSXElement>();
 *
 * <Children get={setChildren}>
 *    <div></div>
 *    ...
 * </Children>
 * ```
 */
declare const Children: (props: {
    get: (resolved: ResolvedChildren) => void;
    children: JSX.Element;
}) => Accessor<ResolvedChildren>;
/**
 * Get up-to-date references of the multiple children elements.
 * @param refs Getter of current array of elements
 * @param added Getter of added elements since the last change
 * @param removed Getter of removed elements since the last change
 * @param onChange handle children changes
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/refs#Refs
 */
declare const Refs: <E_1 extends Element>(props: {
    refs?: ((els: E_1[]) => void) | undefined;
    added?: ((els: E_1[]) => void) | undefined;
    removed?: ((els: E_1[]) => void) | undefined;
    onChange?: ((changed: {
        refs: E_1[];
        added: E_1[];
        removed: E_1[];
    }) => void) | undefined;
    children: JSX.Element;
}) => Accessor<ResolvedChildren>;
/**
 * Get up-to-date reference to a single child element.
 * @param ref Getter of current element *(or `undefined` if not mounted)*
 * @param onMount handle the child element getting mounted to the dom
 * @param onUnmount handle the child element getting unmounted from the dom
 * @see https://github.com/solidjs-community/solid-primitives/tree/main/packages/refs#Ref
 */
declare const Ref: <U extends Element>(props: {
    ref?: ((el: U | undefined) => void) | undefined;
    onMount?: ((el: U) => void) | undefined;
    onUnmount?: ((el: U) => void) | undefined;
    children: JSX.Element;
}) => Accessor<ResolvedChildren>;

export { Children, E, Ref, RefProps, Refs, ResolvedChildren, elements, getAddedItems, getChangedItems, getRemovedItems, mapRemoved, mergeRefs, refs, resolveElements, unmount };
