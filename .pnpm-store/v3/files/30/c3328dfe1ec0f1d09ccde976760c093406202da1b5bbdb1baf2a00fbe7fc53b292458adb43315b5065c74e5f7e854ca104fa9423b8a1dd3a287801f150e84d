import { access, accessWith, getDocument, EventKey, isVirtualClick, isMac, runAfterTransition, focusWithoutScrolling, getActiveElement, contains, removeItemFromArray, visuallyHiddenStyles, getAllTabbableIn, noop, composeEventHandlers, isCtrlKey, isIOS, createGlobalListeners, isVirtualPointerEvent, mergeDefaultProps, chain, getScrollParent, isString, createMediaQuery, createGenerateId, createPolymorphicComponent, mergeRefs, isAppleDevice, createEventListener, scrollIntoView as scrollIntoView$1, callHandler, getFocusableTreeWalker, isActionKey, isSelectionKey, addItemToArray, isFunction, getWindow, isPointInPolygon, getEventPoint, isWebKit, clamp } from '@kobalte/utils';
export { createPolymorphicComponent } from '@kobalte/utils';
import { isServer, createComponent, effect, setAttribute, template, Dynamic, mergeProps as mergeProps$1, memo, use, spread, insert, Portal, style } from 'solid-js/web';
import { createContext, useContext, createMemo, createSignal, createEffect, onCleanup, mergeProps, on, untrack, onMount, createUniqueId, splitProps, Show, createComputed, createComponent as createComponent$1, Index, children, Switch, Match, For } from 'solid-js';
import { LocalizedStringFormatter, LocalizedStringDictionary } from '@internationalized/string';
import { DateFormatter, startOfYear, startOfMonth, startOfWeek, maxDate, toCalendarDate, minDate, isSameDay, isToday, isSameMonth, getDayOfWeek, endOfMonth, getWeeksInMonth, createCalendar, toCalendar, today, GregorianCalendar, isEqualDay } from '@internationalized/date';
import { autoUpdate, offset, flip, shift, size, hide, arrow, computePosition, platform } from '@floating-ui/dom';
import { NumberFormatter } from '@internationalized/number';

/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/color-mode-context.ts
 */
const ColorModeContext = createContext();

/**
 * Primitive that reads from `ColorModeProvider` context,
 * Returns the color mode and function to toggle it.
 */
function useColorMode() {
  const context = useContext(ColorModeContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useColorMode` must be used within a `ColorModeProvider`");
  }
  return context;
}

/**
 * Change value based on color mode.
 *
 * @param light the light mode value
 * @param dark the dark mode value
 * @return A memoized value based on the color mode.
 *
 * @example
 *
 * ```js
 * const Icon = useColorModeValue(MoonIcon, SunIcon)
 * ```
 */
function useColorModeValue(light, dark) {
  const {
    colorMode
  } = useColorMode();
  return createMemo(() => colorMode() === "dark" ? dark : light);
}

/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/storage-manager.ts
 */
const COLOR_MODE_STORAGE_KEY = "kb-color-mode";
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get: fallback => {
      if (isServer) {
        return fallback;
      }
      let value;
      try {
        value = localStorage.getItem(key);
      } catch (e) {
        // noop
      }
      return value ?? fallback;
    },
    set: value => {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        // noop
      }
    }
  };
}
const localStorageManager = createLocalStorageManager(COLOR_MODE_STORAGE_KEY);
function parseCookie(cookie, key) {
  const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
  return match?.[2];
}
function createCookieStorageManager(key, cookie) {
  return {
    ssr: !!cookie,
    type: "cookie",
    get: fallback => {
      if (cookie) {
        return parseCookie(cookie, key) ?? fallback;
      }
      if (isServer) {
        return fallback;
      }
      return parseCookie(document.cookie, key) ?? fallback;
    },
    set: value => {
      document.cookie = `${key}=${value}; max-age=31536000; path=/`;
    }
  };
}
const cookieStorageManager = createCookieStorageManager(COLOR_MODE_STORAGE_KEY);
function cookieStorageManagerSSR(cookie) {
  return createCookieStorageManager(COLOR_MODE_STORAGE_KEY, cookie);
}

/*!
 * Original code by Chakra UI
 * MIT Licensed, Copyright (c) 2019 Segun Adebayo.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/chakra-ui/blob/main/packages/color-mode/src/color-mode.utils.ts
 */
const FALLBACK_COLOR_MODE_VALUE = "system";
function query() {
  return window.matchMedia("(prefers-color-scheme: dark)");
}
function preventTransition() {
  const css = document.createElement("style");
  css.appendChild(document.createTextNode(`*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`));
  document.head.appendChild(css);
  return () => {
    // force a reflow
    (() => window.getComputedStyle(document.body))();

    // wait for next tick
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.head.removeChild(css);
      });
    });
  };
}
function setColorModeDataset(value, shouldPreventTransition = true) {
  const cleanup = shouldPreventTransition ? preventTransition() : undefined;
  document.documentElement.dataset.kbTheme = value;
  document.documentElement.style.colorScheme = value;
  cleanup?.();
}
function getSystemColorMode(fallback) {
  const isDark = query().matches ?? fallback === "dark";
  return isDark ? "dark" : "light";
}
function getInitialColorMode(manager) {
  const fallback = "light";
  const initialColorMode = manager.get(fallback) ?? fallback;
  if (initialColorMode === "system") {
    // We can't know the client system preference in SSR so just return the fallback.
    return isServer ? fallback : getSystemColorMode();
  }
  return initialColorMode;
}
function addColorModeListener(fn) {
  const mql = query();
  const listener = e => {
    fn(e.matches ? "dark" : "light");
  };
  mql.addEventListener("change", listener);
  return () => {
    mql.removeEventListener("change", listener);
  };
}

/**
 * Provides context for the color mode based on config in `theme`
 * Returns the color mode and function to toggle the color mode
 */
function ColorModeProvider(props) {
  const fallbackColorMode = () => props.initialColorMode ?? FALLBACK_COLOR_MODE_VALUE;
  const colorModeManager = () => props.storageManager ?? localStorageManager;
  let colorModeListenerCleanupFn;
  const [colorMode, rawSetColorMode] = createSignal(getInitialColorMode(colorModeManager()));
  const applyColorMode = value => {
    rawSetColorMode(value);
    setColorModeDataset(value, props.disableTransitionOnChange);
  };
  const setColorMode = value => {
    if (colorModeListenerCleanupFn) {
      colorModeListenerCleanupFn();
      colorModeListenerCleanupFn = undefined;
    }
    const isSystem = value === "system";
    if (isSystem) {
      colorModeListenerCleanupFn = addColorModeListener(applyColorMode);
    }
    applyColorMode(isSystem ? getSystemColorMode() : value);
    colorModeManager().set(value);
  };
  const toggleColorMode = () => {
    setColorMode(colorMode() === "dark" ? "light" : "dark");
  };
  createEffect(() => {
    setColorMode(colorModeManager().get() ?? fallbackColorMode());
  });
  onCleanup(() => {
    // ensure listener is always cleaned when component is destroyed.
    colorModeListenerCleanupFn?.();
  });
  const context = {
    colorMode,
    setColorMode,
    toggleColorMode
  };
  return createComponent(ColorModeContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

const _tmpl$$a = /*#__PURE__*/template(`<script id="kb-color-mode-script"></script>`, 2);
const VALID_VALUES = new Set(["light", "dark", "system"]);

/**
 * runtime safe-guard against invalid color mode values
 */
function normalize(initialColorMode) {
  if (!VALID_VALUES.has(initialColorMode)) {
    return FALLBACK_COLOR_MODE_VALUE;
  }
  return initialColorMode;
}
function ColorModeScript(props) {
  props = mergeProps({
    initialColorMode: FALLBACK_COLOR_MODE_VALUE,
    storageType: "localStorage",
    storageKey: COLOR_MODE_STORAGE_KEY
  }, props);
  const scriptSrc = createMemo(() => {
    // runtime safe-guard against invalid color mode values
    const init = normalize(props.initialColorMode);
    const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,s=e==="dark";return d.style.colorScheme=e,d.dataset.kbTheme=e,o},u=a,h="${init}",r="${props.storageKey}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();`;
    const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,i=r==="dark";return o.style.colorScheme=r,o.dataset.kbTheme=r,c},n=a,m="${init}",e="${props.storageKey}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();`;
    const fn = props.storageType === "cookie" ? cookieScript : localStorageScript;
    return `!${fn}`.trim();
  });

  // eslint-disable-next-line solid/no-innerhtml
  return (() => {
    const _el$ = _tmpl$$a.cloneNode(true);
    effect(_p$ => {
      const _v$ = props.nonce,
        _v$2 = scriptSrc();
      _v$ !== _p$._v$ && setAttribute(_el$, "nonce", _p$._v$ = _v$);
      _v$2 !== _p$._v$2 && (_el$.innerHTML = _p$._v$2 = _v$2);
      return _p$;
    }, {
      _v$: undefined,
      _v$2: undefined
    });
    return _el$;
  })();
}

/**
 * Generate an array of `CollectionNode` from a custom data source.
 */
function buildNodes(dataSource) {
  let index = 0;
  const nodes = [];
  for (const data of dataSource) {
    nodes.push({
      key: data.key,
      label: data.label,
      textValue: data.textValue,
      isDisabled: data.isDisabled,
      index
    });
    index++;
  }
  return nodes;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/collections/src/useCollection.ts
 */
function createCollection(props, deps = []) {
  const initialNodes = buildNodes(access(props.dataSource));
  const [collection, setCollection] = createSignal(props.factory(initialNodes));
  createEffect(on([() => access(props.dataSource), () => props.factory, ...deps], ([dataSource, factory]) => {
    const nodes = buildNodes(dataSource);
    setCollection(() => factory(nodes));
  }, {
    defer: true
  }));
  return collection;
}

/**
 * Creates a simple reactive state with a getter and setter,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableSignal(props) {
  // Internal uncontrolled value
  // eslint-disable-next-line solid/reactivity
  const [_value, _setValue] = createSignal(props.defaultValue?.());
  const isControlled = createMemo(() => props.value?.() !== undefined);
  const value = createMemo(() => isControlled() ? props.value?.() : _value());
  const setValue = next => {
    untrack(() => {
      const nextValue = accessWith(next, value());
      if (!Object.is(nextValue, value())) {
        if (!isControlled()) {
          _setValue(nextValue);
        }
        props.onChange?.(nextValue);
      }
      return nextValue;
    });
  };
  return [value, setValue];
}

/**
 * Creates a simple reactive Boolean state with a getter, setter and a fallback value of `false`,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableBooleanSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? false;
  return [value, setValue];
}

/**
 * Creates a simple reactive Array state with a getter, setter and a fallback value of `[]`,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableArraySignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? [];
  return [value, setValue];
}

/**
 * Creates a simple reactive Set state with a getter, setter and a fallback value of `Set()`,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableSetSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Set();
  return [value, setValue];
}

/**
 * Provides state management for open, close and toggle scenarios.
 * Used to control the "open state" of components like Modal, Drawer, etc.
 */
function createDisclosureState(props = {}) {
  const [isOpen, setIsOpen] = createControllableBooleanSignal({
    value: () => access(props.isOpen),
    defaultValue: () => !!access(props.defaultIsOpen),
    onChange: value => props.onOpenChange?.(value)
  });
  const open = () => {
    setIsOpen(true);
  };
  const close = () => {
    setIsOpen(false);
  };
  const toggle = () => {
    isOpen() ? close() : open();
  };
  return {
    isOpen,
    setIsOpen,
    open,
    close,
    toggle
  };
}

/**
 * Listens for when the escape key is down on the document.
 */
function createEscapeKeyDown(props) {
  const handleKeyDown = event => {
    if (event.key === EventKey.Escape) {
      props.onEscapeKeyDown?.(event);
    }
  };
  createEffect(() => {
    if (access(props.isDisabled)) {
      return;
    }
    const document = props.ownerDocument?.() ?? getDocument();
    document.addEventListener("keydown", handleKeyDown);
    onCleanup(() => {
      document.removeEventListener("keydown", handleKeyDown);
    });
  });
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/70e7caf1946c423bc9aa9cb0e50dbdbe953d239b/packages/@react-aria/interactions/src/useFocusVisible.ts
 */
let hasSetupGlobalListeners = false;
let currentModality = null;
let hasEventBeforeFocus = false;
let hasBlurredWindowRecently = false;
const changeHandlers = new Set();
function triggerChangeHandlers(modality, e) {
  for (const handler of changeHandlers) {
    handler(modality, e);
  }
}

/**
 * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.
 */
function isValidKey(e) {
  // Control and Shift keys trigger when navigating back to the tab with keyboard.
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
}
function handleKeyboardEvent(e) {
  hasEventBeforeFocus = true;
  if (isValidKey(e)) {
    currentModality = "keyboard";
    triggerChangeHandlers("keyboard", e);
  }
}
function handlePointerEvent(e) {
  currentModality = "pointer";
  if (e.type === "mousedown" || e.type === "pointerdown") {
    hasEventBeforeFocus = true;
    const target = e.composedPath ? e.composedPath()[0] : e.target;
    let matches = false;
    try {
      matches = target.matches(":focus-visible");
    } catch {
      // noop
    }
    if (matches) {
      return;
    }
    triggerChangeHandlers("pointer", e);
  }
}
function handleClickEvent(e) {
  if (isVirtualClick(e)) {
    hasEventBeforeFocus = true;
    currentModality = "virtual";
  }
}
function handleWindowFocus(e) {
  // Firefox fires two extra focus events when the user first clicks into an iframe:
  // first on the window, then on the document. We ignore these events, so they don't
  // cause keyboard focus rings to appear.
  if (e.target === window || e.target === document) {
    return;
  }

  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.
  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.
  if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
    currentModality = "virtual";
    triggerChangeHandlers("virtual", e);
  }
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = false;
}
function handleWindowBlur() {
  // When the window is blurred, reset state. This is necessary when tabbing out of the window,
  // for example, since a subsequent focus event won't be fired.
  hasEventBeforeFocus = false;
  hasBlurredWindowRecently = true;
}

/**
 * Setup global event listeners to control when keyboard focus style should be visible.
 */
function setupGlobalFocusEvents() {
  if (typeof window === "undefined" || hasSetupGlobalListeners) {
    return;
  }

  // Programmatic focus() calls shouldn't affect the current input modality.
  // However, we need to detect other cases when a focus event occurs without
  // a preceding user event (e.g. screen reader focus). Overriding the focus
  // method on HTMLElement.prototype is a bit hacky, but works.
  const {
    focus
  } = HTMLElement.prototype;
  HTMLElement.prototype.focus = function (...args) {
    hasEventBeforeFocus = true;
    focus.apply(this, args);
  };
  document.addEventListener("keydown", handleKeyboardEvent, true);
  document.addEventListener("keyup", handleKeyboardEvent, true);
  document.addEventListener("click", handleClickEvent, true);
  window.addEventListener("focus", handleWindowFocus, true);
  window.addEventListener("blur", handleWindowBlur, false);
  document.addEventListener("pointerdown", handlePointerEvent, true);
  document.addEventListener("pointermove", handlePointerEvent, true);
  document.addEventListener("pointerup", handlePointerEvent, true);
  hasSetupGlobalListeners = true;
}
function isKeyboardFocusVisible() {
  return currentModality !== "pointer";
}
function getInteractionModality() {
  return currentModality;
}
function setInteractionModality(modality) {
  currentModality = modality;
  triggerChangeHandlers(modality, null);
}

/**
 * Keeps state of the current modality.
 */
function createInteractionModality() {
  setupGlobalFocusEvents();
  const [modality, setModality] = createSignal(currentModality);
  onMount(() => {
    const handler = () => {
      setModality(currentModality);
    };
    changeHandlers.add(handler);
    onCleanup(() => {
      changeHandlers.delete(handler);
    });
  });
  return modality;
}

/**
 * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that
 * focus visible style can be properly set.
 */
function isKeyboardFocusEvent(isTextInput, modality, e) {
  return !(isTextInput && modality === "keyboard" && e instanceof KeyboardEvent &&
  // Only Tab or Esc keys will make focus visible on text input elements
  !(e.key === "Tab" || e.key === "Escape"));
}
/**
 * Manages focus visible state for the page, and subscribes individual components for updates.
 */
function createFocusVisible(props = {}) {
  const [isFocusVisibleState, setIsFocusVisibleState] = createSignal(access(props.autoFocus) || isKeyboardFocusVisible());
  const isTextInput = () => !!access(props.isTextInput);
  createFocusVisibleListener(setIsFocusVisibleState, [isTextInput], isTextInput);
  return {
    isFocusVisible: isFocusVisibleState
  };
}

/**
 * Listens for trigger change and reports if focus is visible (i.e., modality is not pointer).
 */
function createFocusVisibleListener(fn, deps, isTextInput) {
  setupGlobalFocusEvents();
  createEffect(on(deps, () => {
    const handler = (modality, e) => {
      if (!isKeyboardFocusEvent(isTextInput(), modality, e)) {
        return;
      }
      fn(isKeyboardFocusVisible());
    };
    changeHandlers.add(handler);
    onCleanup(() => {
      changeHandlers.delete(handler);
    });
  }));
}

/* -------------------------------------------------------------------------------------------------
 * Setup
 * -----------------------------------------------------------------------------------------------*/

if (typeof document !== "undefined") {
  if (document.readyState !== "loading") {
    setupGlobalFocusEvents();
  } else {
    document.addEventListener("DOMContentLoaded", setupGlobalFocusEvents);
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/focus/src/focusSafely.ts
 */

/**
 * A utility function that focuses an element while avoiding undesired side effects such
 * as page scrolling and screen reader issues with CSS transitions.
 */
function focusSafely(element) {
  // If the user is interacting with a virtual cursor, e.g. screen reader, then
  // wait until after any animated transitions that are currently occurring on
  // the page before shifting focus. This avoids issues with VoiceOver on iOS
  // causing the page to scroll when moving focus if the element is transitioning
  // from off the screen.
  if (getInteractionModality() === "virtual") {
    const lastFocusedElement = document.activeElement;
    runAfterTransition(() => {
      // If focus did not move and the element is still in the document, focus it.
      if (document.activeElement === lastFocusedElement && document.contains(element)) {
        focusWithoutScrolling(element);
      }
    });
  } else {
    focusWithoutScrolling(element);
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/70e7caf1946c423bc9aa9cb0e50dbdbe953d239b/packages/@react-aria/focus/src/useFocusRing.ts
 */
const FOCUS_RING_HANDLERS_PROP_NAMES = ["onFocusIn", "onFocusOut"];

/**
 * Determines whether a focus ring should be shown to indicate keyboard focus.
 * Focus rings are visible only when the user is interacting with a keyboard,
 * not with a mouse, touch, or other input methods.
 */
function createFocusRing(props = {}) {
  const [isFocused, setIsFocused] = createSignal(false);
  const [isFocusVisible, setIsFocusVisible] = createSignal(false);
  const [isFocusRingVisible, setIsFocusRingVisible] = createSignal(false);
  createFocusVisibleListener(setIsFocusVisible, [], () => !!access(props.isTextInput));
  const shouldPreventFocusWithin = e => {
    return !access(props.within) && e.currentTarget !== e.target;
  };
  const updateStateAndNotifyHandlers = newIsFocused => {
    const newIsFocusRingVisible = newIsFocused && isFocusVisible();
    setIsFocused(newIsFocused);
    setIsFocusRingVisible(newIsFocusRingVisible);
    props.onFocusChange?.(newIsFocused);
    props.onFocusVisibleChange?.(newIsFocusRingVisible);
  };
  const onFocusIn = e => {
    if (shouldPreventFocusWithin(e)) {
      return;
    }
    updateStateAndNotifyHandlers(true);
  };
  const onFocusOut = e => {
    if (shouldPreventFocusWithin(e)) {
      return;
    }
    updateStateAndNotifyHandlers(false);
  };
  return {
    isFocused,
    isFocusVisible: isFocusRingVisible,
    focusRingHandlers: {
      onFocusIn,
      onFocusOut
    }
  };
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/focus-scope/src/FocusScope.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/focus-scope/src/focus-on-child-unmount.ts
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/focus-scope/src/focus-containment.ts
 */
const AUTOFOCUS_ON_MOUNT_EVENT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT_EVENT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const focusScopeStack = {
  /** A stack of focus scopes, with the active one at the top */
  stack: [],
  active() {
    return this.stack[0];
  },
  add(scope) {
    // pause the currently active focus scope (at the top of the stack)
    if (scope !== this.active()) {
      this.active()?.pause();
    }

    // remove in case it already exists and re-add it at the top of the stack.
    this.stack = removeItemFromArray(this.stack, scope);
    this.stack.unshift(scope);
  },
  remove(scope) {
    this.stack = removeItemFromArray(this.stack, scope);
    this.active()?.resume();
  }
};
function createFocusScope(props, ref) {
  const [isPaused, setIsPaused] = createSignal(false);
  const focusScope = {
    pause() {
      setIsPaused(true);
    },
    resume() {
      setIsPaused(false);
    }
  };
  let lastFocusedElement = null;
  const onMountAutoFocus = e => props.onMountAutoFocus?.(e);
  const onUnmountAutoFocus = e => props.onUnmountAutoFocus?.(e);
  const ownerDocument = () => getDocument(ref());
  const createSentinel = () => {
    const element = ownerDocument().createElement("span");
    element.setAttribute("data-focus-trap", "");
    element.tabIndex = 0;
    Object.assign(element.style, visuallyHiddenStyles);
    return element;
  };
  const tabbables = () => {
    const container = ref();
    if (!container) {
      return [];
    }

    // Get all tabbable in container excluding focus scope sentinels
    return getAllTabbableIn(container, true).filter(el => !el.hasAttribute("data-focus-trap"));
  };
  const firstTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[0] : null;
  };
  const lastTabbable = () => {
    const items = tabbables();
    return items.length > 0 ? items[items.length - 1] : null;
  };

  // Handle dispatching mount and unmount autofocus events.
  createEffect(() => {
    const container = ref();
    if (!container) {
      return;
    }
    focusScopeStack.add(focusScope);
    const previouslyFocusedElement = getActiveElement(container);
    const hasFocusedCandidate = contains(container, previouslyFocusedElement);
    if (!hasFocusedCandidate) {
      const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT_EVENT, EVENT_OPTIONS);
      container.addEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      container.dispatchEvent(mountEvent);
      if (!mountEvent.defaultPrevented) {
        // Delay the focusing because it may run before a `DismissableLayer` is added to the layer stack,
        // so it cause nested dismissable layer to open then close instantly.
        setTimeout(() => {
          focusWithoutScrolling(firstTabbable());
          if (getActiveElement(container) === previouslyFocusedElement) {
            focusWithoutScrolling(container);
          }
        }, 0);
      }
    }
    onCleanup(() => {
      container.removeEventListener(AUTOFOCUS_ON_MOUNT_EVENT, onMountAutoFocus);
      setTimeout(() => {
        const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT_EVENT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        container.dispatchEvent(unmountEvent);
        if (!unmountEvent.defaultPrevented) {
          focusWithoutScrolling(previouslyFocusedElement ?? ownerDocument().body);
        }

        // We need to remove the listener after we `dispatchEvent`.
        container.removeEventListener(AUTOFOCUS_ON_UNMOUNT_EVENT, onUnmountAutoFocus);
        focusScopeStack.remove(focusScope);
      }, 0);
    });
  });

  /*
  // Handle containing focus if a child unmount.
  createEffect(() => {
    const container = ref();
     if (!container || !access(props.trapFocus)) {
      return;
    }
     const observer = new MutationObserver(([mutation]) => {
      if (!mutation || mutation.target !== container) {
        return;
      }
       if (getActiveElement(container) === ownerDocument().body) {
        focusWithoutScrolling(container);
      }
    });
     observer.observe(container, { childList: true, subtree: true });
     onCleanup(() => {
      observer.disconnect();
    });
  });
  */

  // Handle containing focus if focus is moved outside.
  createEffect(() => {
    const container = ref();
    if (!container || !access(props.trapFocus) || isPaused()) {
      return;
    }
    const onFocusIn = event => {
      const target = event.target;
      if (contains(container, target)) {
        lastFocusedElement = target;
      } else {
        focusWithoutScrolling(lastFocusedElement);
      }
    };
    const onFocusOut = event => {
      const relatedTarget = event.relatedTarget;
      const target = relatedTarget ?? getActiveElement(container);
      if (!contains(container, target)) {
        focusWithoutScrolling(lastFocusedElement);
      }
    };
    ownerDocument().addEventListener("focusin", onFocusIn);
    ownerDocument().addEventListener("focusout", onFocusOut);
    onCleanup(() => {
      ownerDocument().removeEventListener("focusin", onFocusIn);
      ownerDocument().removeEventListener("focusout", onFocusOut);
    });
  });

  // Handle looping focus (when tabbing whilst at the edges)
  createEffect(() => {
    const container = ref();
    if (!container || !access(props.trapFocus) || isPaused()) {
      return;
    }
    const startSentinel = createSentinel();
    container.insertAdjacentElement("afterbegin", startSentinel);
    const endSentinel = createSentinel();
    container.insertAdjacentElement("beforeend", endSentinel);
    function onFocus(event) {
      const first = firstTabbable();
      const last = lastTabbable();
      if (event.relatedTarget === first) {
        focusWithoutScrolling(last);
      } else {
        focusWithoutScrolling(first);
      }
    }
    startSentinel.addEventListener("focusin", onFocus);
    endSentinel.addEventListener("focusin", onFocus);

    // Ensure sentinels are always the edges of the container.
    const observer = new MutationObserver(mutations => {
      for (const mutation of mutations) {
        if (mutation.previousSibling === endSentinel) {
          endSentinel.remove();
          container.insertAdjacentElement("beforeend", endSentinel);
        }
        if (mutation.nextSibling === startSentinel) {
          startSentinel.remove();
          container.insertAdjacentElement("afterbegin", startSentinel);
        }
      }
    });
    observer.observe(container, {
      childList: true,
      subtree: false
    });
    onCleanup(() => {
      startSentinel.removeEventListener("focusin", onFocus);
      endSentinel.removeEventListener("focusin", onFocus);
      startSentinel.remove();
      endSentinel.remove();
      observer.disconnect();
    });
  });
}

/*!
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the zag team:
 * https://github.com/chakra-ui/zag/blob/c1e6c7689b22bf58741ded7cf224dd9baec2a046/packages/utilities/form-utils/src/form.ts
 */

/**
 * Listens for `reset` event on the closest `<form>` element and execute the given handler.
 */
function createFormResetListener(element, handler) {
  createEffect(on(element, element => {
    if (element == null) {
      return;
    }
    const form = getClosestForm(element);
    if (form == null) {
      return;
    }
    form.addEventListener("reset", handler, {
      passive: true
    });
    onCleanup(() => {
      form.removeEventListener("reset", handler);
    });
  }));
}
function getClosestForm(element) {
  return isFormElement(element) ? element.form : element.closest("form");
}
function isFormElement(element) {
  return element.matches("textarea, input, select, button");
}

/*!
 * This file is based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/810579b671791f1593108f62cdc1893de3a220e3/packages/@react-aria/overlays/src/ariaHideOutside.ts
 */
/**
 * Hides all elements in the DOM outside the given targets from screen readers
 * using aria-hidden, and returns a function to revert these changes.
 * In addition, changes to the DOM are watched and new elements
 * outside the targets are automatically hidden.
 */
function createHideOutside(props) {
  createEffect(() => {
    if (access(props.isDisabled)) {
      return;
    }
    onCleanup(ariaHideOutside(access(props.targets), access(props.root)));
  });
}
// Keeps a ref count of all hidden elements.
// Added to when hiding an element, and subtracted from when showing it again.
// When it reaches zero, aria-hidden is removed.
const refCountMap = new WeakMap();
const observerStack = [];

/**
 * Hides all elements in the DOM outside the given targets from screen readers using aria-hidden,
 * and returns a function to revert these changes. In addition, changes to the DOM are watched
 * and new elements outside the targets are automatically hidden.
 * @param targets - The elements that should remain visible.
 * @param root - Nothing will be hidden above this element.
 * @returns - A function to restore all hidden elements.
 */
function ariaHideOutside(targets, root = document.body) {
  const visibleNodes = new Set(targets);
  const hiddenNodes = new Set();
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {
    acceptNode(node) {
      // If this node is a live announcer, add it to the set of nodes to keep visible.
      if ((node instanceof HTMLElement || node instanceof SVGElement) && node.dataset.liveAnnouncer === "true") {
        visibleNodes.add(node);
      }

      // Skip this node and its children if it is one of the target nodes, or a live announcer.
      // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is
      // made for elements with role="row" since VoiceOver on iOS has issues hiding elements with role="row".
      // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).
      if (visibleNodes.has(node) || node.parentElement && hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }

      // Skip this node but continue to children if one of the targets is inside the node.
      if (targets.some(target => node.contains(target))) {
        return NodeFilter.FILTER_SKIP;
      }
      return NodeFilter.FILTER_ACCEPT;
    }
  });
  const hide = node => {
    const refCount = refCountMap.get(node) ?? 0;

    // If already aria-hidden, and the ref count is zero, then this element
    // was already hidden and there's nothing for us to do.
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };

  // If there is already a MutationObserver listening from a previous call,
  // disconnect it so the new on takes over.
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  let node = walker.nextNode();
  while (node != null) {
    hide(node);
    node = walker.nextNode();
  }
  const observer = new MutationObserver(changes => {
    for (const change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }

      // If the parent element of the added nodes is not within one of the targets,
      // and not already inside a hidden node, hide all the new children.
      if (![...visibleNodes, ...hiddenNodes].some(node => node.contains(change.target))) {
        for (const node of change.addedNodes) {
          if ((node instanceof HTMLElement || node instanceof SVGElement) && node.dataset.liveAnnouncer === "true") {
            visibleNodes.add(node);
          } else if (node instanceof Element) {
            hide(node);
          }
        }
      }
    }
  });
  observer.observe(root, {
    childList: true,
    subtree: true
  });
  const observerWrapper = {
    observe() {
      observer.observe(root, {
        childList: true,
        subtree: true
      });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (const node of hiddenNodes) {
      const count = refCountMap.get(node);
      if (count == null) {
        return;
      }
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }

    // Remove this observer from the stack, and start the previous one.
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/2bcc2f0b45ea8b20621458a93f1804a3f9df9ac4/packages/@react-aria/interactions/src/useHover.ts
 */
// iOS fires onPointerEnter twice: once with pointerType="touch" and again with pointerType="mouse".
// We want to ignore these emulated events, so they do not trigger hover behavior.
// See https://bugs.webkit.org/show_bug.cgi?id=214609.
let globalIgnoreEmulatedMouseEvents = false;
let hoverCount = 0;
function setGlobalIgnoreEmulatedMouseEvents() {
  globalIgnoreEmulatedMouseEvents = true;

  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
  // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
  // the distant future because a user previously touched the element.
  setTimeout(() => {
    globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function handleGlobalPointerEvent(e) {
  if (e.pointerType === "touch") {
    setGlobalIgnoreEmulatedMouseEvents();
  }
}
function setupGlobalTouchEvents() {
  if (typeof document === "undefined") {
    return;
  }
  document.addEventListener("pointerup", handleGlobalPointerEvent);
  hoverCount++;
  return () => {
    hoverCount--;
    if (hoverCount > 0) {
      return;
    }
    document.removeEventListener("pointerup", handleGlobalPointerEvent);
  };
}
const HOVER_HANDLERS_PROP_NAMES = ["onPointerEnter", "onPointerLeave"];

/**
 * Handles pointer hover interactions for an element. Normalizes behavior
 * across browsers and platforms, and ignores emulated mouse events on touch devices.
 */
function createHover(props = {}) {
  const [isHovered, setIsHovered] = createSignal(false);
  const state = {
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: null,
    target: null
  };
  const triggerHoverStart = (event, pointerType) => {
    state.pointerType = pointerType;
    const eventCurrentTarget = event.currentTarget;
    const eventTarget = event.target;
    if (access(props.isDisabled) || pointerType === "touch" || state.isHovered || !eventCurrentTarget?.contains(eventTarget)) {
      return;
    }
    state.isHovered = true;
    state.target = eventCurrentTarget;
    props.onHoverStart?.({
      type: "hoverstart",
      target: eventCurrentTarget,
      pointerType
    });
    props.onHoverChange?.(true);
    setIsHovered(true);
  };
  const triggerHoverEnd = (event, pointerType) => {
    state.pointerType = null;
    state.target = null;
    if (pointerType === "touch" || !state.isHovered) {
      return;
    }
    state.isHovered = false;
    props.onHoverEnd?.({
      type: "hoverend",
      target: event.currentTarget,
      pointerType
    });
    props.onHoverChange?.(false);
    setIsHovered(false);
  };
  const onPointerEnter = e => {
    if (globalIgnoreEmulatedMouseEvents && e.pointerType === "mouse") {
      return;
    }
    triggerHoverStart(e, e.pointerType);
  };
  const onPointerLeave = e => {
    if (!access(props.isDisabled) && e.currentTarget.contains(e.target)) {
      triggerHoverEnd(e, e.pointerType);
    }
  };
  onMount(() => {
    const cleanupFn = setupGlobalTouchEvents();
    onCleanup(() => cleanupFn?.());
  });
  createEffect(on(() => access(props.isDisabled), disabled => {
    // Call the triggerHoverEnd as soon as isDisabled changes to true
    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering
    if (disabled) {
      triggerHoverEnd({
        currentTarget: state.target
      }, state.pointerType);
    }
  }));
  return {
    isHovered,
    hoverHandlers: {
      onPointerEnter,
      onPointerLeave
    }
  };
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dismissable-layer/src/DismissableLayer.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/interact-outside/src/index.ts
 */
const POINTER_DOWN_OUTSIDE_EVENT = "interactOutside.pointerDownOutside";
const FOCUS_OUTSIDE_EVENT = "interactOutside.focusOutside";
function createInteractOutside(props, ref) {
  let pointerDownTimeoutId;
  let clickHandler = noop;
  const ownerDocument = () => getDocument(ref());
  const onPointerDownOutside = e => props.onPointerDownOutside?.(e);
  const onFocusOutside = e => props.onFocusOutside?.(e);
  const onInteractOutside = e => props.onInteractOutside?.(e);
  const isEventOutside = e => {
    const target = e.target;
    if (!(target instanceof HTMLElement)) {
      return false;
    }
    if (!contains(ownerDocument(), target)) {
      return false;
    }
    if (contains(ref(), target)) {
      return false;
    }
    return !props.shouldExcludeElement?.(target);
  };
  const onPointerDown = e => {
    function handler() {
      const container = ref();
      const target = e.target;
      if (!container || !target || !isEventOutside(e)) {
        return;
      }
      const handler = composeEventHandlers([onPointerDownOutside, onInteractOutside]);
      target.addEventListener(POINTER_DOWN_OUTSIDE_EVENT, handler, {
        once: true
      });
      const pointerDownOutsideEvent = new CustomEvent(POINTER_DOWN_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: e,
          isContextMenu: e.button === 2 || isCtrlKey(e) && e.button === 0
        }
      });
      target.dispatchEvent(pointerDownOutsideEvent);
    }

    /**
     * On touch devices, we need to wait for a click event because browsers implement
     * a ~350ms delay between the time the user stops touching the display and when the
     * browser executes events. We need to ensure we don't reactivate pointer-events within
     * this timeframe otherwise the browser may execute events that should have been prevented.
     *
     * Additionally, this also lets us deal automatically with cancellations when a click event
     * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.
     *
     * This is why we also continuously remove the previous listener, because we cannot be
     * certain that it was raised, and therefore cleaned-up.
     */
    if (e.pointerType === "touch") {
      ownerDocument().removeEventListener("click", handler);
      clickHandler = handler;
      ownerDocument().addEventListener("click", handler, {
        once: true
      });
    } else {
      handler();
    }
  };
  const onFocusIn = e => {
    const container = ref();
    const target = e.target;
    if (!container || !target || !isEventOutside(e)) {
      return;
    }
    const handler = composeEventHandlers([onFocusOutside, onInteractOutside]);
    target.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {
      once: true
    });
    const focusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE_EVENT, {
      bubbles: false,
      cancelable: true,
      detail: {
        originalEvent: e,
        isContextMenu: false
      }
    });
    target.dispatchEvent(focusOutsideEvent);
  };
  createEffect(() => {
    if (access(props.isDisabled)) {
      return;
    }

    /**
     * if this primitive executes in a component that mounts via a `pointerdown` event, the event
     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid
     * this by delaying the event listener registration on the document.
     * ```
     * button.addEventListener('pointerdown', () => {
     *   console.log('I will log');
     *   document.addEventListener('pointerdown', () => {
     *     console.log('I will also log');
     *   })
     * });
     */
    pointerDownTimeoutId = window.setTimeout(() => {
      ownerDocument().addEventListener("pointerdown", onPointerDown, true);
    }, 0);
    ownerDocument().addEventListener("focusin", onFocusIn, true);
    onCleanup(() => {
      window.clearTimeout(pointerDownTimeoutId);
      ownerDocument().removeEventListener("click", clickHandler);
      ownerDocument().removeEventListener("pointerdown", onPointerDown, true);
      ownerDocument().removeEventListener("focusin", onFocusIn, true);
    });
  });
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/interactions/src/textSelection.ts
 */

// Safari on iOS starts selecting text on long press. The only way to avoid this, it seems,
// is to add user-select: none to the entire page. Adding it to the pressable element prevents
// that element from being selected, but nearby elements may still receive selection. We add
// user-select: none on touch start, and remove it again on touch end to prevent this.
// This must be implemented using global state to avoid race conditions between multiple elements.

// There are three possible states due to the delay before removing user-select: none after
// pointer up. The 'default' state always transitions to the 'disabled' state, which transitions
// to 'restoring'. The 'restoring' state can either transition back to 'disabled' or 'default'.

// For non-iOS devices, we apply user-select: none to the pressed element instead to avoid possible
// performance issues that arise from applying and removing user-select: none to the entire page
// (see https://github.com/adobe/react-spectrum/issues/1609).

// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element
// rather than at the document level, so we just need to apply/remove user-select: none for each pressed element individually
let state = "default";
let savedUserSelect = "";
const modifiedElementMap = new WeakMap();
function disableTextSelection(target) {
  if (isIOS()) {
    if (state === "default") {
      savedUserSelect = document.documentElement.style.webkitUserSelect;
      document.documentElement.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    // If not iOS, store the target's original user-select and change to user-select: none
    // Ignore state since it doesn't apply for non iOS
    modifiedElementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
}
function restoreTextSelection(target) {
  if (isIOS()) {
    // If the state is already default, there's nothing to do.
    // If it is restoring, then there's no need to queue a second restore.
    if (state !== "disabled") {
      return;
    }
    state = "restoring";

    // There appears to be a delay on iOS where selection still might occur
    // after pointer up, so wait a bit before removing user-select.
    setTimeout(() => {
      // Wait for any CSS transitions to complete, so we don't recompute style
      // for the whole page in the middle of the animation and cause jank.
      runAfterTransition(() => {
        // Avoid race conditions
        if (state === "restoring") {
          if (document.documentElement.style.webkitUserSelect === "none") {
            document.documentElement.style.webkitUserSelect = savedUserSelect || "";
          }
          savedUserSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else if (target instanceof HTMLElement || target instanceof SVGElement) {
    // If not iOS, restore the target's original user-select if any
    // Ignore state since it doesn't apply for non iOS
    if (target && modifiedElementMap.has(target)) {
      const targetOldUserSelect = modifiedElementMap.get(target) ?? "";
      if (target.style.userSelect === "none") {
        target.style.userSelect = targetOldUserSelect;
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      modifiedElementMap.delete(target);
    }
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a9dea8a3672179e6c38aafd1429daf44c7ea2ff6/packages/@react-aria/interactions/src/usePress.ts
 */
const CREATE_PRESS_PROP_NAMES = ["onPressStart", "onPressEnd", "onPressUp", "onPressChange", "onPress", "isDisabled", "preventFocusOnPress", "cancelOnPointerExit", "allowTextSelectionOnPress"];
const PRESS_HANDLERS_PROP_NAMES = ["onKeyDown", "onKeyUp", "onClick", "onPointerDown", "onPointerUp", "onMouseDown", "onDragStart"];

/**
 * Handles press interactions across mouse, touch, keyboard, and screen readers.
 * It normalizes behavior across browsers and platforms, and handles many nuances
 * of dealing with pointer and keyboard events.
 * @param props - Props for the press primitive.
 */
function createPress(props) {
  const [isPressed, setIsPressed] = createSignal(false);
  const state = {
    isPressed: false,
    ignoreEmulatedMouseEvents: false,
    ignoreClickAfterPress: false,
    didFirePressStart: false,
    activePointerId: null,
    isOverTarget: false,
    target: null,
    pointerType: null
  };
  const {
    addGlobalListener,
    removeAllGlobalListeners
  } = createGlobalListeners();
  const triggerPressStart = (originalEvent, pointerType) => {
    if (access(props.isDisabled) || state.didFirePressStart) {
      return;
    }
    props.onPressStart?.({
      type: "pressstart",
      pointerType,
      target: originalEvent.currentTarget,
      shiftKey: originalEvent.shiftKey,
      metaKey: originalEvent.metaKey,
      ctrlKey: originalEvent.ctrlKey,
      altKey: originalEvent.altKey
    });
    props.onPressChange?.(true);
    state.didFirePressStart = true;
    setIsPressed(true);
  };
  const triggerPressEnd = (originalEvent, pointerType, wasPressed = true) => {
    if (!state.didFirePressStart) {
      return;
    }
    state.ignoreClickAfterPress = true;
    state.didFirePressStart = false;
    props.onPressEnd?.({
      type: "pressend",
      pointerType,
      target: originalEvent.currentTarget,
      shiftKey: originalEvent.shiftKey,
      metaKey: originalEvent.metaKey,
      ctrlKey: originalEvent.ctrlKey,
      altKey: originalEvent.altKey
    });
    props.onPressChange?.(false);
    setIsPressed(false);
    if (wasPressed && !access(props.isDisabled)) {
      props.onPress?.({
        type: "press",
        pointerType,
        target: originalEvent.currentTarget,
        shiftKey: originalEvent.shiftKey,
        metaKey: originalEvent.metaKey,
        ctrlKey: originalEvent.ctrlKey,
        altKey: originalEvent.altKey
      });
    }
  };
  const triggerPressUp = (originalEvent, pointerType) => {
    if (access(props.isDisabled)) {
      return;
    }
    props.onPressUp?.({
      type: "pressup",
      pointerType,
      target: originalEvent.currentTarget,
      shiftKey: originalEvent.shiftKey,
      metaKey: originalEvent.metaKey,
      ctrlKey: originalEvent.ctrlKey,
      altKey: originalEvent.altKey
    });
  };
  const cancel = e => {
    if (!state.isPressed) {
      return;
    }
    if (state.isOverTarget) {
      triggerPressEnd(createEvent(state.target, e), state.pointerType, false);
    }
    state.isPressed = false;
    state.isOverTarget = false;
    state.activePointerId = null;
    state.pointerType = null;
    removeAllGlobalListeners();
    if (!access(props.allowTextSelectionOnPress)) {
      restoreTextSelection(state.target ?? undefined);
    }
  };
  const globalOnKeyUp = e => {
    if (state.isPressed && isValidKeyboardEvent(e, state.target)) {
      if (shouldPreventDefaultKeyboard(e.target, e.key)) {
        e.preventDefault();
      }
      e.stopPropagation();
      state.isPressed = false;
      const target = e.target;
      triggerPressEnd(createEvent(state.target, e), "keyboard", state.target?.contains(target));
      removeAllGlobalListeners();

      // If the target is a link, trigger the click method to open the URL,
      // but defer triggering pressEnd until onClick event handler.
      if (state.target instanceof HTMLElement && state.target.contains(target) && (isHTMLAnchorLink(state.target) || state.target.getAttribute("role") === "link")) {
        state.target.click();
      }
    }
  };

  // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.
  // Use pointer move events instead to implement our own hit testing.
  // See https://bugs.webkit.org/show_bug.cgi?id=199803
  const globalOnPointerMove = e => {
    if (e.pointerId !== state.activePointerId) {
      return;
    }
    if (isPointOverTarget(e, state.target)) {
      if (!state.isOverTarget) {
        state.isOverTarget = true;
        triggerPressStart(createEvent(state.target, e), state.pointerType);
      }
    } else if (state.isOverTarget) {
      state.isOverTarget = false;
      triggerPressEnd(createEvent(state.target, e), state.pointerType, false);
      if (access(props.cancelOnPointerExit)) {
        cancel(e);
      }
    }
  };
  const globalOnPointerUp = e => {
    if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {
      if (isPointOverTarget(e, state.target)) {
        triggerPressEnd(createEvent(state.target, e), state.pointerType);
      } else if (state.isOverTarget) {
        triggerPressEnd(createEvent(state.target, e), state.pointerType, false);
      }
      state.isPressed = false;
      state.isOverTarget = false;
      state.activePointerId = null;
      state.pointerType = null;
      removeAllGlobalListeners();
      if (!access(props.allowTextSelectionOnPress)) {
        restoreTextSelection(state.target ?? undefined);
      }
    }
  };
  const globalOnPointerCancel = e => {
    cancel(e);
  };
  const onKeyDown = e => {
    if (isValidKeyboardEvent(e, e.currentTarget) && e.currentTarget.contains(e.target)) {
      if (shouldPreventDefaultKeyboard(e.target, e.key)) {
        e.preventDefault();
      }
      e.stopPropagation();

      // If the event is repeating, it may have started on a different element
      // after which focus moved to the current element. Ignore these events and
      // only handle the first key down event.
      if (!state.isPressed && !e.repeat) {
        state.target = e.currentTarget;
        state.isPressed = true;
        triggerPressStart(e, "keyboard");

        // Focus may move before the key up event, so register the event on the document
        // instead of the same element where the key down event occurred.
        addGlobalListener(document, "keyup", globalOnKeyUp, false);
      }
    } else if (e.key === EventKey.Enter && isHTMLAnchorLink(e.currentTarget)) {
      // If the target is a link, we won't have handled this above because we want the default
      // browser behavior to open the link when pressing Enter. But we still need to prevent
      // default so that elements above do not also handle it (e.g. table row).
      e.stopPropagation();
    }
  };
  const onKeyUp = e => {
    if (isValidKeyboardEvent(e, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) {
      triggerPressUp(createEvent(state.target, e), "keyboard");
    }
  };
  const onClick = e => {
    if (e && !e.currentTarget.contains(e.target)) {
      return;
    }
    if (e && e.button === 0) {
      e.stopPropagation();
      if (access(props.isDisabled)) {
        e.preventDefault();
      }

      // If triggered from a screen reader or by using element.click(),
      // trigger as if it were a keyboard click.
      if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === "virtual" || isVirtualClick(e))) {
        // Ensure the element receives focus (VoiceOver on iOS does not do this)
        if (!access(props.isDisabled) && !access(props.preventFocusOnPress)) {
          focusWithoutScrolling(e.currentTarget);
        }
        triggerPressStart(e, "virtual");
        triggerPressUp(e, "virtual");
        triggerPressEnd(e, "virtual");
      }
      state.ignoreEmulatedMouseEvents = false;
      state.ignoreClickAfterPress = false;
    }
  };
  const onPointerDown = e => {
    // Only handle left clicks, and ignore events that bubbled through portals.
    if (e.button !== 0 || !e.currentTarget.contains(e.target)) {
      return;
    }

    // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.
    // Ignore and let the onClick handler take care of it instead.
    // https://bugs.webkit.org/show_bug.cgi?id=222627
    // https://bugs.webkit.org/show_bug.cgi?id=223202
    if (isVirtualPointerEvent(e)) {
      state.pointerType = "virtual";
      return;
    }

    // Due to browser inconsistencies, especially on mobile browsers, we prevent
    // default on pointer down and handle focusing the pressable element ourselves.
    if (shouldPreventDefault(e.currentTarget)) {
      e.preventDefault();
    }
    state.pointerType = e.pointerType;
    e.stopPropagation();
    if (state.isPressed) {
      return;
    }
    state.isPressed = true;
    state.isOverTarget = true;
    state.activePointerId = e.pointerId;
    state.target = e.currentTarget;
    if (!access(props.isDisabled) && !access(props.preventFocusOnPress)) {
      focusWithoutScrolling(e.currentTarget);
    }
    if (!access(props.allowTextSelectionOnPress)) {
      disableTextSelection(state.target ?? undefined);
    }
    triggerPressStart(e, state.pointerType);
    addGlobalListener(document, "pointermove", globalOnPointerMove, false);
    addGlobalListener(document, "pointerup", globalOnPointerUp, false);
    addGlobalListener(document, "pointercancel", globalOnPointerCancel, false);
  };
  const onPointerUp = e => {
    // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.
    if (!e.currentTarget.contains(e.target) || state.pointerType === "virtual") {
      return;
    }

    // Only handle left clicks
    // Safari on iOS sometimes fires pointerup events, even
    // when the touch isn't over the target, so double check.
    if (e.button === 0 && isPointOverTarget(e, e.currentTarget)) {
      triggerPressUp(e, state.pointerType ?? e.pointerType);
    }
  };
  const onMouseDown = e => {
    if (!e.currentTarget.contains(e.target)) {
      return;
    }
    if (e.button === 0) {
      // Chrome and Firefox on touch Windows devices require mouse down events
      // to be canceled in addition to pointer events, or an extra asynchronous
      // focus event will be fired.
      if (shouldPreventDefault(e.currentTarget)) {
        e.preventDefault();
      }
      e.stopPropagation();
    }
  };
  const onDragStart = e => {
    if (!e.currentTarget.contains(e.target)) {
      return;
    }

    // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.
    cancel(e);
  };

  // Remove user-select: none in case component unmounts immediately after pressStart
  createEffect(on(() => access(props.allowTextSelectionOnPress), allowTextSelectionOnPress => {
    onCleanup(() => {
      if (!allowTextSelectionOnPress) {
        restoreTextSelection(state.target ?? undefined);
      }
    });
  }));
  return {
    isPressed,
    pressHandlers: {
      onKeyDown,
      onKeyUp,
      onClick,
      onPointerDown,
      onPointerUp,
      onMouseDown,
      onDragStart
    }
  };
}
function isHTMLAnchorLink(target) {
  return target.tagName === "A" && target.hasAttribute("href");
}
function isValidKeyboardEvent(event, currentTarget) {
  const {
    key,
    code
  } = event;
  const element = currentTarget;
  const role = element.getAttribute("role");

  // Accessibility for keyboards. Space and Enter only.
  return (key === EventKey.Enter || key === EventKey.Space || code === "Space") && !(element instanceof HTMLInputElement && !isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && (
  // A link with a valid href should be handled natively,
  // unless it also has role='button' and was triggered using Space.
  !isHTMLAnchorLink(element) || role === "button" && key !== EventKey.Enter) &&
  // An element with role='link' should only trigger with Enter key
  !(role === "link" && key !== EventKey.Enter);
}
function createEvent(target, e) {
  return {
    currentTarget: target,
    shiftKey: e.shiftKey,
    ctrlKey: e.ctrlKey,
    metaKey: e.metaKey,
    altKey: e.altKey
  };
}
function getPointClientRect(point) {
  const offsetX = (point.width ?? 0) / 2 || point.radiusX || 0;
  const offsetY = (point.height ?? 0) / 2 || point.radiusY || 0;
  return {
    top: point.clientY - offsetY,
    right: point.clientX + offsetX,
    bottom: point.clientY + offsetY,
    left: point.clientX - offsetX
  };
}
function areRectanglesOverlapping(a, b) {
  // check if they cannot overlap on x-axis
  if (a.left > b.right || b.left > a.right) {
    return false;
  }

  // check if they cannot overlap on y-axis
  if (a.top > b.bottom || b.top > a.bottom) {
    return false;
  }
  return true;
}
function isPointOverTarget(point, target) {
  const rect = target.getBoundingClientRect();
  const pointRect = getPointClientRect(point);
  return areRectanglesOverlapping(rect, pointRect);
}
function shouldPreventDefault(target) {
  // We cannot prevent default if the target is a draggable element.
  return !(target instanceof HTMLElement) || !target.draggable;
}
function shouldPreventDefaultKeyboard(target, key) {
  if (target instanceof HTMLInputElement) {
    return !isValidInputKey(target, key);
  }
  if (target instanceof HTMLButtonElement) {
    return target.type !== "submit";
  }
  return true;
}
const NON_TEXT_INPUT_TYPES = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);
function isValidInputKey(target, key) {
  // Only space should toggle checkboxes and radios, not enter.
  return target.type === "checkbox" || target.type === "radio" ? key === EventKey.Space : NON_TEXT_INPUT_TYPES.has(target.type);
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/6b51339cca0b8344507d3c8e81e7ad05d6e75f9b/packages/@react-aria/interactions/src/useLongPress.ts
 */
const CREATE_LONG_PRESS_PROP_NAMES = ["onLongPressStart", "onLongPressEnd", "onLongPress", "isDisabled", "threshold"];

/**
 * Handles long press interactions across mouse and touch devices. Supports a customizable time threshold,
 * and normalizes behavior across browsers and devices.
 */
function createLongPress(props) {
  props = mergeDefaultProps({
    threshold: 500
  }, props);
  let timeoutId;
  const {
    addGlobalListener,
    removeGlobalListener
  } = createGlobalListeners();
  const isDisabled = () => access(props.isDisabled) ?? false;
  const onPressStart = e => {
    if (e.pointerType === "mouse" || e.pointerType === "touch") {
      props.onLongPressStart?.({
        ...e,
        type: "longpressstart"
      });
      timeoutId = window.setTimeout(() => {
        // Prevent other usePress handlers from also handling this event.
        e.target.dispatchEvent(new PointerEvent("pointercancel", {
          bubbles: true
        }));
        props.onLongPress?.({
          ...e,
          type: "longpress"
        });
        timeoutId = undefined;
      }, access(props.threshold));

      // Prevent context menu, which may be opened on long press on touch devices
      if (e.pointerType === "touch") {
        const onContextMenu = e => {
          e.preventDefault();
        };
        addGlobalListener(e.target, "contextmenu", onContextMenu, {
          once: true
        });
        addGlobalListener(window, "pointerup", () => {
          // If no contextmenu event is fired quickly after pointerup, remove the handler
          // so future context menu events outside a long press are not prevented.
          setTimeout(() => {
            removeGlobalListener(e.target, "contextmenu", onContextMenu);
          }, 30);
        }, {
          once: true
        });
      }
    }
  };
  const onPressEnd = e => {
    if (timeoutId) {
      window.clearTimeout(timeoutId);
    }
    if (e.pointerType === "mouse" || e.pointerType === "touch") {
      props.onLongPressEnd?.({
        ...e,
        type: "longpressend"
      });
    }
  };
  const {
    isPressed,
    pressHandlers: longPressHandlers
  } = createPress({
    isDisabled,
    onPressStart,
    onPressEnd
  });
  return {
    isPressed,
    longPressHandlers
  };
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/21a7c97dc8efa79fecca36428eec49f187294085/packages/react/presence/src/Presence.tsx
 * https://github.com/radix-ui/primitives/blob/21a7c97dc8efa79fecca36428eec49f187294085/packages/react/presence/src/useStateMachine.tsx
 */
function createPresence(present) {
  const [node, setNode] = createSignal();
  let styles = {};
  let prevPresent = present();
  let prevAnimationName = "none";
  const [state, send] = createStateMachine(present() ? "mounted" : "unmounted", {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  createEffect(on(state, state => {
    const currentAnimationName = getAnimationName(styles);
    prevAnimationName = state === "mounted" ? currentAnimationName : "none";
  }));
  createEffect(on(present, present => {
    if (prevPresent === present) {
      return;
    }
    const currentAnimationName = getAnimationName(styles);
    if (present) {
      send("MOUNT");
      //} else if (currentAnimationName === "none" || styles?.display === "none") {
      // If there is no exit animation or the element is hidden, animations won't run, so we unmount instantly
    } else if (styles?.display === "none") {
      // If the element is hidden, animations won't run, so we unmount instantly
      send("UNMOUNT");
    } else {
      /**
       * When `present` changes to `false`, we check changes to animation-name to
       * determine whether an animation has started. We chose this approach (reading
       * computed styles) because there is no `animationrun` event and `animationstart`
       * fires after `animation-delay` has expired which would be too late.
       */
      const isAnimating = prevAnimationName !== currentAnimationName;
      if (prevPresent && isAnimating) {
        send("ANIMATION_OUT");
      } else {
        send("UNMOUNT");
      }
    }
    prevPresent = present;
  }));
  createEffect(on(node, node => {
    if (node) {
      /**
       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`
       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we
       * make sure we only trigger ANIMATION_END for the currently active animation.
       */
      const handleAnimationEnd = event => {
        const currentAnimationName = getAnimationName(styles);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
        }
      };
      const handleAnimationStart = event => {
        if (event.target === node) {
          // if animation occurred, store its name as the previous animation.
          prevAnimationName = getAnimationName(styles);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      onCleanup(() => {
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      });
    } else {
      // Transition to the unmounted state if the node is removed prematurely.
      // We avoid doing so during cleanup as the node may change but still exist.
      send("ANIMATION_END");
    }
  }));
  return {
    isPresent: () => ["mounted", "unmountSuspended"].includes(state()),
    setRef: el => {
      if (el) {
        styles = getComputedStyle(el);
      }
      setNode(el);
    }
  };
}

/* -----------------------------------------------------------------------------------------------*/

function getAnimationName(styles) {
  return styles?.animationName || "none";
}

// https://fettblog.eu/typescript-union-to-intersection/

function createStateMachine(initialState, machine) {
  const reduce = (state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  };
  const [state, setState] = createSignal(initialState);
  const send = event => {
    setState(prev => reduce(prev, event));
  };
  return [state, send];
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/892d41e82dc781fb4651455d0e29c324376659ed/packages/@react-aria/overlays/src/usePreventScroll.ts
 */
const visualViewport = typeof window !== "undefined" && window.visualViewport;

// HTML input types that do not cause the software keyboard to appear.
const nonTextInputTypes = new Set(["checkbox", "radio", "range", "color", "file", "image", "button", "submit", "reset"]);

/**
 * Prevents scrolling on the document body on mount, and
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */
function createPreventScroll(options) {
  createEffect(on(() => access(options.isDisabled), disabled => {
    if (disabled) {
      return;
    }
    if (isIOS()) {
      onCleanup(preventScrollMobileSafari());
    } else {
      onCleanup(preventScrollStandard());
    }
  }));
}

// For most browsers, all we need to do is set `overflow: hidden` on the root element, and
// add some padding to prevent the page from shifting when the scrollbar is hidden.
function preventScrollStandard() {
  return chain([setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), setStyle(document.documentElement, "overflow", "hidden")]);
}

// Mobile Safari is a whole different beast. Even with overflow: hidden,
// it still scrolls the page in many situations:
//
// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.
// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of
//    it, so it becomes scrollable.
// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.
//    This may cause even fixed position elements to scroll off the screen.
// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always
//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.
//
// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:
//
// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling
//    on the window.
// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the
//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.
// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.
// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top
//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element
//    into view ourselves, without scrolling the whole page.
// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the
//    same visually, but makes the actual scroll position always zero. This is required to make all of the
//    above work or Safari will still try to scroll the page when focusing an input.
// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting
//    to navigate to an input with the next/previous buttons that's outside a modal.
function preventScrollMobileSafari() {
  let scrollable;
  let lastY = 0;
  const onTouchStart = e => {
    // Store the nearest scrollable parent element from the element that the user touched.
    scrollable = getScrollParent(e.target);
    if (scrollable === document.documentElement && scrollable === document.body) {
      return;
    }
    lastY = e.changedTouches[0].pageY;
  };
  const onTouchMove = e => {
    // Prevent scrolling the window.
    if (scrollable === document.documentElement || scrollable === document.body) {
      e.preventDefault();
      return;
    }

    // Prevent scrolling up when at the top and scrolling down when at the bottom
    // of a nested scrollable area, otherwise mobile Safari will start scrolling
    // the window instead. Unfortunately, this disables bounce scrolling when at
    // the top, but it's the best we can do.
    const y = e.changedTouches[0].pageY;
    const scrollTop = scrollable.scrollTop;
    const bottom = scrollable.scrollHeight - scrollable.clientHeight;
    if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) {
      e.preventDefault();
    }
    lastY = y;
  };
  const onTouchEnd = e => {
    const target = e.target;

    // Apply this change if we're not already focused on the target element
    if (willOpenKeyboard(target) && target !== document.activeElement) {
      e.preventDefault();

      // Apply a transform to trick Safari into thinking the input is at the top of the page,
      // so it doesn't try to scroll it into view. When tapping on an input, this needs to
      // be done before the "focus" event, so we have to focus the element ourselves.
      target.style.transform = "translateY(-2000px)";
      target.focus();
      requestAnimationFrame(() => {
        target.style.transform = "";
      });
    }
  };
  const onFocus = e => {
    const target = e.target;
    if (willOpenKeyboard(target)) {
      // Transform also needs to be applied in the focus event in cases where focus moves
      // other than tapping on an input directly, e.g. the next/previous buttons in the
      // software keyboard. In these cases, it seems applying the transform in the focus event
      // is good enough, whereas when tapping an input, it must be done before the focus event.
      target.style.transform = "translateY(-2000px)";
      requestAnimationFrame(() => {
        target.style.transform = "";

        // This will have prevented the browser from scrolling the focused element into view,
        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.
        if (visualViewport) {
          if (visualViewport.height < window.innerHeight) {
            // If the keyboard is already visible, do this after one additional frame
            // to wait for the transform to be removed.
            requestAnimationFrame(() => {
              scrollIntoView(target);
            });
          } else {
            // Otherwise, wait for the visual viewport to resize before scrolling, so we can
            // measure the correct position to scroll to.
            visualViewport.addEventListener("resize", () => scrollIntoView(target), {
              once: true
            });
          }
        }
      });
    }
  };
  const onWindowScroll = () => {
    // Last resort. If the window scrolled, scroll it back to the top.
    // It should always be at the top because the body will have a negative margin (see below).
    window.scrollTo(0, 0);
  };

  // Record the original scroll position, so we can restore it.
  // Then apply a negative margin to the body to offset it by the scroll position. This will
  // enable us to scroll the window to the top, which is required for the rest of this to work.
  const scrollX = window.pageXOffset;
  const scrollY = window.pageYOffset;
  const restoreStyles = chain([setStyle(document.documentElement, "paddingRight", `${window.innerWidth - document.documentElement.clientWidth}px`), setStyle(document.documentElement, "overflow", "hidden"), setStyle(document.body, "marginTop", `-${scrollY}px`)]);

  // Scroll to the top. The negative margin on the body will make this appear the same.
  window.scrollTo(0, 0);
  const removeEvents = chain([addEvent(document, "touchstart", onTouchStart, {
    passive: false,
    capture: true
  }), addEvent(document, "touchmove", onTouchMove, {
    passive: false,
    capture: true
  }), addEvent(document, "touchend", onTouchEnd, {
    passive: false,
    capture: true
  }), addEvent(document, "focus", onFocus, true), addEvent(window, "scroll", onWindowScroll)]);
  return () => {
    // Restore styles and scroll the page back to where it was.
    restoreStyles();
    removeEvents();
    window.scrollTo(scrollX, scrollY);
  };
}

/**
 * Sets a CSS property on an element, and returns a function to revert it to the previous value.
 */
function setStyle(element, style, value) {
  const cur = element.style[style];
  element.style[style] = value;
  return () => {
    element.style[style] = cur;
  };
}

/**
 * Adds an event listener to an element, and returns a function to remove it.
 */
function addEvent(target, event, handler, options) {
  target.addEventListener(event, handler, options);
  return () => {
    target.removeEventListener(event, handler, options);
  };
}
function scrollIntoView(target) {
  const root = document.scrollingElement || document.documentElement;
  while (target && target !== root) {
    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.
    const scrollable = getScrollParent(target);
    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {
      const scrollableTop = scrollable.getBoundingClientRect().top;
      const targetTop = target.getBoundingClientRect().top;
      if (targetTop > scrollableTop + target.clientHeight) {
        scrollable.scrollTop += targetTop - scrollableTop;
      }
    }
    target = scrollable.parentElement;
  }
}
function willOpenKeyboard(target) {
  return target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;
}

/**
 * Create a function that call the setter with an id and return a function to reset it.
 */
function createRegisterId(setter) {
  return id => {
    setter(id);
    return () => setter(undefined);
  };
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the ariakit team:
 * https://github.com/ariakit/ariakit/blob/8a13899ff807bbf39f3d89d2d5964042ba4d5287/packages/ariakit-react-utils/src/hooks.ts
 */

/**
 * Returns the tag name by parsing an element ref.
 * @example
 * function Component(props) {
 *   let ref: HTMLDivElement | undefined;
 *   const tagName = createTagName(() => ref, () => "button"); // div
 *   return <div ref={ref} {...props} />;
 * }
 */
function createTagName(ref, fallback) {
  const [tagName, setTagName] = createSignal(stringOrUndefined(fallback?.()));
  createEffect(() => {
    setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));
  });
  return tagName;
}
function stringOrUndefined(value) {
  return isString(value) ? value : undefined;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/a13802d8be6f83af1450e56f7a88527b10d9cadf/packages/@react-stately/toggle/src/useToggleState.ts
 */
/**
 * Provides state management for toggle components like checkboxes and switches.
 */
function createToggleState(props = {}) {
  const [isSelected, _setIsSelected] = createControllableBooleanSignal({
    value: () => access(props.isSelected),
    defaultValue: () => !!access(props.defaultIsSelected),
    onChange: value => props.onSelectedChange?.(value)
  });
  const setIsSelected = value => {
    if (!access(props.isReadOnly) && !access(props.isDisabled)) {
      _setIsSelected(value);
    }
  };
  const toggle = () => {
    if (!access(props.isReadOnly) && !access(props.isDisabled)) {
      _setIsSelected(!isSelected());
    }
  };
  return {
    isSelected,
    setIsSelected,
    toggle
  };
}

/*!
 * Portions of this file are based on code from mantinedev.
 * MIT Licensed, Copyright (c) 2021 Vitaly Rtishchev.
 *
 * Credits to the Mantinedev team:
 * https://github.com/mantinedev/mantine/blob/8546c580fdcaa9653edc6f4813103349a96cfb09/src/mantine-core/src/Transition/get-transition-styles/get-transition-styles.ts
 */

const TRANSITION_PHASES_MAP = {
  beforeEnter: "out",
  enter: "in",
  afterEnter: "in",
  beforeExit: "in",
  //"out",
  exit: "out",
  afterExit: "out"
};
function getTransitionStyles(params) {
  const shared = {
    "transition-duration": `${params.duration}ms`,
    "transition-timing-function": params.easing
  };
  return {
    "transition-property": getTransitionProperty(params.transition),
    ...shared,
    ...params.transition.common,
    ...params.transition[TRANSITION_PHASES_MAP[params.phase]]
  };
}
function getTransitionProperty(transitionStyles) {
  return [...new Set([...Object.keys(transitionStyles.in), ...Object.keys(transitionStyles.out)])].join(", ");
}

/*!
 * Portions of this file are based on code from mantinedev.
 * MIT Licensed, Copyright (c) 2021 Vitaly Rtishchev.
 *
 * Credits to the Mantinedev team:
 * https://github.com/mantinedev/mantine/blob/8546c580fdcaa9653edc6f4813103349a96cfb09/src/mantine-core/src/Transition/use-transition.ts
 */
const DEFAULT_DURATION = 250;
const DEFAULT_DELAY = 10;
const DEFAULT_EASING = "ease";

/**
 * Primitive for working with enter/exit transitions.
 *
 * @param shouldMount Whether the component should be mounted.
 * @param options The transition options.
 */
function createTransition(shouldMount, options) {
  options = mergeProps({
    duration: DEFAULT_DURATION,
    delay: DEFAULT_DELAY,
    easing: DEFAULT_EASING,
    get exitDuration() {
      return access(options).duration || DEFAULT_DURATION;
    },
    get exitDelay() {
      return access(options).delay || DEFAULT_DELAY;
    },
    get exitEasing() {
      return access(options).easing || DEFAULT_EASING;
    }
  }, options);
  const reduceMotion = createMediaQuery("(prefers-reduced-motion: reduce)");
  const [duration, setDuration] = createSignal(reduceMotion() ? 0 : access(options).duration);
  const [phase, setPhase] = createSignal(access(shouldMount) ? "afterEnter" : "afterExit");
  const [easing, setEasing] = createSignal(access(options).easing);
  let timeoutId = -1;
  const handleStateChange = shouldMount => {
    const preHandler = shouldMount ? access(options).onBeforeEnter : access(options).onBeforeExit;
    const postHandler = shouldMount ? access(options).onAfterEnter : access(options).onAfterExit;
    setPhase(shouldMount ? "beforeEnter" : "beforeExit");
    window.clearTimeout(timeoutId);
    const newDuration = setDuration(reduceMotion() ? 0 : shouldMount ? access(options).duration : access(options).exitDuration);
    setEasing(shouldMount ? access(options).easing : access(options).exitEasing);
    if (newDuration === 0) {
      preHandler?.();
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
      return;
    }
    const delay = reduceMotion() ? 0 : shouldMount ? access(options).delay : access(options).exitDelay;
    const preStateTimeoutId = window.setTimeout(() => {
      preHandler?.();
      setPhase(shouldMount ? "enter" : "exit");
    }, delay);
    timeoutId = window.setTimeout(() => {
      window.clearTimeout(preStateTimeoutId);
      postHandler?.();
      setPhase(shouldMount ? "afterEnter" : "afterExit");
    }, delay + newDuration);
  };
  const style = createMemo(() => getTransitionStyles({
    transition: access(options).transition,
    duration: duration(),
    phase: phase(),
    easing: easing()
  }));
  const keepMounted = createMemo(() => phase() !== "afterExit");
  createEffect(on(() => access(shouldMount), shouldMount => handleStateChange(shouldMount), {
    defer: true
  }));
  onCleanup(() => {
    if (isServer) {
      return;
    }
    window.clearTimeout(timeoutId);
  });
  return {
    keepMounted,
    style
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/70e7caf1946c423bc9aa9cb0e50dbdbe953d239b/packages/@react-aria/label/src/useField.ts
 */
const FORM_CONTROL_PROP_NAMES = ["id", "name", "validationState", "isRequired", "isDisabled", "isReadOnly"];
function createFormControl(props) {
  const defaultId = `form-control-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId
  }, props);
  const [labelId, setLabelId] = createSignal();
  const [fieldId, setFieldId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [errorMessageId, setErrorMessageId] = createSignal();
  const getAriaLabelledBy = (fieldId, fieldAriaLabel, fieldAriaLabelledBy) => {
    const hasAriaLabelledBy = fieldAriaLabelledBy != null || labelId() != null;
    return [fieldAriaLabelledBy, labelId(),
    // If there is both an aria-label and aria-labelledby, add the field itself has an aria-labelledby
    hasAriaLabelledBy && fieldAriaLabel != null ? fieldId : undefined].filter(Boolean).join(" ") || undefined;
  };
  const getAriaDescribedBy = fieldAriaDescribedBy => {
    return [descriptionId(),
    // Use aria-describedby for error message because aria-errormessage is unsupported using VoiceOver or NVDA.
    // See https://github.com/adobe/react-spectrum/issues/1346#issuecomment-740136268
    errorMessageId(), fieldAriaDescribedBy].filter(Boolean).join(" ") || undefined;
  };
  const dataset = createMemo(() => ({
    "data-valid": access(props.validationState) === "valid" ? "" : undefined,
    "data-invalid": access(props.validationState) === "invalid" ? "" : undefined,
    "data-required": access(props.isRequired) ? "" : undefined,
    "data-disabled": access(props.isDisabled) ? "" : undefined,
    "data-readonly": access(props.isReadOnly) ? "" : undefined
  }));
  const formControlContext = {
    name: () => access(props.name) ?? access(props.id),
    dataset,
    validationState: () => access(props.validationState),
    isRequired: () => access(props.isRequired),
    isDisabled: () => access(props.isDisabled),
    isReadOnly: () => access(props.isReadOnly),
    labelId,
    fieldId,
    descriptionId,
    errorMessageId,
    getAriaLabelledBy,
    getAriaDescribedBy,
    generateId: createGenerateId(() => access(props.id)),
    registerLabel: createRegisterId(setLabelId),
    registerField: createRegisterId(setFieldId),
    registerDescription: createRegisterId(setDescriptionId),
    registerErrorMessage: createRegisterId(setErrorMessageId)
  };
  return {
    formControlContext
  };
}

const FormControlContext = createContext();
function useFormControlContext() {
  const context = useContext(FormControlContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useFormControlContext` must be used within a `FormControlContext.Provider` component");
  }
  return context;
}

const FORM_CONTROL_FIELD_PROP_NAMES = ["id", "aria-label", "aria-labelledby", "aria-describedby"];
function createFormControlField(props) {
  const context = useFormControlContext();
  props = mergeDefaultProps({
    id: context.generateId("field")
  }, props);
  createEffect(() => onCleanup(context.registerField(access(props.id))));
  return {
    fieldProps: {
      id: () => access(props.id),
      ariaLabel: () => access(props["aria-label"]),
      ariaLabelledBy: () => context.getAriaLabelledBy(access(props.id), access(props["aria-label"]), access(props["aria-labelledby"])),
      ariaDescribedBy: () => context.getAriaDescribedBy(access(props["aria-describedby"]))
    }
  };
}

/**
 * The description that gives the user more information on the form control.
 */
const FormControlDescription = createPolymorphicComponent(props => {
  const context = useFormControlContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerDescription(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
});

/**
 * The error message that gives the user information about how to fix a validation error on the form control.
 */
const FormControlErrorMessage = createPolymorphicComponent(props => {
  const context = useFormControlContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("error-message")
  }, props);
  const [local, others] = splitProps(props, ["as", "id", "forceMount"]);
  const isInvalid = () => context.validationState() === "invalid";
  createEffect(() => {
    if (!isInvalid()) {
      return;
    }
    onCleanup(context.registerErrorMessage(local.id));
  });
  return createComponent(Show, {
    get when() {
      return local.forceMount || isInvalid();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        get id() {
          return local.id;
        }
      }, () => context.dataset(), others));
    }
  });
});

/**
 * The label that gives the user information on the form control.
 */
const FormControlLabel = createPolymorphicComponent(props => {
  let ref;
  const context = useFormControlContext();
  props = mergeDefaultProps({
    as: "label",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "id"]);
  const tagName = createTagName(() => ref, () => local.as || "label");
  createEffect(() => onCleanup(context.registerLabel(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get ["for"]() {
      return memo(() => tagName() === "label")() ? context.fieldId() : undefined;
    }
  }, () => context.dataset(), others));
});

const COMMON_INTL_MESSAGES = {
  "ar-AE": {
    dismiss: "تجاهل"
  },
  "bg-BG": {
    dismiss: "Отхвърляне"
  },
  "cs-CZ": {
    dismiss: "Odstranit"
  },
  "da-DK": {
    dismiss: "Luk"
  },
  "de-DE": {
    dismiss: "Schließen"
  },
  "el-GR": {
    dismiss: "Απόρριψη"
  },
  "en-US": {
    dismiss: "Dismiss"
  },
  "es-ES": {
    dismiss: "Descartar"
  },
  "et-EE": {
    dismiss: "Lõpeta"
  },
  "fi-FI": {
    dismiss: "Hylkää"
  },
  "fr-FR": {
    dismiss: "Rejeter"
  },
  "he-IL": {
    dismiss: "התעלם"
  },
  "hr-HR": {
    dismiss: "Odbaci"
  },
  "hu-HU": {
    dismiss: "Elutasítás"
  },
  "it-IT": {
    dismiss: "Ignora"
  },
  "ja-JP": {
    dismiss: "閉じる"
  },
  "ko-KR": {
    dismiss: "무시"
  },
  "lt-LT": {
    dismiss: "Atmesti"
  },
  "lv-LV": {
    dismiss: "Nerādīt"
  },
  "nb-NO": {
    dismiss: "Lukk"
  },
  "nl-NL": {
    dismiss: "Negeren"
  },
  "pl-PL": {
    dismiss: "Zignoruj"
  },
  "pt-BR": {
    dismiss: "Descartar"
  },
  "pt-PT": {
    dismiss: "Dispensar"
  },
  "ro-RO": {
    dismiss: "Revocare"
  },
  "ru-RU": {
    dismiss: "Пропустить"
  },
  "sk-SK": {
    dismiss: "Zrušiť"
  },
  "sl-SI": {
    dismiss: "Opusti"
  },
  "sr-SP": {
    dismiss: "Odbaci"
  },
  "sv-SE": {
    dismiss: "Avvisa"
  },
  "tr-TR": {
    dismiss: "Kapat"
  },
  "uk-UA": {
    dismiss: "Скасувати"
  },
  "zh-CN": {
    dismiss: "取消"
  },
  "zh-TW": {
    dismiss: "關閉"
  }
};

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/utils.ts
 */

// https://en.wikipedia.org/wiki/Right-to-left
const RTL_SCRIPTS = new Set(["Avst", "Arab", "Armi", "Syrc", "Samr", "Mand", "Thaa", "Mend", "Nkoo", "Adlm", "Rohg", "Hebr"]);
const RTL_LANGS = new Set(["ae", "ar", "arc", "bcc", "bqi", "ckb", "dv", "fa", "glk", "he", "ku", "mzn", "nqo", "pnb", "ps", "sd", "ug", "ur", "yi"]);

/**
 * Determines if a locale is read right to left using [Intl.Locale]
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale}.
 */
function isRTL(locale) {
  // If the Intl.Locale API is available, use it to get the script for the locale.
  // This is more accurate than guessing by language, since languages can be written in multiple scripts.
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }

  // If not, just guess by the language (first part of the locale)
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}
function getReadingDirection(locale) {
  return isRTL(locale) ? "rtl" : "ltr";
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useDefaultLocale.ts
 */
/**
 * Gets the locale setting of the browser.
 */
function getDefaultLocale() {
  let locale =
  // @ts-ignore
  typeof navigator !== "undefined" && (navigator.language || navigator.userLanguage) || "en-US";
  try {
    Intl.DateTimeFormat.supportedLocalesOf([locale]);
  } catch (_err) {
    locale = "en-US";
  }
  return {
    locale,
    direction: getReadingDirection(locale)
  };
}
let currentLocale = getDefaultLocale();
const listeners = new Set();
function updateLocale() {
  currentLocale = getDefaultLocale();
  for (const listener of listeners) {
    listener(currentLocale);
  }
}

/**
 * Returns an accessor for the current browser/system language, and updates when it changes.
 */
function createDefaultLocale() {
  // We cannot determine the browser's language on the server, so default to en-US.
  // This will be updated after hydration on the client to the correct value.
  const defaultSSRLocale = {
    locale: "en-US",
    direction: "ltr"
  };
  const [defaultClientLocale, setDefaultClientLocale] = createSignal(currentLocale);
  const defaultLocale = createMemo(() => isServer ? defaultSSRLocale : defaultClientLocale());
  onMount(() => {
    if (listeners.size === 0) {
      window.addEventListener("languagechange", updateLocale);
    }
    listeners.add(setDefaultClientLocale);
    onCleanup(() => {
      listeners.delete(setDefaultClientLocale);
      if (listeners.size === 0) {
        window.removeEventListener("languagechange", updateLocale);
      }
    });
  });
  return {
    locale: () => defaultLocale().locale,
    direction: () => defaultLocale().direction
  };
}

const I18nContext = createContext();

/**
 * Provides the locale for the application to all child components.
 */
function I18nProvider(props) {
  const defaultLocale = createDefaultLocale();
  const context = {
    locale: () => props.locale ?? defaultLocale.locale(),
    direction: () => props.locale ? getReadingDirection(props.locale) : defaultLocale.direction()
  };
  return createComponent(I18nContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
}

/**
 * Returns an accessor for the current locale and layout direction.
 */
function useLocale() {
  const defaultLocale = createDefaultLocale();
  const context = useContext(I18nContext);
  return context || defaultLocale;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useCollator.ts
 */
const cache$1 = new Map();

/**
 * Provides localized string collation for the current locale. Automatically updates when the locale changes,
 * and handles caching of the collator for performance.
 * @param options - Collator options.
 */
function createCollator(options) {
  const {
    locale
  } = useLocale();
  const cacheKey = createMemo(() => {
    return locale() + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : "");
  });
  return createMemo(() => {
    const key = cacheKey();
    let collator;
    if (cache$1.has(key)) {
      collator = cache$1.get(key);
    }
    if (!collator) {
      collator = new Intl.Collator(locale(), options);
      cache$1.set(key, collator);
    }
    return collator;
  });
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/i18n/src/useDateFormatter.ts
 */
/**
 * Provides localized date formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the date formatter for performance.
 * @param options - Formatting options.
 */
function createDateFormatter(options) {
  const {
    locale
  } = useLocale();
  return createMemo(() => new DateFormatter(locale(), options()));
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/22cb32d329e66c60f55d4fc4025d1d44bb015d71/packages/@react-aria/i18n/src/useFilter.ts
 */
/**
 * Provides localized string search functionality that is useful for filtering or matching items
 * in a list. Options can be provided to adjust the sensitivity to case, diacritics, and other parameters.
 */
function createFilter(options) {
  const collator = createCollator({
    usage: "search",
    ...options
  });

  // TODO: these methods don't currently support the ignorePunctuation option.

  const startsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }

    // Normalize both strings so we can slice safely
    // TODO: take into account the ignorePunctuation option as well...
    str = str.normalize("NFC");
    substr = substr.normalize("NFC");
    return collator().compare(str.slice(0, substr.length), substr) === 0;
  };
  const endsWith = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    str = str.normalize("NFC");
    substr = substr.normalize("NFC");
    return collator().compare(str.slice(-substr.length), substr) === 0;
  };
  const contains = (str, substr) => {
    if (substr.length === 0) {
      return true;
    }
    str = str.normalize("NFC");
    substr = substr.normalize("NFC");
    let scan = 0;
    const sliceLen = substr.length;
    for (; scan + sliceLen <= str.length; scan++) {
      const slice = str.slice(scan, scan + sliceLen);
      if (collator().compare(substr, slice) === 0) {
        return true;
      }
    }
    return false;
  };
  return {
    startsWith,
    endsWith,
    contains
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useLocalizedStringFormatter.ts
 */
const cache = new WeakMap();
function getCachedDictionary(strings) {
  let dictionary = cache.get(strings);
  if (!dictionary) {
    dictionary = new LocalizedStringDictionary(strings);
    cache.set(strings, dictionary);
  }
  return dictionary;
}

/**
 * Provides localized string formatting for the current locale. Supports interpolating variables,
 * selecting the correct pluralization, and formatting numbers. Automatically updates when the locale changes.
 * @param strings - A mapping of languages to localized strings by key.
 */
function createLocalizedStringFormatter(strings) {
  const {
    locale
  } = useLocale();
  return createMemo(() => {
    return new LocalizedStringFormatter(locale(), getCachedDictionary(strings()));
  });
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/i18n/src/useNumberFormatter.ts
 */

/**
 * Provides localized number formatting for the current locale. Automatically updates when the locale changes,
 * and handles caching of the number formatter for performance.
 * @param options - Formatting options.
 */
function createNumberFormatter(options) {
  const {
    locale
  } = useLocale();
  return createMemo(() => new NumberFormatter(locale(), options()));
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/Selection.ts
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/types.ts
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-types/shared/src/selection.d.ts
 */

/**
 * A Selection is a special Set containing Keys, which also has an anchor
 * and current selected key for use when range selecting.
 */
class Selection extends Set {
  constructor(keys, anchorKey, currentKey) {
    super(keys);
    _defineProperty(this, "anchorKey", void 0);
    _defineProperty(this, "currentKey", void 0);
    if (keys instanceof Selection) {
      this.anchorKey = anchorKey || keys.anchorKey;
      this.currentKey = currentKey || keys.currentKey;
    } else {
      this.anchorKey = anchorKey;
      this.currentKey = currentKey;
    }
  }
}

/**
 * Creates a simple reactive `Selection` state with a getter, setter and a fallback value of an empty selection,
 * that can be controlled with `value` and `onChange` props.
 */
function createControllableSelectionSignal(props) {
  const [_value, setValue] = createControllableSignal(props);
  const value = () => _value() ?? new Selection();
  return [value, setValue];
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/selection/src/useMultipleSelectionState.ts
 */
/**
 * Manages state for multiple selection and focus in a collection.
 */
function createMultipleSelectionState(props) {
  props = mergeDefaultProps({
    selectionMode: "none",
    selectionBehavior: "toggle"
  }, props);
  const [isFocused, setFocused] = createSignal(false);
  const [focusedKey, setFocusedKey] = createSignal();
  const selectedKeysProp = createMemo(() => {
    const selection = access(props.selectedKeys);
    if (!selection) {
      return;
    }
    return convertSelection(selection);
  });
  const defaultSelectedKeys = createMemo(() => {
    const defaultSelection = access(props.defaultSelectedKeys);
    if (!defaultSelection) {
      return new Selection();
    }
    return convertSelection(defaultSelection);
  });
  const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({
    value: selectedKeysProp,
    defaultValue: defaultSelectedKeys,
    onChange: value => props.onSelectionChange?.(value)
  });
  const [selectionBehavior, setSelectionBehavior] = createSignal(access(props.selectionBehavior));
  const selectionMode = () => access(props.selectionMode);
  const disallowEmptySelection = () => access(props.disallowEmptySelection) ?? false;
  const setSelectedKeys = keys => {
    if (access(props.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) {
      _setSelectedKeys(keys);
    }
  };

  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press
  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.
  createEffect(() => {
    const selection = selectedKeys();
    if (access(props.selectionBehavior) === "replace" && selectionBehavior() === "toggle" && typeof selection === "object" && selection.size === 0) {
      setSelectionBehavior("replace");
    }
  });

  // If the selectionBehavior prop changes, update the state as well.
  createEffect(() => {
    setSelectionBehavior(access(props.selectionBehavior) ?? "toggle");
  });
  return {
    selectionMode,
    disallowEmptySelection,
    selectionBehavior,
    setSelectionBehavior,
    isFocused,
    setFocused,
    focusedKey,
    setFocusedKey,
    selectedKeys,
    setSelectedKeys
  };
}
function convertSelection(selection) {
  return new Selection(selection);
}
function isSameSelection(setA, setB) {
  if (setA.size !== setB.size) {
    return false;
  }
  for (const item of setA) {
    if (!setB.has(item)) {
      return false;
    }
  }
  return true;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useTypeSelect.ts
 */
/**
 * Handles typeahead interactions with collections.
 */
function createTypeSelect(props) {
  const [search, setSearch] = createSignal("");
  const [timeoutId, setTimeoutId] = createSignal(-1);
  const onKeyDown = e => {
    if (access(props.isDisabled)) {
      return;
    }
    const delegate = access(props.keyboardDelegate);
    const manager = access(props.selectionManager);
    if (!delegate.getKeyForSearch) {
      return;
    }
    const character = getStringForKey(e.key);
    if (!character || e.ctrlKey || e.metaKey) {
      return;
    }

    // Do not propagate the Space bar event if it's meant to be part of the search.
    // When we time out, the search term becomes empty, hence the check on length.
    // Trimming is to account for the case of pressing the Space bar more than once,
    // which should cycle through the selection/deselection of the focused item.
    if (character === " " && search().trim().length > 0) {
      e.preventDefault();
      e.stopPropagation();
    }
    let newSearch = setSearch(prev => prev += character);

    // Use the delegate to find a key to focus.
    // Prioritize items after the currently focused item, falling back to searching the whole list.
    let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);

    // If not key found, and the search is multiple iterations of the same letter (e.g "aaa"),
    // then cycle through first-letter matches
    if (key == null && isAllSameLetter(newSearch)) {
      newSearch = newSearch[0];
      key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);
    }
    if (key != null) {
      manager.setFocusedKey(key);
      props.onTypeSelect?.(key);
    }
    clearTimeout(timeoutId());
    setTimeoutId(window.setTimeout(() => setSearch(""), 500));
  };
  return {
    typeSelectHandlers: {
      onKeyDown
    }
  };
}
function getStringForKey(key) {
  // If the key is of length 1, it is an ASCII value.
  // Otherwise, if there are no ASCII characters in the key name,
  // it is a Unicode character.
  // See https://www.w3.org/TR/uievents-key/
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }
  return "";
}
function isAllSameLetter(search) {
  return search.split("").every(letter => letter === search[0]);
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/utils.ts
 */
function isNonContiguousSelectionModifier(e) {
  // Ctrl + Arrow Up/Arrow Down has a system-wide meaning on macOS, so use Alt instead.
  // On Windows and Ubuntu, Alt + Space has a system-wide meaning.
  return isAppleDevice() ? e.altKey : e.ctrlKey;
}
function isCtrlKeyPressed(e) {
  if (isMac()) {
    return e.metaKey;
  }
  return e.ctrlKey;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableCollection.ts
 */
/**
 * Handles interactions with selectable collections.
 * @param props Props for the collection.
 * @param ref The ref attached to the element representing the collection.
 * @param scrollRef The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections. If not provided, defaults to the collection ref.
 */
function createSelectableCollection(props, ref, scrollRef) {
  const defaultProps = {
    selectOnFocus: () => access(props.selectionManager).selectionBehavior() === "replace"
  };
  props = mergeProps(defaultProps, props);
  const finalScrollRef = () => scrollRef?.() ?? ref();
  const {
    direction
  } = useLocale();

  // Store the scroll position, so we can restore it later.
  let scrollPos = {
    top: 0,
    left: 0
  };
  createEventListener(() => !access(props.isVirtualized) ? finalScrollRef() : undefined, "scroll", () => {
    const scrollEl = finalScrollRef();
    if (!scrollEl) {
      return;
    }
    scrollPos = {
      top: scrollEl.scrollTop,
      left: scrollEl.scrollLeft
    };
  });
  const {
    typeSelectHandlers
  } = createTypeSelect({
    isDisabled: () => access(props.disallowTypeAhead),
    keyboardDelegate: () => access(props.keyboardDelegate),
    selectionManager: () => access(props.selectionManager)
  });
  const onKeyDown = e => {
    callHandler(e, typeSelectHandlers.onKeyDown);

    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes
    if (e.altKey && e.key === "Tab") {
      e.preventDefault();
    }
    const refEl = ref();

    // Keyboard events bubble through portals. Don't handle keyboard events
    // for elements outside the collection (e.g. menus).
    if (!refEl?.contains(e.target)) {
      return;
    }
    const manager = access(props.selectionManager);
    const selectOnFocus = access(props.selectOnFocus);
    const navigateToKey = key => {
      if (key != null) {
        manager.setFocusedKey(key);
        if (e.shiftKey && manager.selectionMode() === "multiple") {
          manager.extendSelection(key);
        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {
          manager.replaceSelection(key);
        }
      }
    };
    const delegate = access(props.keyboardDelegate);
    const shouldFocusWrap = access(props.shouldFocusWrap);
    const focusedKey = manager.focusedKey();
    switch (e.key) {
      case "ArrowDown":
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyBelow(focusedKey);
            } else {
              nextKey = delegate.getFirstKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowUp":
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyAbove(focusedKey);
            } else {
              nextKey = delegate.getLastKey?.();
            }
            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey?.(focusedKey);
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowLeft":
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyLeftOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "ArrowRight":
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            const isRTL = direction() === "rtl";
            let nextKey;
            if (focusedKey != null) {
              nextKey = delegate.getKeyRightOf(focusedKey);
            } else {
              nextKey = isRTL ? delegate.getLastKey?.() : delegate.getFirstKey?.();
            }
            navigateToKey(nextKey);
          }
          break;
        }
      case "Home":
        if (delegate.getFirstKey) {
          e.preventDefault();
          const firstKey = delegate.getFirstKey(focusedKey, isCtrlKeyPressed(e));
          if (firstKey != null) {
            manager.setFocusedKey(firstKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(firstKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(firstKey);
            }
          }
        }
        break;
      case "End":
        if (delegate.getLastKey) {
          e.preventDefault();
          const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));
          if (lastKey != null) {
            manager.setFocusedKey(lastKey);
            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === "multiple") {
              manager.extendSelection(lastKey);
            } else if (selectOnFocus) {
              manager.replaceSelection(lastKey);
            }
          }
        }
        break;
      case "PageDown":
        if (delegate.getKeyPageBelow && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageBelow(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "PageUp":
        if (delegate.getKeyPageAbove && focusedKey != null) {
          e.preventDefault();
          const nextKey = delegate.getKeyPageAbove(focusedKey);
          navigateToKey(nextKey);
        }
        break;
      case "a":
        if (isCtrlKeyPressed(e) && manager.selectionMode() === "multiple" && access(props.disallowSelectAll) !== true) {
          e.preventDefault();
          manager.selectAll();
        }
        break;
      case "Escape":
        e.preventDefault();
        if (!access(props.disallowEmptySelection)) {
          manager.clearSelection();
        }
        break;
      case "Tab":
        {
          if (!access(props.allowsTabNavigation)) {
            // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
            // However, collections should be treated as a single tab stop, with arrow key navigation internally.
            // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
            // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
            // in the collection, so that the browser default behavior will apply starting from that element
            // rather than the currently focused one.
            if (e.shiftKey) {
              refEl.focus();
            } else {
              const walker = getFocusableTreeWalker(refEl, {
                tabbable: true
              });
              let next;
              let last;
              do {
                last = walker.lastChild();
                if (last) {
                  next = last;
                }
              } while (last);
              if (next && !next.contains(document.activeElement)) {
                focusWithoutScrolling(next);
              }
            }
            break;
          }
        }
    }
  };
  const onFocusIn = e => {
    const manager = access(props.selectionManager);
    const delegate = access(props.keyboardDelegate);
    const selectOnFocus = access(props.selectOnFocus);
    if (manager.isFocused()) {
      // If a focus event bubbled through a portal, reset focus state.
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }
      return;
    }

    // Focus events can bubble through portals. Ignore these events.
    if (!e.currentTarget.contains(e.target)) {
      return;
    }
    manager.setFocused(true);
    if (manager.focusedKey() == null) {
      const navigateToFirstKey = key => {
        if (key == null) {
          return;
        }
        manager.setFocusedKey(key);
        if (selectOnFocus) {
          manager.replaceSelection(key);
        }
      };

      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
      // Attempt to detect whether the user is tabbing forward or backward into the collection
      // and either focus the first or last item accordingly.
      const relatedTarget = e.relatedTarget;
      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        navigateToFirstKey(manager.lastSelectedKey() ?? delegate.getLastKey?.());
      } else {
        navigateToFirstKey(manager.firstSelectedKey() ?? delegate.getFirstKey?.());
      }
    } else if (!access(props.isVirtualized)) {
      const scrollEl = finalScrollRef();
      if (scrollEl) {
        // Restore the scroll position to what it was before.
        scrollEl.scrollTop = scrollPos.top;
        scrollEl.scrollLeft = scrollPos.left;

        // Refocus and scroll the focused item into view if it exists within the scrollable region.
        const element = scrollEl.querySelector(`[data-key="${manager.focusedKey()}"]`);
        if (element) {
          // This prevents a flash of focus on the first/last element in the collection
          focusWithoutScrolling(element);
          scrollIntoView$1(scrollEl, element);
        }
      }
    }
  };
  const onFocusOut = e => {
    const manager = access(props.selectionManager);

    // Don't set blurred and then focused again if moving focus within the collection.
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };
  const onMouseDown = e => {
    // Ignore events that bubbled through portals.
    if (e.currentTarget.contains(e.target)) {
      // Prevent focus going to the collection when clicking on the scrollbar.
      e.preventDefault();
    }
  };
  const tryAutoFocus = () => {
    const autoFocus = access(props.autoFocus);
    if (!autoFocus) {
      return;
    }
    const manager = access(props.selectionManager);
    const delegate = access(props.keyboardDelegate);
    let focusedKey;

    // Check focus strategy to determine which item to focus
    if (autoFocus === "first") {
      focusedKey = delegate.getFirstKey?.();
    }
    if (autoFocus === "last") {
      focusedKey = delegate.getLastKey?.();
    }

    // If there are any selected keys, make the first one the new focus target
    const selectedKeys = manager.selectedKeys();
    if (selectedKeys.size) {
      focusedKey = selectedKeys.values().next().value;
    }
    manager.setFocused(true);
    manager.setFocusedKey(focusedKey);
    const refEl = ref();

    // If no default focus key is selected, focus the collection itself.
    if (refEl && focusedKey == null && !access(props.shouldUseVirtualFocus)) {
      focusSafely(refEl);
    }
  };
  onMount(() => {
    if (props.deferAutoFocus) {
      queueMicrotask(tryAutoFocus); // TODO: does this work EVERY time ?
    } else {
      tryAutoFocus();
    }
  });

  // If not virtualized, scroll the focused element into view when the focusedKey changes.
  // When virtualized, the Virtualizer should handle this.
  createEffect(on([finalScrollRef, () => access(props.isVirtualized), () => access(props.selectionManager).focusedKey()], newValue => {
    const [scrollEl, isVirtualized, focusedKey] = newValue;
    if (!isVirtualized && focusedKey && scrollEl) {
      const element = scrollEl.querySelector(`[data-key="${focusedKey}"]`);
      if (element) {
        scrollIntoView$1(scrollEl, element);
      }
    }
  }));

  // If nothing is focused within the collection, make the collection itself tabbable.
  // This will be marshalled to either the first or last item depending on where focus came from.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
  // to move real DOM focus to the element anyway.
  const tabIndex = createMemo(() => {
    if (access(props.shouldUseVirtualFocus)) {
      return undefined;
    }
    return access(props.selectionManager).focusedKey() == null ? 0 : -1;
  });
  return {
    tabIndex,
    handlers: {
      onKeyDown,
      onMouseDown,
      onFocusIn,
      onFocusOut
    }
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableItem.ts
 */
/**
 * Handles interactions with an item in a selectable collection.
 * @param props Props for the item.
 * @param ref Ref to the item.
 */
function createSelectableItem(props, ref) {
  const manager = () => access(props.selectionManager);
  const key = () => access(props.key);
  const shouldUseVirtualFocus = () => access(props.shouldUseVirtualFocus);
  const onSelect = e => {
    if (e.pointerType === "keyboard" && isNonContiguousSelectionModifier(e)) {
      manager().toggleSelection(key());
    } else {
      if (manager().selectionMode() === "none") {
        return;
      }
      if (manager().selectionMode() === "single") {
        if (manager().isSelected(key()) && !manager().disallowEmptySelection()) {
          manager().toggleSelection(key());
        } else {
          manager().replaceSelection(key());
        }
      } else if (e && e.shiftKey) {
        manager().extendSelection(key());
      } else if (manager().selectionBehavior() === "toggle" || e && (isCtrlKeyPressed(e) || e.pointerType === "touch" || e.pointerType === "virtual")) {
        // if touch or virtual then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
        manager().toggleSelection(key());
      } else {
        manager().replaceSelection(key());
      }
    }
  };
  const isSelected = () => manager().isSelected(key());

  // With checkbox selection, onAction (i.e. navigation) becomes primary, and occurs on a single click of the row.
  // Clicking the checkbox enters selection mode, after which clicking anywhere on any row toggles selection for that row.
  // With highlight selection, onAction is secondary, and occurs on double click. Single click selects the row.
  // With touch, onAction occurs on single tap, and long press enters selection mode.
  const isDisabled = () => access(props.isDisabled) || manager().isDisabled(key());
  const allowsSelection = () => !isDisabled() && manager().canSelectItem(key());
  let modality = null;
  let longPressEnabledOnPressStart = false;

  // By default, selection occurs on pointer down. This can be strange if selecting an
  // item causes the UI to disappear immediately (e.g. menus).
  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.
  // onPress requires a pointer down event on the same element as pointer up. For menus,
  // we want to be able to have the pointer down on the trigger that opens the menu and
  // the pointer up on the menu item rather than requiring a separate press.
  // For keyboard events, selection still occurs on key down.
  const onPressStart = e => {
    if (!allowsSelection()) {
      return;
    }
    modality = e.pointerType;
    longPressEnabledOnPressStart = allowsSelection();

    // Selection occurs on mouse down or key down (Enter or Space bar).
    if (e.pointerType === "mouse" && !access(props.shouldSelectOnPressUp) || e.pointerType === "keyboard" && (isActionKey() || isSelectionKey())) {
      onSelect(e);
    }
  };
  const onPressUp = e => {
    if (!allowsSelection()) {
      return;
    }

    // If allowsDifferentPressOrigin, make selection happen on pressUp.
    // Otherwise, have selection happen onPress
    if (access(props.shouldSelectOnPressUp) && access(props.allowsDifferentPressOrigin) && e.pointerType !== "keyboard") {
      onSelect(e);
    }
  };
  const onPress = e => {
    if (!allowsSelection()) {
      return;
    }
    if (access(props.shouldSelectOnPressUp)) {
      if (!access(props.allowsDifferentPressOrigin) && e.pointerType !== "keyboard") {
        onSelect(e);
      }
    } else {
      // Selection occurs on touch up.
      if (e.pointerType === "touch" || e.pointerType === "pen" || e.pointerType === "virtual") {
        onSelect(e);
      }
    }
  };

  // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior
  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to
  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.
  const onLongPress = e => {
    if (!allowsSelection()) {
      return;
    }
    if (e.pointerType === "touch") {
      onSelect(e);
      manager().setSelectionBehavior("toggle");
    }
  };

  // Prevent native drag and drop on long press if we also select on long press.
  // Once the user is in selection mode, they can long press again to drag.
  const onDragStart = e => {
    if (modality === "touch" && longPressEnabledOnPressStart) {
      e.preventDefault();
    }
  };
  const onMouseDown = e => {
    if (isDisabled()) {
      // Prevent focus going to the body when clicking on a disabled item.
      e.preventDefault();
    }
  };
  const onFocus = e => {
    const refEl = ref();
    if (shouldUseVirtualFocus() || isDisabled() || !refEl) {
      return;
    }
    if (e.target === refEl) {
      manager().setFocusedKey(key());
    }
  };

  // Set tabIndex to 0 if the element is focused,
  // or -1 otherwise so that only the last focused item is tabbable.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver
  // on iOS 14 doesn't try to move real DOM focus to the item anyway.
  const tabIndex = createMemo(() => {
    if (shouldUseVirtualFocus() || isDisabled()) {
      return undefined;
    }
    return key() === manager().focusedKey() ? 0 : -1;
  });

  // data-attribute used in selection manager and keyboard delegate
  const dataKey = createMemo(() => {
    return access(props.isVirtualized) ? undefined : key();
  });

  // Focus the associated DOM node when this item becomes the focusedKey.
  createEffect(on([ref, key, shouldUseVirtualFocus, () => manager().focusedKey(), () => manager().isFocused()], ([refEl, key, shouldUseVirtualFocus, focusedKey, isFocused]) => {
    if (refEl && key === focusedKey && isFocused && !shouldUseVirtualFocus && document.activeElement !== refEl) {
      if (props.focus) {
        props.focus();
      } else {
        focusSafely(refEl);
      }
    }
  }));
  return {
    isSelected,
    isDisabled,
    allowsSelection,
    preventFocusOnPress: shouldUseVirtualFocus,
    tabIndex,
    dataKey,
    onPressStart,
    onPressUp,
    onPress,
    onLongPress,
    onMouseDown,
    onFocus,
    onDragStart
  };
}

/**
 * An interface for reading and updating multiple selection state.
 */
class SelectionManager {
  constructor(collection, state) {
    _defineProperty(this, "collection", void 0);
    _defineProperty(this, "state", void 0);
    this.collection = collection;
    this.state = state;
  }

  /** The type of selection that is allowed in the collection. */
  selectionMode() {
    return this.state.selectionMode();
  }

  /** Whether the collection allows empty selection. */
  disallowEmptySelection() {
    return this.state.disallowEmptySelection();
  }

  /** The selection behavior for the collection. */
  selectionBehavior() {
    return this.state.selectionBehavior();
  }

  /** Sets the selection behavior for the collection. */
  setSelectionBehavior(selectionBehavior) {
    this.state.setSelectionBehavior(selectionBehavior);
  }

  /** Whether the collection is currently focused. */
  isFocused() {
    return this.state.isFocused();
  }

  /** Sets whether the collection is focused. */
  setFocused(isFocused) {
    this.state.setFocused(isFocused);
  }

  /** The current focused key in the collection. */
  focusedKey() {
    return this.state.focusedKey();
  }

  /** Sets the focused key. */
  setFocusedKey(key) {
    if (key == null || this.collection().getItem(key)) {
      this.state.setFocusedKey(key);
    }
  }

  /** The currently selected keys in the collection. */
  selectedKeys() {
    return this.state.selectedKeys();
  }

  /** Returns whether a key is selected. */
  isSelected(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return false;
    }
    return this.state.selectedKeys().has(retrievedKey);
  }

  /** Whether the selection is empty. */
  isEmpty() {
    return this.state.selectedKeys().size === 0;
  }

  /** Whether all items in the collection are selected. */
  isSelectAll() {
    if (this.isEmpty()) {
      return false;
    }
    const selectedKeys = this.state.selectedKeys();
    return this.getAllSelectableKeys().every(k => selectedKeys.has(k));
  }
  firstSelectedKey() {
    let first;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;
      if (!first || isItemBeforeFirst) {
        first = item;
      }
    }
    return first?.key;
  }
  lastSelectedKey() {
    let last;
    for (const key of this.state.selectedKeys()) {
      const item = this.collection().getItem(key);
      const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;
      if (!last || isItemAfterLast) {
        last = item;
      }
    }
    return last?.key;
  }

  /** Extends the selection to the given key. */
  extendSelection(toKey) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      this.replaceSelection(toKey);
      return;
    }
    const retrievedToKey = this.getKey(toKey);
    if (retrievedToKey == null) {
      return;
    }
    const selectedKeys = this.state.selectedKeys();
    const anchorKey = selectedKeys.anchorKey || retrievedToKey;
    const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);
    for (const key of this.getKeyRange(anchorKey, selectedKeys.currentKey || retrievedToKey)) {
      selection.delete(key);
    }
    for (const key of this.getKeyRange(retrievedToKey, anchorKey)) {
      if (this.canSelectItem(key)) {
        selection.add(key);
      }
    }
    this.state.setSelectedKeys(selection);
  }
  getKeyRange(from, to) {
    const fromItem = this.collection().getItem(from);
    const toItem = this.collection().getItem(to);
    if (fromItem && toItem) {
      if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) {
        return this.getKeyRangeInternal(from, to);
      }
      return this.getKeyRangeInternal(to, from);
    }
    return [];
  }
  getKeyRangeInternal(from, to) {
    const keys = [];
    let key = from;
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item) {
        keys.push(key);
      }
      if (key === to) {
        return keys;
      }
      key = this.collection().getKeyAfter(key);
    }
    return [];
  }
  getKey(key) {
    const item = this.collection().getItem(key);
    if (!item) {
      return key;
    }
    return item.key;
  }

  /** Toggles whether the given key is selected. */
  toggleSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single" && !this.isSelected(key)) {
      this.replaceSelection(key);
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const keys = new Selection(this.state.selectedKeys());
    if (keys.has(retrievedKey)) {
      keys.delete(retrievedKey);
    } else if (this.canSelectItem(retrievedKey)) {
      keys.add(retrievedKey);
      keys.anchorKey = retrievedKey;
      keys.currentKey = retrievedKey;
    }
    if (this.disallowEmptySelection() && keys.size === 0) {
      return;
    }
    this.state.setSelectedKeys(keys);
  }

  /** Replaces the selection with only the given key. */
  replaceSelection(key) {
    if (this.selectionMode() === "none") {
      return;
    }
    const retrievedKey = this.getKey(key);
    if (retrievedKey == null) {
      return;
    }
    const selection = this.canSelectItem(retrievedKey) ? new Selection([retrievedKey], retrievedKey, retrievedKey) : new Selection();
    this.state.setSelectedKeys(selection);
  }

  /** Replaces the selection with the given keys. */
  setSelectedKeys(keys) {
    if (this.selectionMode() === "none") {
      return;
    }
    const selection = new Selection();
    for (const key of keys) {
      const retrievedKey = this.getKey(key);
      if (retrievedKey != null) {
        selection.add(retrievedKey);
        if (this.selectionMode() === "single") {
          break;
        }
      }
    }
    this.state.setSelectedKeys(selection);
  }

  /** Selects all items in the collection. */
  selectAll() {
    if (this.selectionMode() === "multiple") {
      this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));
    }
  }

  /**
   * Removes all keys from the selection.
   */
  clearSelection() {
    const selectedKeys = this.state.selectedKeys();
    if (!this.disallowEmptySelection() && selectedKeys.size > 0) {
      this.state.setSelectedKeys(new Selection());
    }
  }

  /**
   * Toggles between select all and an empty selection.
   */
  toggleSelectAll() {
    if (this.isSelectAll()) {
      this.clearSelection();
    } else {
      this.selectAll();
    }
  }
  select(key, e) {
    if (this.selectionMode() === "none") {
      return;
    }
    if (this.selectionMode() === "single") {
      if (this.isSelected(key) && !this.disallowEmptySelection()) {
        this.toggleSelection(key);
      } else {
        this.replaceSelection(key);
      }
    } else if (this.selectionBehavior() === "toggle" || e && (e.pointerType === "touch" || e.pointerType === "virtual")) {
      // if touch or virtual then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
      this.toggleSelection(key);
    } else {
      this.replaceSelection(key);
    }
  }

  /** Returns whether the current selection is equal to the given selection. */
  isSelectionEqual(selection) {
    if (selection === this.state.selectedKeys()) {
      return true;
    }

    // Check if the set of keys match.
    const selectedKeys = this.selectedKeys();
    if (selection.size !== selectedKeys.size) {
      return false;
    }
    for (const key of selection) {
      if (!selectedKeys.has(key)) {
        return false;
      }
    }
    for (const key of selectedKeys) {
      if (!selection.has(key)) {
        return false;
      }
    }
    return true;
  }
  canSelectItem(key) {
    if (this.state.selectionMode() === "none") {
      return false;
    }
    const item = this.collection().getItem(key);
    return item != null && !item.isDisabled;
  }
  isDisabled(key) {
    const item = this.collection().getItem(key);
    return !item || item.isDisabled;
  }
  getAllSelectableKeys() {
    const keys = [];
    const addKeys = key => {
      while (key != null) {
        if (this.canSelectItem(key)) {
          const item = this.collection().getItem(key);
          if (!item) {
            continue;
          }
          keys.push(key);
        }
        key = this.collection().getKeyAfter(key);
      }
    };
    addKeys(this.collection().getFirstKey());
    return keys;
  }
}

let _Symbol$iterator;
_Symbol$iterator = Symbol.iterator;
/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/list/src/ListCollection.ts
 */

class ListCollection {
  constructor(nodes) {
    _defineProperty(this, "keyMap", new Map());
    _defineProperty(this, "iterable", void 0);
    _defineProperty(this, "firstKey", void 0);
    _defineProperty(this, "lastKey", void 0);
    this.iterable = nodes;
    for (const node of nodes) {
      this.keyMap.set(node.key, node);
    }
    if (this.keyMap.size === 0) {
      return;
    }
    let last;
    let index = 0;
    for (const [key, node] of this.keyMap) {
      if (last) {
        last.nextKey = key;
        node.prevKey = last.key;
      } else {
        this.firstKey = key;
        node.prevKey = undefined;
      }
      node.index = index++;
      last = node;

      // Set nextKey as undefined since this might be the last node
      // If it isn't the last node, last.nextKey will properly set at start of new loop
      last.nextKey = undefined;
    }
    this.lastKey = last.key;
  }
  *[_Symbol$iterator]() {
    yield* this.iterable;
  }
  getSize() {
    return this.keyMap.size;
  }
  getKeys() {
    return this.keyMap.keys();
  }
  getKeyBefore(key) {
    return this.keyMap.get(key)?.prevKey;
  }
  getKeyAfter(key) {
    return this.keyMap.get(key)?.nextKey;
  }
  getFirstKey() {
    return this.firstKey;
  }
  getLastKey() {
    return this.lastKey;
  }
  getItem(key) {
    return this.keyMap.get(key);
  }
  at(idx) {
    const keys = [...this.getKeys()];
    return this.getItem(keys[idx]);
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/bfce84fee12a027d9cbc38b43e1747e3e4b4b169/packages/@react-stately/list/src/useListState.ts
 */
/**
 * Provides state management for list-like components.
 * Handles building a collection of items from props, and manages multiple selection state.
 */
function createListState(props) {
  const selectionState = createMultipleSelectionState(props);
  const factory = nodes => {
    return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);
  };
  const collection = createCollection({
    dataSource: () => access(props.dataSource),
    factory
  }, [() => props.filter]);
  const selectionManager = new SelectionManager(collection, selectionState);

  // Reset focused key if that item is deleted from the collection.
  createComputed(() => {
    const focusedKey = selectionState.focusedKey();
    if (focusedKey != null && !collection().getItem(focusedKey)) {
      selectionState.setFocusedKey(undefined);
    }
  });
  return {
    collection,
    selectionManager: () => selectionManager
  };
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/ListKeyboardDelegate.ts
 */

class ListKeyboardDelegate {
  constructor(collection, ref, collator) {
    _defineProperty(this, "collection", void 0);
    _defineProperty(this, "ref", void 0);
    _defineProperty(this, "collator", void 0);
    this.collection = collection;
    this.ref = ref;
    this.collator = collator;
  }
  getKeyBelow(key) {
    let keyAfter = this.collection().getKeyAfter(key);
    while (keyAfter != null) {
      const item = this.collection().getItem(keyAfter);
      if (item && !item.isDisabled) {
        return keyAfter;
      }
      keyAfter = this.collection().getKeyAfter(keyAfter);
    }
  }
  getKeyAbove(key) {
    let keyBefore = this.collection().getKeyBefore(key);
    while (keyBefore != null) {
      const item = this.collection().getItem(keyBefore);
      if (item && !item.isDisabled) {
        return keyBefore;
      }
      keyBefore = this.collection().getKeyBefore(keyBefore);
    }
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && !item.isDisabled) {
        return key;
      }
      key = this.collection().getKeyAfter(key);
    }
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item && !item.isDisabled) {
        return key;
      }
      key = this.collection().getKeyBefore(key);
    }
  }
  getItem(key) {
    return this.ref?.()?.querySelector(`[data-key="${key}"]`) ?? null;
  }

  // TODO: not working correctly
  getKeyPageAbove(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);
    let keyAbove = key;
    while (keyAbove && item && item.offsetTop > pageY) {
      keyAbove = this.getKeyAbove(keyAbove);
      item = keyAbove != null ? this.getItem(keyAbove) : null;
    }
    return keyAbove;
  }

  // TODO: not working correctly
  getKeyPageBelow(key) {
    const menu = this.ref?.();
    let item = this.getItem(key);
    if (!menu || !item) {
      return;
    }
    const pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);
    let keyBelow = key;
    while (keyBelow && item && item.offsetTop < pageY) {
      keyBelow = this.getKeyBelow(keyBelow);
      item = keyBelow != null ? this.getItem(keyBelow) : null;
    }
    return keyBelow;
  }
  getKeyForSearch(search, fromKey) {
    const collator = this.collator?.();
    if (!collator) {
      return;
    }

    // Prevent from getting the same key twice
    let key = fromKey != null ? this.getKeyBelow(fromKey) : this.getFirstKey();
    while (key != null) {
      const item = this.collection().getItem(key);
      if (item) {
        const substring = item.textValue.slice(0, search.length);
        if (item.textValue && collator.compare(substring, search) === 0) {
          return key;
        }
      }
      key = this.getKeyBelow(key);
    }
  }
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-aria/selection/src/useSelectableList.ts
 */
/**
 * Handles interactions with a selectable list.
 * @param props Props for the list.
 * @param ref A ref to the list element.
 * @param scrollRef The ref attached to the scrollable body. Used to provide automatic scrolling on item focus for non-virtualized collections. If not provided, defaults to the collection ref.
 */
function createSelectableList(props, ref, scrollRef) {
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });

  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.
  const delegate = createMemo(() => {
    const keyboardDelegate = access(props.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(props.collection, ref, collator);
  });
  return createSelectableCollection({
    selectionManager: () => access(props.selectionManager),
    keyboardDelegate: delegate,
    autoFocus: () => access(props.autoFocus),
    deferAutoFocus: () => access(props.deferAutoFocus),
    shouldFocusWrap: () => access(props.shouldFocusWrap),
    disallowEmptySelection: () => access(props.disallowEmptySelection),
    selectOnFocus: () => access(props.selectOnFocus),
    disallowTypeAhead: () => access(props.disallowTypeAhead),
    shouldUseVirtualFocus: () => access(props.shouldUseVirtualFocus),
    allowsTabNavigation: () => access(props.allowsTabNavigation),
    isVirtualized: () => access(props.isVirtualized)
  }, ref, scrollRef);
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/8f2f2acb3d5850382ebe631f055f88c704aa7d17/packages/@react-stately/list/src/useSingleSelectListState.ts
 */
/**
 * Provides state management for list-like components with single selection.
 * Handles building a collection of items from props, and manages selection state.
 */
function createSingleSelectListState(props) {
  const [selectedKey, setSelectedKey] = createControllableSignal({
    value: () => access(props.selectedKey),
    defaultValue: () => access(props.defaultSelectedKey),
    onChange: value => props.onSelectionChange?.(value)
  });
  const selectedKeys = createMemo(() => {
    const selection = selectedKey();
    return selection != null ? [selection] : [];
  });
  const [, defaultCreateListStateProps] = splitProps(props, ["onSelectionChange"]);
  const createListStateProps = mergeProps(defaultCreateListStateProps, {
    selectionMode: "single",
    disallowEmptySelection: true,
    allowDuplicateSelectionEvents: true,
    selectedKeys,
    onSelectionChange: keys => {
      const key = keys.values().next().value;

      // Always fire onSelectionChange, even if the key is the same
      // as the current key (createControllableSignal does not).
      if (key === selectedKey()) {
        props.onSelectionChange?.(key);
      }
      setSelectedKey(key);
    }
  });
  const {
    collection,
    selectionManager
  } = createListState(createListStateProps);
  const selectedItem = createMemo(() => {
    const selection = selectedKey();
    return selection != null ? collection().getItem(selection) : undefined;
  });
  return {
    collection,
    selectionManager,
    selectedKey,
    setSelectedKey,
    selectedItem
  };
}

/* Inspired by https://github.com/AlmeroSteyn/react-aria-live */
const LIVEREGION_TIMEOUT_DELAY = 7000;
let liveAnnouncer = null;

/**
 * Announces the message using screen reader technology.
 */
function announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
  if (!liveAnnouncer) {
    liveAnnouncer = new LiveAnnouncer();
  }
  liveAnnouncer.announce(message, assertiveness, timeout);
}

/**
 * Stops all queued announcements.
 */
function clearAnnouncer(assertiveness) {
  if (liveAnnouncer) {
    liveAnnouncer.clear(assertiveness);
  }
}

/**
 * Removes the announcer from the DOM.
 */
function destroyAnnouncer() {
  if (liveAnnouncer) {
    liveAnnouncer.destroy();
    liveAnnouncer = null;
  }
}

// LiveAnnouncer is implemented using vanilla DOM, not SolidJS.
class LiveAnnouncer {
  constructor() {
    _defineProperty(this, "node", void 0);
    _defineProperty(this, "assertiveLog", void 0);
    _defineProperty(this, "politeLog", void 0);
    this.node = document.createElement("div");
    this.node.dataset.liveAnnouncer = "true";
    Object.assign(this.node.style, visuallyHiddenStyles);
    this.assertiveLog = this.createLog("assertive");
    this.node.appendChild(this.assertiveLog);
    this.politeLog = this.createLog("polite");
    this.node.appendChild(this.politeLog);
    document.body.prepend(this.node);
  }
  createLog(ariaLive) {
    const node = document.createElement("div");
    node.setAttribute("role", "log");
    node.setAttribute("aria-live", ariaLive);
    node.setAttribute("aria-relevant", "additions");
    return node;
  }
  destroy() {
    if (!this.node) {
      return;
    }
    document.body.removeChild(this.node);
    this.node = null;
  }
  announce(message, assertiveness = "assertive", timeout = LIVEREGION_TIMEOUT_DELAY) {
    if (!this.node) {
      return;
    }
    const node = document.createElement("div");
    node.textContent = message;
    if (assertiveness === "assertive") {
      this.assertiveLog.appendChild(node);
    } else {
      this.politeLog.appendChild(node);
    }
    if (message !== "") {
      setTimeout(() => {
        node.remove();
      }, timeout);
    }
  }
  clear(assertiveness) {
    if (!this.node) {
      return;
    }
    if (!assertiveness || assertiveness === "assertive") {
      this.assertiveLog.innerHTML = "";
    }
    if (!assertiveness || assertiveness === "polite") {
      this.politeLog.innerHTML = "";
    }
  }
}

const CollapsibleContext = createContext();
function useCollapsibleContext() {
  const context = useContext(CollapsibleContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCollapsibleContext` must be used within a `Collapsible.Root` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the collapsible is expanded.
 */
const CollapsibleContent = createPolymorphicComponent(props => {
  let ref;
  const context = useCollapsibleContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "id", "style", "children"]);
  const presence = createPresence(() => context.shouldMount());
  const [height, setHeight] = createSignal(0);
  const [width, setWidth] = createSignal(0);

  // when opening we want it to immediately open to retrieve dimensions
  // when closing we delay `isPresent` to retrieve dimensions before closing
  const isOpen = () => context.isOpen() || presence.isPresent();
  let isMountAnimationPrevented = isOpen();
  let originalStyles;
  onMount(() => {
    const raf = requestAnimationFrame(() => {
      isMountAnimationPrevented = false;
    });
    onCleanup(() => {
      cancelAnimationFrame(raf);
    });
  });
  createEffect(on(
  /**
   * depends on `context.isOpen` because it will change to `false`
   * when a close is triggered but `isPresent` will be `false` on
   * animation end (so when close finishes). This allows us to
   * retrieve the dimensions *before* closing.
   */
  [() => context.isOpen(), () => presence.isPresent()], () => {
    if (!ref) {
      return;
    }
    originalStyles = originalStyles || {
      transitionDuration: ref.style.transitionDuration,
      animationName: ref.style.animationName
    };

    // block any animations/transitions so the element renders at its full dimensions
    ref.style.transitionDuration = "0s";
    ref.style.animationName = "none";

    // get width and height from full dimensions
    const rect = ref.getBoundingClientRect();
    setHeight(rect.height);
    setWidth(rect.width);

    // kick off any animations/transitions that were originally set up if it isn't the initial mount
    if (!isMountAnimationPrevented) {
      ref.style.transitionDuration = originalStyles.transitionDuration;
      ref.style.animationName = originalStyles.animationName;
    }
  }));
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        presence.setRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get hidden() {
      return !isOpen();
    },
    get style() {
      return {
        "--kb-collapsible-content-height": height() ? `${height()}px` : undefined,
        "--kb-collapsible-content-width": width() ? `${width()}px` : undefined,
        ...local.style
      };
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    }
  }, others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return isOpen();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
});

/**
 * An interactive component which expands/collapses a content.
 */
const CollapsibleRoot = createPolymorphicComponent(props => {
  const defaultId = `collapsible-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["as", "isOpen", "defaultIsOpen", "onOpenChange", "forceMount"]);
  const [contentId, setContentId] = createSignal();
  const disclosureState = createDisclosureState({
    isOpen: () => local.isOpen,
    defaultIsOpen: () => local.defaultIsOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    isOpen: disclosureState.isOpen,
    shouldMount: () => local.forceMount || disclosureState.isOpen(),
    contentId,
    toggle: disclosureState.toggle,
    generateId: createGenerateId(() => others.id),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(CollapsibleContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        get ["data-expanded"]() {
          return disclosureState.isOpen() ? "" : undefined;
        }
      }, others));
    }
  });
});

/*!
 * Portions of this file are based on code from ariakit
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the ariakit team:
 * https://github.com/hope-ui/hope-ui/blob/54125b130195f37161dbeeea0c21dc3b198bc3ac/packages/core/src/button/is-button.ts
 */

const BUTTON_INPUT_TYPES = ["button", "color", "file", "image", "reset", "submit"];

/**
 * Checks whether `element` is a native HTML button element.
 * @example
 * isButton(document.querySelector("button")); // true
 * isButton(document.querySelector("input[type='button']")); // true
 * isButton(document.querySelector("div")); // false
 * isButton(document.querySelector("input[type='text']")); // false
 * isButton(document.querySelector("div[role='button']")); // false
 */
function isButton(element) {
  const tagName = element.tagName.toLowerCase();
  if (tagName === "button") {
    return true;
  }
  if (tagName === "input" && element.type) {
    return BUTTON_INPUT_TYPES.indexOf(element.type) !== -1;
  }
  return false;
}

const PressableSymbol = Symbol("$$Pressable");

/**
 * `Pressable` handles press and long press interactions across mouse, touch, keyboard, and screen readers.
 * Supports a customizable time threshold, normalizes behavior across browsers and platforms,
 * and handles many nuances of dealing with pointer and keyboard events.
 * It renders a `<button>` by default.
 */
const Pressable = createPolymorphicComponent(props => {
  let ref;
  props = mergeDefaultProps({
    as: "button"
  }, props);
  const [local, createPressProps, createLongPressProps, others] = splitProps(props, ["as", "ref", "type", "isDisabled", ...PRESS_HANDLERS_PROP_NAMES], CREATE_PRESS_PROP_NAMES, CREATE_LONG_PRESS_PROP_NAMES);
  const tagName = createTagName(() => ref, () => local.as || "button");
  const isNativeButton = createMemo(() => {
    const elementTagName = tagName();
    if (elementTagName == null) {
      return false;
    }
    return isButton({
      tagName: elementTagName,
      type: local.type
    });
  });
  const isNativeInput = createMemo(() => {
    return tagName() === "input";
  });
  const {
    isPressed,
    pressHandlers
  } = createPress(createPressProps);
  const {
    longPressHandlers
  } = createLongPress(createLongPressProps);
  const pressableHandler = (name, warningMessage = undefined) => {
    const handler = e => {
      if (local[name]) {
        callHandler(e, local[name]);

        // Prevent the default behavior when a component that use `Pressable` under the hood
        // is passed to the `as` prop of another component that use `Pressable` under the hood.
        // @ts-ignore
        if (local[name][PressableSymbol]) {
          return;
        }
        if (warningMessage) {
          console.warn(warningMessage);
        }
      }
      callHandler(e, pressHandlers[name]);
      callHandler(e, longPressHandlers[name]);
    };

    // @ts-ignore
    handler[PressableSymbol] = true;
    return handler;
  };
  const onClick = pressableHandler("onClick", "[kobalte]: use `onPress` instead of `onClick` for handling click interactions.");
  const onKeyDown = pressableHandler("onKeyDown");
  const onKeyUp = pressableHandler("onKeyUp");
  const onPointerDown = pressableHandler("onPointerDown");
  const onPointerUp = pressableHandler("onPointerUp");
  const onMouseDown = pressableHandler("onMouseDown");
  const onDragStart = pressableHandler("onDragStart");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get type() {
      return isNativeButton() || isNativeInput() ? local.type : undefined;
    },
    get disabled() {
      return isNativeButton() || isNativeInput() ? local.isDisabled : undefined;
    },
    get ["aria-disabled"]() {
      return !isNativeButton() && !isNativeInput() && local.isDisabled ? true : undefined;
    },
    get ["data-disabled"]() {
      return local.isDisabled ? "" : undefined;
    },
    get ["data-active"]() {
      return isPressed() ? "" : undefined;
    },
    onKeyDown: onKeyDown,
    onKeyUp: onKeyUp,
    onClick: onClick,
    onPointerDown: onPointerDown,
    onPointerUp: onPointerUp,
    onMouseDown: onMouseDown,
    onDragStart: onDragStart
  }, others));
});

/**
 * Button enables users to trigger an action or event, such as submitting a form,
 * opening a dialog, canceling an action, or performing a delete operation.
 * This component is based on the [WAI-ARIA Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/button/)
 */
const ButtonRoot = createPolymorphicComponent(props => {
  let ref;
  props = mergeDefaultProps({
    as: "button",
    type: "button"
  }, props);
  const [local, others] = splitProps(props, ["ref", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled: () => others.isDisabled
  });
  const {
    isFocused,
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  const tagName = createTagName(() => ref, () => others.as || "button");
  const isNativeButton = createMemo(() => {
    const elementTagName = tagName();
    if (elementTagName == null) {
      return false;
    }
    return isButton({
      tagName: elementTagName,
      type: others.type
    });
  });
  const isLink = createMemo(() => {
    return tagName() === "a" && others.href != null;
  });
  return createComponent(Pressable, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return !isNativeButton() && !isLink() ? "button" : undefined;
    },
    get tabIndex() {
      return !isNativeButton() && !isLink() && !others.isDisabled ? 0 : undefined;
    },
    get ["data-hover"]() {
      return isHovered() ? "" : undefined;
    },
    get ["data-focus"]() {
      return isFocused() ? "" : undefined;
    },
    get ["data-focus-visible"]() {
      return isFocusVisible() ? "" : undefined;
    },
    get onPointerEnter() {
      return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
    },
    get onPointerLeave() {
      return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
    }
  }, others));
});

var index$o = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: ButtonRoot
});

/**
 * The button that expands/collapses the collapsible content.
 */
const CollapsibleTrigger = createPolymorphicComponent(props => {
  const context = useCollapsibleContext();
  const [local, others] = splitProps(props, ["onPress"]);
  const onPress = e => {
    local.onPress?.(e);
    context.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    onPress: onPress
  }, others));
});

var index$n = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: CollapsibleContent,
  Root: CollapsibleRoot,
  Trigger: CollapsibleTrigger
});

const AccordionItemContext = createContext();
function useAccordionItemContext() {
  const context = useContext(AccordionItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionItemContext` must be used within a `Accordion.Item` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the `Accordion.Item` is expanded.
 */
const AccordionContent = createPolymorphicComponent(props => {
  const itemContext = useAccordionItemContext();
  const defaultId = itemContext.generateId("content");
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["style"]);
  createEffect(() => onCleanup(itemContext.registerContentId(others.id)));
  return createComponent(CollapsibleContent, mergeProps$1({
    role: "region",
    get ["aria-labelledby"]() {
      return itemContext.triggerId();
    },
    get style() {
      return {
        "--kb-accordion-content-height": "var(--kb-collapsible-content-height)",
        "--kb-accordion-content-width": "var(--kb-collapsible-content-width)",
        ...local.style
      };
    }
  }, others));
});

/**
 * Wraps an `Accordion.Trigger`. Use the `as` prop to update it to the appropriate heading level for your page.
 */
const AccordionHeader = createPolymorphicComponent(props => {
  const context = useAccordionItemContext();
  props = mergeDefaultProps({
    as: "h3"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get ["data-expanded"]() {
      return context.isExpanded() ? "" : undefined;
    }
  }, others));
});

const AccordionContext = createContext();
function useAccordionContext() {
  const context = useContext(AccordionContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useAccordionContext` must be used within a `Accordion.Root` component");
  }
  return context;
}

/**
 * An item of the accordion, contains all the parts of a collapsible section.
 */
const AccordionItem = createPolymorphicComponent(props => {
  const accordionContext = useAccordionContext();
  const defaultId = `${accordionContext.generateId("item")}-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["value", "isDisabled"]);
  const [triggerId, setTriggerId] = createSignal();
  const [contentId, setContentId] = createSignal();
  const selectionManager = () => accordionContext.listState().selectionManager();
  const isExpanded = () => {
    return selectionManager().isSelected(local.value);
  };
  const context = {
    value: () => local.value,
    isDisabled: () => local.isDisabled ?? false,
    isExpanded,
    triggerId,
    contentId,
    generateId: createGenerateId(() => others.id),
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(AccordionItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(CollapsibleRoot, mergeProps$1({
        get isOpen() {
          return isExpanded();
        }
      }, others));
    }
  });
});

const DomCollectionContext = createContext();
function useOptionalDomCollectionContext() {
  return useContext(DomCollectionContext);
}
function useDomCollectionContext() {
  const context = useOptionalDomCollectionContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useDomCollectionContext` must be used within a `DomCollectionProvider` component");
  }
  return context;
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-state.ts
 */
function isElementPreceding(a, b) {
  return Boolean(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);
}
function findDOMIndex(items, item) {
  const itemEl = item.ref();
  if (!itemEl) {
    return -1;
  }
  let length = items.length;
  if (!length) {
    return -1;
  }

  // Most of the time, the new item will be added at the end of the list, so we
  // do a findIndex in reverse order, instead of wasting time searching the
  // index from the beginning.
  while (length--) {
    const currentItemEl = items[length]?.ref();
    if (!currentItemEl) {
      continue;
    }
    if (isElementPreceding(currentItemEl, itemEl)) {
      return length + 1;
    }
  }
  return 0;
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.ref();
    const elementB = b.ref();
    if (elementA === elementB) {
      return 0;
    }
    if (!elementA || !elementB) {
      return 0;
    }

    // a before b
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }

    // a after b
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function setItemsBasedOnDOMPosition(items, setItems) {
  const sortedItems = sortBasedOnDOMPosition(items);
  if (items !== sortedItems) {
    setItems(sortedItems);
  }
}
function getCommonParent(items) {
  const firstItem = items[0];
  const lastItemEl = items[items.length - 1]?.ref();
  let parentEl = firstItem?.ref()?.parentElement;
  while (parentEl) {
    if (lastItemEl && parentEl.contains(lastItemEl)) {
      return parentEl;
    }
    parentEl = parentEl.parentElement;
  }
  return getDocument(parentEl).body;
}
function createTimeoutObserver(items, setItems) {
  createEffect(() => {
    const timeout = setTimeout(() => {
      setItemsBasedOnDOMPosition(items(), setItems);
    });
    onCleanup(() => clearTimeout(timeout));
  });
}
function createSortBasedOnDOMPosition(items, setItems) {
  // JSDOM doesn't support IntersectionObserver. See https://github.com/jsdom/jsdom/issues/2032
  if (typeof IntersectionObserver !== "function") {
    createTimeoutObserver(items, setItems);
    return;
  }
  let previousItems = [];
  createEffect(() => {
    const callback = () => {
      const hasPreviousItems = !!previousItems.length;
      previousItems = items();

      // We don't want to sort items if items have been just registered.
      if (!hasPreviousItems) {
        return;
      }
      setItemsBasedOnDOMPosition(items(), setItems);
    };
    const root = getCommonParent(items());
    const observer = new IntersectionObserver(callback, {
      root
    });
    items().forEach(item => {
      const itemEl = item.ref();
      if (itemEl) {
        observer.observe(itemEl);
      }
    });
    onCleanup(() => observer.disconnect());
  });
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection.tsx
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-state.ts
 * https://github.com/ariakit/ariakit/blob/da142672eddefa99365773ced72171facc06fdcb/packages/ariakit/src/collection/collection-item.ts
 */
function createDomCollection(props = {}) {
  const [items, setItems] = createControllableArraySignal({
    value: () => access(props.items),
    onChange: value => props.onItemsChange?.(value)
  });
  createSortBasedOnDOMPosition(items, setItems);
  const registerItem = item => {
    setItems(prevItems => {
      // Finds the item group based on the DOM hierarchy
      const index = findDOMIndex(prevItems, item);
      return addItemToArray(prevItems, item, index);
    });
    return () => {
      setItems(prevItems => {
        const nextItems = prevItems.filter(prevItem => prevItem.ref() !== item.ref());
        if (prevItems.length === nextItems.length) {
          // The item isn't registered, so do nothing
          return prevItems;
        }
        return nextItems;
      });
    };
  };
  const DomCollectionProvider = props => {
    return createComponent$1(DomCollectionContext.Provider, {
      value: {
        registerItem
      },
      get children() {
        return props.children;
      }
    });
  };
  return {
    DomCollectionProvider
  };
}

function createDomCollectionItem(props) {
  const context = useDomCollectionContext();
  props = mergeDefaultProps({
    shouldRegisterItem: true
  }, props);
  createEffect(() => {
    if (!props.shouldRegisterItem) {
      return;
    }
    const unregister = context.registerItem(props.getItem());
    onCleanup(unregister);
  });
}

/**
 * A vertically stacked set of interactive headings that each reveal an associated section of content.
 */
const AccordionRoot = createPolymorphicComponent(props => {
  let ref;
  const defaultId = `accordion-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId,
    isMultiple: false,
    isCollapsible: false,
    shouldFocusWrap: true
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "value", "defaultValue", "onValueChange", "isMultiple", "isCollapsible", "shouldFocusWrap", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const [items, setItems] = createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createListState({
    selectedKeys: () => local.value,
    defaultSelectedKeys: () => local.defaultValue,
    onSelectionChange: value => local.onValueChange?.(Array.from(value)),
    disallowEmptySelection: () => !local.isMultiple && !local.isCollapsible,
    selectionMode: () => local.isMultiple ? "multiple" : "single",
    dataSource: items
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState.selectionManager(),
    collection: () => listState.collection(),
    disallowEmptySelection: () => listState.selectionManager().disallowEmptySelection(),
    shouldFocusWrap: () => local.shouldFocusWrap,
    disallowTypeAhead: true,
    allowsTabNavigation: true
  }, () => ref);
  const context = {
    listState: () => listState,
    generateId: createGenerateId(() => others.id)
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(AccordionContext.Provider, {
        value: context,
        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            },
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get onKeyDown() {
              return composeEventHandlers([local.onKeyDown, selectableList.handlers.onKeyDown]);
            },
            get onMouseDown() {
              return composeEventHandlers([local.onMouseDown, selectableList.handlers.onMouseDown]);
            },
            get onFocusIn() {
              return composeEventHandlers([local.onFocusIn, selectableList.handlers.onFocusIn]);
            },
            get onFocusOut() {
              return composeEventHandlers([local.onFocusOut, selectableList.handlers.onFocusOut]);
            }
          }, others));
        }
      });
    }
  });
});

/**
 * Toggles the collapsed state of its associated item. It should be nested inside an `Accordion.Header`.
 */
const AccordionTrigger = createPolymorphicComponent(props => {
  let ref;
  const accordionContext = useAccordionContext();
  const itemContext = useAccordionItemContext();
  const defaultId = itemContext.generateId("trigger");
  props = mergeDefaultProps({
    as: "button",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["ref", "onPressStart", "onPressUp", "onPress", "onLongPress", "onFocus", "onMouseDown", "onDragStart"]);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      key: itemContext.value(),
      isDisabled: itemContext.isDisabled(),
      label: "",
      // not applicable
      textValue: "" // not applicable
    })
  });

  const selectableItem = createSelectableItem({
    key: () => itemContext.value(),
    selectionManager: () => accordionContext.listState().selectionManager(),
    isDisabled: () => itemContext.isDisabled(),
    shouldSelectOnPressUp: true
  }, () => ref);
  createEffect(() => onCleanup(itemContext.registerTriggerId(others.id)));
  return createComponent(CollapsibleTrigger, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get isDisabled() {
      return selectableItem.isDisabled();
    },
    get preventFocusOnPress() {
      return selectableItem.preventFocusOnPress();
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    get onPressStart() {
      return composeEventHandlers([local.onPressStart, selectableItem.onPressStart]);
    },
    get onPressUp() {
      return composeEventHandlers([local.onPressUp, selectableItem.onPressUp]);
    },
    get onPress() {
      return composeEventHandlers([local.onPress, selectableItem.onPress]);
    },
    get onLongPress() {
      return composeEventHandlers([local.onLongPress, selectableItem.onLongPress]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onDragStart() {
      return composeEventHandlers([local.onDragStart, selectableItem.onDragStart]);
    }
  }, others));
});

var index$m = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: AccordionContent,
  Header: AccordionHeader,
  Item: AccordionItem,
  Root: AccordionRoot,
  Trigger: AccordionTrigger
});

/**
 * Alert displays a brief, important message
 * in a way that attracts the user's attention without interrupting the user's task.
 */
const AlertRoot = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    role: "alert"
  }, others));
});

var index$l = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: AlertRoot
});

/**
 * Link allows a user to navigate to another page or resource within a web page or application.
 */
const LinkRoot = createPolymorphicComponent(props => {
  let ref;
  props = mergeDefaultProps({
    as: "a"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled: () => others.isDisabled
  });
  const {
    isFocused,
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  const tagName = createTagName(() => ref, () => local.as || "a");
  return createComponent(Pressable, mergeProps$1({
    get as() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "a" ? "link" : undefined;
    },
    get tabIndex() {
      return tagName() !== "a" && !others.isDisabled ? 0 : undefined;
    },
    get ["data-hover"]() {
      return isHovered() ? "" : undefined;
    },
    get ["data-focus"]() {
      return isFocused() ? "" : undefined;
    },
    get ["data-focus-visible"]() {
      return isFocusVisible() ? "" : undefined;
    },
    get onPointerEnter() {
      return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
    },
    get onPointerLeave() {
      return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
    }
  }, others));
});

var index$k = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: LinkRoot
});

/**
 * The breadcrumbs link.
 */
const BreadcrumbsLink = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "a"
  }, props);
  const [local, others] = splitProps(props, ["isCurrent", "isDisabled", "aria-current"]);
  const ariaCurrent = () => {
    if (!local.isCurrent) {
      return undefined;
    }
    return local["aria-current"] || "page";
  };
  return createComponent(LinkRoot, mergeProps$1({
    get isDisabled() {
      return local.isDisabled || local.isCurrent;
    },
    get ["aria-current"]() {
      return ariaCurrent();
    },
    get ["data-current"]() {
      return local.isCurrent ? "" : undefined;
    }
  }, others));
});

const BREADCRUMBS_INTL_MESSAGES = {
  "ar-AE": {
    breadcrumbs: "عناصر الواجهة"
  },
  "bg-BG": {
    breadcrumbs: "Трохи хляб"
  },
  "cs-CZ": {
    breadcrumbs: "Popis cesty"
  },
  "da-DK": {
    breadcrumbs: "Brødkrummer"
  },
  "de-DE": {
    breadcrumbs: "Breadcrumbs"
  },
  "el-GR": {
    breadcrumbs: "Πλοηγήσεις breadcrumb"
  },
  "en-US": {
    breadcrumbs: "Breadcrumbs"
  },
  "es-ES": {
    breadcrumbs: "Migas de pan"
  },
  "et-EE": {
    breadcrumbs: "Lingiread"
  },
  "fi-FI": {
    breadcrumbs: "Navigointilinkit"
  },
  "fr-FR": {
    breadcrumbs: "Chemin de navigation"
  },
  "he-IL": {
    breadcrumbs: "שבילי ניווט"
  },
  "hr-HR": {
    breadcrumbs: "Navigacijski putovi"
  },
  "hu-HU": {
    breadcrumbs: "Morzsamenü"
  },
  "it-IT": {
    breadcrumbs: "Breadcrumb"
  },
  "ja-JP": {
    breadcrumbs: "パンくずリスト"
  },
  "ko-KR": {
    breadcrumbs: "탐색 표시"
  },
  "lt-LT": {
    breadcrumbs: "Naršymo kelias"
  },
  "lv-LV": {
    breadcrumbs: "Atpakaļceļi"
  },
  "nb-NO": {
    breadcrumbs: "Navigasjonsstier"
  },
  "nl-NL": {
    breadcrumbs: "Broodkruimels"
  },
  "pl-PL": {
    breadcrumbs: "Struktura nawigacyjna"
  },
  "pt-BR": {
    breadcrumbs: "Caminho detalhado"
  },
  "pt-PT": {
    breadcrumbs: "Categorias"
  },
  "ro-RO": {
    breadcrumbs: "Miez de pâine"
  },
  "ru-RU": {
    breadcrumbs: "Навигация"
  },
  "sk-SK": {
    breadcrumbs: "Navigačné prvky Breadcrumbs"
  },
  "sl-SI": {
    breadcrumbs: "Drobtine"
  },
  "sr-SP": {
    breadcrumbs: "Putanje navigacije"
  },
  "sv-SE": {
    breadcrumbs: "Sökvägar"
  },
  "tr-TR": {
    breadcrumbs: "İçerik haritaları"
  },
  "uk-UA": {
    breadcrumbs: "Навігаційна стежка"
  },
  "zh-CN": {
    breadcrumbs: "导航栏"
  },
  "zh-TW": {
    breadcrumbs: "導覽列"
  }
};

const BreadcrumbsContext = createContext();
function useBreadcrumbsContext() {
  const context = useContext(BreadcrumbsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useBreadcrumbsContext` must be used within a `Breadcrumbs.Root` component");
  }
  return context;
}

/**
 * Breadcrumbs show hierarchy and navigational context for a user’s location within an application.
 */
const BreadcrumbsRoot = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "nav",
    separator: "/"
  }, props);
  const [local, others] = splitProps(props, ["as", "separator"]);
  const formatter = createLocalizedStringFormatter(() => BREADCRUMBS_INTL_MESSAGES);
  const context = {
    separator: () => local.separator
  };
  return createComponent(BreadcrumbsContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        get ["aria-label"]() {
          return formatter().format("breadcrumbs");
        }
      }, others));
    }
  });
});

/**
 * The visual separator between each breadcrumb items.
 * It will not be visible by screen readers.
 */
const BreadcrumbsSeparator = createPolymorphicComponent(props => {
  const context = useBreadcrumbsContext();
  props = mergeDefaultProps({
    as: "span"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get children() {
      return context.separator();
    },
    "aria-hidden": "true"
  }, others));
});

var index$j = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Link: BreadcrumbsLink,
  Root: BreadcrumbsRoot,
  Separator: BreadcrumbsSeparator
});

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/tree/main/packages/%40react-aria/calendar/intl
 */

const CALENDAR_INTL_MESSAGES = {
  "ar-AE": {
    dateRange: "{startDate} إلى {endDate}",
    dateSelected: "{date} المحدد",
    finishRangeSelectionPrompt: "انقر لإنهاء عملية تحديد نطاق التاريخ",
    maximumDate: "آخر تاريخ متاح",
    minimumDate: "أول تاريخ متاح",
    next: "التالي",
    previous: "السابق",
    selectedDateDescription: "تاريخ محدد: {date}",
    selectedRangeDescription: "المدى الزمني المحدد: {dateRange}",
    startRangeSelectionPrompt: "انقر لبدء عملية تحديد نطاق التاريخ",
    todayDate: "اليوم، {date}",
    todayDateSelected: "اليوم، {date} محدد"
  },
  "bg-BG": {
    dateRange: "{startDate} до {endDate}",
    dateSelected: "Избрано е {date}",
    finishRangeSelectionPrompt: "Натиснете, за да довършите избора на времеви интервал",
    maximumDate: "Последна налична дата",
    minimumDate: "Първа налична дата",
    next: "Напред",
    previous: "Назад",
    selectedDateDescription: "Избрана дата: {date}",
    selectedRangeDescription: "Избран диапазон: {dateRange}",
    startRangeSelectionPrompt: "Натиснете, за да пристъпите към избора на времеви интервал",
    todayDate: "Днес, {date}",
    todayDateSelected: "Днес, {date} са избрани"
  },
  "cs-CZ": {
    dateRange: "{startDate} až {endDate}",
    dateSelected: "Vybráno {date}",
    finishRangeSelectionPrompt: "Kliknutím dokončíte výběr rozsahu dat",
    maximumDate: "Poslední dostupné datum",
    minimumDate: "První dostupné datum",
    next: "Další",
    previous: "Předchozí",
    selectedDateDescription: "Vybrané datum: {date}",
    selectedRangeDescription: "Vybrané období: {dateRange}",
    startRangeSelectionPrompt: "Kliknutím zahájíte výběr rozsahu dat",
    todayDate: "Dnes, {date}",
    todayDateSelected: "Dnes, vybráno {date}"
  },
  "da-DK": {
    dateRange: "{startDate} til {endDate}",
    dateSelected: "{date} valgt",
    finishRangeSelectionPrompt: "Klik for at fuldføre valg af datoområde",
    maximumDate: "Sidste ledige dato",
    minimumDate: "Første ledige dato",
    next: "Næste",
    previous: "Forrige",
    selectedDateDescription: "Valgt dato: {date}",
    selectedRangeDescription: "Valgt interval: {dateRange}",
    startRangeSelectionPrompt: "Klik for at starte valg af datoområde",
    todayDate: "I dag, {date}",
    todayDateSelected: "I dag, {date} valgt"
  },
  "de-DE": {
    dateRange: "{startDate} bis {endDate}",
    dateSelected: "{date} ausgewählt",
    finishRangeSelectionPrompt: "Klicken, um die Auswahl des Datumsbereichs zu beenden",
    maximumDate: "Letztes verfügbares Datum",
    minimumDate: "Erstes verfügbares Datum",
    next: "Weiter",
    previous: "Zurück",
    selectedDateDescription: "Ausgewähltes Datum: {date}",
    selectedRangeDescription: "Ausgewählter Bereich: {dateRange}",
    startRangeSelectionPrompt: "Klicken, um die Auswahl des Datumsbereichs zu beginnen",
    todayDate: "Heute, {date}",
    todayDateSelected: "Heute, {date} ausgewählt"
  },
  "el-GR": {
    dateRange: "{startDate} έως {endDate}",
    dateSelected: "Επιλέχθηκε {date}",
    finishRangeSelectionPrompt: "Κάντε κλικ για να ολοκληρώσετε την επιλογή εύρους ημερομηνιών",
    maximumDate: "Τελευταία διαθέσιμη ημερομηνία",
    minimumDate: "Πρώτη διαθέσιμη ημερομηνία",
    next: "Επόμενο",
    previous: "Προηγούμενο",
    selectedDateDescription: "Επιλεγμένη ημερομηνία: {date}",
    selectedRangeDescription: "Επιλεγμένο εύρος: {dateRange}",
    startRangeSelectionPrompt: "Κάντε κλικ για να ξεκινήσετε την επιλογή εύρους ημερομηνιών",
    todayDate: "Σήμερα, {date}",
    todayDateSelected: "Σήμερα, επιλέχτηκε {date}"
  },
  "en-US": {
    dateRange: "{startDate} to {endDate}",
    dateSelected: "{date} selected",
    finishRangeSelectionPrompt: "Click to finish selecting date range",
    maximumDate: "Last available date",
    minimumDate: "First available date",
    next: "Next",
    previous: "Previous",
    selectedDateDescription: "Selected Date: {date}",
    selectedRangeDescription: "Selected Range: {dateRange}",
    startRangeSelectionPrompt: "Click to start selecting date range",
    todayDate: "Today, {date}",
    todayDateSelected: "Today, {date} selected"
  },
  "es-ES": {
    dateRange: "{startDate} a {endDate}",
    dateSelected: "{date} seleccionado",
    finishRangeSelectionPrompt: "Haga clic para terminar de seleccionar rango de fechas",
    maximumDate: "Última fecha disponible",
    minimumDate: "Primera fecha disponible",
    next: "Siguiente",
    previous: "Anterior",
    selectedDateDescription: "Fecha seleccionada: {date}",
    selectedRangeDescription: "Intervalo seleccionado: {dateRange}",
    startRangeSelectionPrompt: "Haga clic para comenzar a seleccionar un rango de fechas",
    todayDate: "Hoy, {date}",
    todayDateSelected: "Hoy, {date} seleccionado"
  },
  "et-EE": {
    dateRange: "{startDate} kuni {endDate}",
    dateSelected: "{date} valitud",
    finishRangeSelectionPrompt: "Klõpsake kuupäevavahemiku valimise lõpetamiseks",
    maximumDate: "Viimane saadaolev kuupäev",
    minimumDate: "Esimene saadaolev kuupäev",
    next: "Järgmine",
    previous: "Eelmine",
    selectedDateDescription: "Valitud kuupäev: {date}",
    selectedRangeDescription: "Valitud vahemik: {dateRange}",
    startRangeSelectionPrompt: "Klõpsake kuupäevavahemiku valimiseks",
    todayDate: "Täna, {date}",
    todayDateSelected: "Täna, {date} valitud"
  },
  "fi-FI": {
    dateRange: "{startDate} – {endDate}",
    dateSelected: "{date} valittu",
    finishRangeSelectionPrompt: "Lopeta päivämääräalueen valinta napsauttamalla tätä.",
    maximumDate: "Viimeinen varattavissa oleva päivämäärä",
    minimumDate: "Ensimmäinen varattavissa oleva päivämäärä",
    next: "Seuraava",
    previous: "Edellinen",
    selectedDateDescription: "Valittu päivämäärä: {date}",
    selectedRangeDescription: "Valittu aikaväli: {dateRange}",
    startRangeSelectionPrompt: "Aloita päivämääräalueen valinta napsauttamalla tätä.",
    todayDate: "Tänään, {date}",
    todayDateSelected: "Tänään, {date} valittu"
  },
  "fr-FR": {
    dateRange: "{startDate} à {endDate}",
    dateSelected: "{date} sélectionné",
    finishRangeSelectionPrompt: "Cliquer pour finir de sélectionner la plage de dates",
    maximumDate: "Dernière date disponible",
    minimumDate: "Première date disponible",
    next: "Suivant",
    previous: "Précédent",
    selectedDateDescription: "Date sélectionnée : {date}",
    selectedRangeDescription: "Plage sélectionnée : {dateRange}",
    startRangeSelectionPrompt: "Cliquer pour commencer à sélectionner la plage de dates",
    todayDate: "Aujourd'hui, {date}",
    todayDateSelected: "Aujourd’hui, {date} sélectionné"
  },
  "he-IL": {
    dateRange: "{startDate} עד {endDate}",
    dateSelected: "{date} נבחר",
    finishRangeSelectionPrompt: "חץ כדי לסיים את בחירת טווח התאריכים",
    maximumDate: "תאריך פנוי אחרון",
    minimumDate: "תאריך פנוי ראשון",
    next: "הבא",
    previous: "הקודם",
    selectedDateDescription: "תאריך נבחר: {date}",
    selectedRangeDescription: "טווח נבחר: {dateRange}",
    startRangeSelectionPrompt: "לחץ כדי להתחיל בבחירת טווח התאריכים",
    todayDate: "היום, {date}",
    todayDateSelected: "היום, {date} נבחר"
  },
  "hr-HR": {
    dateRange: "{startDate} do {endDate}",
    dateSelected: "{date} odabran",
    finishRangeSelectionPrompt: "Kliknite da dovršite raspon odabranih datuma",
    maximumDate: "Posljednji raspoloživi datum",
    minimumDate: "Prvi raspoloživi datum",
    next: "Sljedeći",
    previous: "Prethodni",
    selectedDateDescription: "Odabrani datum: {date}",
    selectedRangeDescription: "Odabrani raspon: {dateRange}",
    startRangeSelectionPrompt: "Kliknite da započnete raspon odabranih datuma",
    todayDate: "Danas, {date}",
    todayDateSelected: "Danas, odabran {date}"
  },
  "hu-HU": {
    dateRange: "{startDate}–{endDate}",
    dateSelected: "{date} kiválasztva",
    finishRangeSelectionPrompt: "Kattintson a dátumtartomány kijelölésének befejezéséhez",
    maximumDate: "Utolsó elérhető dátum",
    minimumDate: "Az első elérhető dátum",
    next: "Következő",
    previous: "Előző",
    selectedDateDescription: "Kijelölt dátum: {date}",
    selectedRangeDescription: "Kijelölt tartomány: {dateRange}",
    startRangeSelectionPrompt: "Kattintson a dátumtartomány kijelölésének indításához",
    todayDate: "Ma, {date}",
    todayDateSelected: "Ma, {date} kijelölve"
  },
  "it-IT": {
    dateRange: "Da {startDate} a {endDate}",
    dateSelected: "{date} selezionata",
    finishRangeSelectionPrompt: "Fai clic per completare la selezione dell’intervallo di date",
    maximumDate: "Ultima data disponibile",
    minimumDate: "Prima data disponibile",
    next: "Successivo",
    previous: "Precedente",
    selectedDateDescription: "Data selezionata: {date}",
    selectedRangeDescription: "Intervallo selezionato: {dateRange}",
    startRangeSelectionPrompt: "Fai clic per selezionare l’intervallo di date",
    todayDate: "Oggi, {date}",
    todayDateSelected: "Oggi, {date} selezionata"
  },
  "ja-JP": {
    dateRange: "{startDate} から {endDate}",
    dateSelected: "{date} を選択",
    finishRangeSelectionPrompt: "クリックして日付範囲の選択を終了",
    maximumDate: "最終利用可能日",
    minimumDate: "最初の利用可能日",
    next: "次へ",
    previous: "前へ",
    selectedDateDescription: "選択した日付 : {date}",
    selectedRangeDescription: "選択範囲 : {dateRange}",
    startRangeSelectionPrompt: "クリックして日付範囲の選択を開始",
    todayDate: "本日、{date}",
    todayDateSelected: "本日、{date} を選択"
  },
  "ko-KR": {
    dateRange: "{startDate} ~ {endDate}",
    dateSelected: "{date} 선택됨",
    finishRangeSelectionPrompt: "날짜 범위 선택을 완료하려면 클릭하십시오.",
    maximumDate: "마지막으로 사용 가능한 일자",
    minimumDate: "처음으로 사용 가능한 일자",
    next: "다음",
    previous: "이전",
    selectedDateDescription: "선택 일자: {date}",
    selectedRangeDescription: "선택 범위: {dateRange}",
    startRangeSelectionPrompt: "날짜 범위 선택을 시작하려면 클릭하십시오.",
    todayDate: "오늘, {date}",
    todayDateSelected: "오늘, {date} 선택됨"
  },
  "lt-LT": {
    dateRange: "Nuo {startDate} iki {endDate}",
    dateSelected: "Pasirinkta {date}",
    finishRangeSelectionPrompt: "Spustelėkite, kad baigtumėte pasirinkti datų intervalą",
    maximumDate: "Paskutinė galima data",
    minimumDate: "Pirmoji galima data",
    next: "Paskesnis",
    previous: "Ankstesnis",
    selectedDateDescription: "Pasirinkta data: {date}",
    selectedRangeDescription: "Pasirinktas intervalas: {dateRange}",
    startRangeSelectionPrompt: "Spustelėkite, kad pradėtumėte pasirinkti datų intervalą",
    todayDate: "Šiandien, {date}",
    todayDateSelected: "Šiandien, pasirinkta {date}"
  },
  "lv-LV": {
    dateRange: "No {startDate} līdz {endDate}",
    dateSelected: "Atlasīts: {date}",
    finishRangeSelectionPrompt: "Noklikšķiniet, lai pabeigtu datumu diapazona atlasi",
    maximumDate: "Pēdējais pieejamais datums",
    minimumDate: "Pirmais pieejamais datums",
    next: "Tālāk",
    previous: "Atpakaļ",
    selectedDateDescription: "Atlasītais datums: {date}",
    selectedRangeDescription: "Atlasītais diapazons: {dateRange}",
    startRangeSelectionPrompt: "Noklikšķiniet, lai sāktu datumu diapazona atlasi",
    todayDate: "Šodien, {date}",
    todayDateSelected: "Atlasīta šodiena, {date}"
  },
  "nb-NO": {
    dateRange: "{startDate} til {endDate}",
    dateSelected: "{date} valgt",
    finishRangeSelectionPrompt: "Klikk for å fullføre valg av datoområde",
    maximumDate: "Siste tilgjengelige dato",
    minimumDate: "Første tilgjengelige dato",
    next: "Neste",
    previous: "Forrige",
    selectedDateDescription: "Valgt dato: {date}",
    selectedRangeDescription: "Valgt område: {dateRange}",
    startRangeSelectionPrompt: "Klikk for å starte valg av datoområde",
    todayDate: "I dag, {date}",
    todayDateSelected: "I dag, {date} valgt"
  },
  "nl-NL": {
    dateRange: "{startDate} tot {endDate}",
    dateSelected: "{date} geselecteerd",
    finishRangeSelectionPrompt: "Klik om de selectie van het datumbereik te voltooien",
    maximumDate: "Laatste beschikbare datum",
    minimumDate: "Eerste beschikbare datum",
    next: "Volgende",
    previous: "Vorige",
    selectedDateDescription: "Geselecteerde datum: {date}",
    selectedRangeDescription: "Geselecteerd bereik: {dateRange}",
    startRangeSelectionPrompt: "Klik om het datumbereik te selecteren",
    todayDate: "Vandaag, {date}",
    todayDateSelected: "Vandaag, {date} geselecteerd"
  },
  "pl-PL": {
    dateRange: "{startDate} do {endDate}",
    dateSelected: "Wybrano {date}",
    finishRangeSelectionPrompt: "Kliknij, aby zakończyć wybór zakresu dat",
    maximumDate: "Ostatnia dostępna data",
    minimumDate: "Pierwsza dostępna data",
    next: "Dalej",
    previous: "Wstecz",
    selectedDateDescription: "Wybrana data: {date}",
    selectedRangeDescription: "Wybrany zakres: {dateRange}",
    startRangeSelectionPrompt: "Kliknij, aby rozpocząć wybór zakresu dat",
    todayDate: "Dzisiaj, {date}",
    todayDateSelected: "Dzisiaj wybrano {date}"
  },
  "pt-BR": {
    dateRange: "{startDate} a {endDate}",
    dateSelected: "{date} selecionado",
    finishRangeSelectionPrompt: "Clique para concluir a seleção do intervalo de datas",
    maximumDate: "Última data disponível",
    minimumDate: "Primeira data disponível",
    next: "Próximo",
    previous: "Anterior",
    selectedDateDescription: "Data selecionada: {date}",
    selectedRangeDescription: "Intervalo selecionado: {dateRange}",
    startRangeSelectionPrompt: "Clique para iniciar a seleção do intervalo de datas",
    todayDate: "Hoje, {date}",
    todayDateSelected: "Hoje, {date} selecionado"
  },
  "pt-PT": {
    dateRange: "{startDate} a {endDate}",
    dateSelected: "{date} selecionado",
    finishRangeSelectionPrompt: "Clique para terminar de selecionar o intervalo de datas",
    maximumDate: "Última data disponível",
    minimumDate: "Primeira data disponível",
    next: "Próximo",
    previous: "Anterior",
    selectedDateDescription: "Data selecionada: {date}",
    selectedRangeDescription: "Intervalo selecionado: {dateRange}",
    startRangeSelectionPrompt: "Clique para começar a selecionar o intervalo de datas",
    todayDate: "Hoje, {date}",
    todayDateSelected: "Hoje, {date} selecionado"
  },
  "ro-RO": {
    dateRange: "De la {startDate} până la {endDate}",
    dateSelected: "{date} selectată",
    finishRangeSelectionPrompt: "Apăsaţi pentru a finaliza selecţia razei pentru dată",
    maximumDate: "Ultima dată disponibilă",
    minimumDate: "Prima dată disponibilă",
    next: "Următorul",
    previous: "Înainte",
    selectedDateDescription: "Dată selectată: {date}",
    selectedRangeDescription: "Interval selectat: {dateRange}",
    startRangeSelectionPrompt: "Apăsaţi pentru a începe selecţia razei pentru dată",
    todayDate: "Astăzi, {date}",
    todayDateSelected: "Azi, {date} selectată"
  },
  "ru-RU": {
    dateRange: "С {startDate} по {endDate}",
    dateSelected: "Выбрано {date}",
    finishRangeSelectionPrompt: "Щелкните, чтобы завершить выбор диапазона дат",
    maximumDate: "Последняя доступная дата",
    minimumDate: "Первая доступная дата",
    next: "Далее",
    previous: "Назад",
    selectedDateDescription: "Выбранная дата: {date}",
    selectedRangeDescription: "Выбранный диапазон: {dateRange}",
    startRangeSelectionPrompt: "Щелкните, чтобы начать выбор диапазона дат",
    todayDate: "Сегодня, {date}",
    todayDateSelected: "Сегодня, выбрано {date}"
  },
  "sk-SK": {
    dateRange: "Od {startDate} do {endDate}",
    dateSelected: "Vybratý dátum {date}",
    finishRangeSelectionPrompt: "Kliknutím dokončíte výber rozsahu dátumov",
    maximumDate: "Posledný dostupný dátum",
    minimumDate: "Prvý dostupný dátum",
    next: "Nasledujúce",
    previous: "Predchádzajúce",
    selectedDateDescription: "Vybratý dátum: {date}",
    selectedRangeDescription: "Vybratý rozsah: {dateRange}",
    startRangeSelectionPrompt: "Kliknutím spustíte výber rozsahu dátumov",
    todayDate: "Dnes {date}",
    todayDateSelected: "Vybratý dnešný dátum {date}"
  },
  "sl-SI": {
    dateRange: "{startDate} do {endDate}",
    dateSelected: "{date} izbrano",
    finishRangeSelectionPrompt: "Kliknite za dokončanje izbire datumskega obsega",
    maximumDate: "Zadnji razpoložljivi datum",
    minimumDate: "Prvi razpoložljivi datum",
    next: "Naprej",
    previous: "Nazaj",
    selectedDateDescription: "Izbrani datum: {date}",
    selectedRangeDescription: "Izbrano območje: {dateRange}",
    startRangeSelectionPrompt: "Kliknite za začetek izbire datumskega obsega",
    todayDate: "Danes, {date}",
    todayDateSelected: "Danes, {date} izbrano"
  },
  "sr-SP": {
    dateRange: "{startDate} do {endDate}",
    dateSelected: "{date} izabran",
    finishRangeSelectionPrompt: "Kliknite da dovršite opseg izabranih datuma",
    maximumDate: "Zadnji raspoloživi datum",
    minimumDate: "Prvi raspoloživi datum",
    next: "Sledeći",
    previous: "Prethodni",
    selectedDateDescription: "Izabrani datum: {date}",
    selectedRangeDescription: "Izabrani period: {dateRange}",
    startRangeSelectionPrompt: "Kliknite da započnete opseg izabranih datuma",
    todayDate: "Danas, {date}",
    todayDateSelected: "Danas, izabran {date}"
  },
  "sv-SE": {
    dateRange: "{startDate} till {endDate}",
    dateSelected: "{date} har valts",
    finishRangeSelectionPrompt: "Klicka för att avsluta val av datumintervall",
    maximumDate: "Sista tillgängliga datum",
    minimumDate: "Första tillgängliga datum",
    next: "Nästa",
    previous: "Föregående",
    selectedDateDescription: "Valt datum: {date}",
    selectedRangeDescription: "Valt intervall: {dateRange}",
    startRangeSelectionPrompt: "Klicka för att välja datumintervall",
    todayDate: "Idag, {date}",
    todayDateSelected: "Idag, {date} har valts"
  },
  "tr-TR": {
    dateRange: "{startDate} - {endDate}",
    dateSelected: "{date} seçildi",
    finishRangeSelectionPrompt: "Tarih aralığı seçimini tamamlamak için tıklayın",
    maximumDate: "Son müsait tarih",
    minimumDate: "İlk müsait tarih",
    next: "Sonraki",
    previous: "Önceki",
    selectedDateDescription: "Seçilen Tarih: {date}",
    selectedRangeDescription: "Seçilen Aralık: {dateRange}",
    startRangeSelectionPrompt: "Tarih aralığı seçimini başlatmak için tıklayın",
    todayDate: "Bugün, {date}",
    todayDateSelected: "Bugün, {date} seçildi"
  },
  "uk-UA": {
    dateRange: "{startDate} — {endDate}",
    dateSelected: "Вибрано {date}",
    finishRangeSelectionPrompt: "Натисніть, щоб завершити вибір діапазону дат",
    maximumDate: "Остання доступна дата",
    minimumDate: "Перша доступна дата",
    next: "Наступний",
    previous: "Попередній",
    selectedDateDescription: "Вибрана дата: {date}",
    selectedRangeDescription: "Вибраний діапазон: {dateRange}",
    startRangeSelectionPrompt: "Натисніть, щоб почати вибір діапазону дат",
    todayDate: "Сьогодні, {date}",
    todayDateSelected: "Сьогодні, вибрано {date}"
  },
  "zh-CN": {
    dateRange: "{startDate} 至 {endDate}",
    dateSelected: "已选定 {date}",
    finishRangeSelectionPrompt: "单击以完成选择日期范围",
    maximumDate: "最后一个可用日期",
    minimumDate: "第一个可用日期",
    next: "下一页",
    previous: "上一页",
    selectedDateDescription: "选定的日期：{date}",
    selectedRangeDescription: "选定的范围：{dateRange}",
    startRangeSelectionPrompt: "单击以开始选择日期范围",
    todayDate: "今天，即 {date}",
    todayDateSelected: "已选定今天，即 {date}"
  },
  "zh-TW": {
    dateRange: "{startDate} 至 {endDate}",
    dateSelected: "已選取 {date}",
    finishRangeSelectionPrompt: "按一下以完成選取日期範圍",
    maximumDate: "最後一個可用日期",
    minimumDate: "第一個可用日期",
    next: "下一頁",
    previous: "上一頁",
    selectedDateDescription: "選定的日期：{date}",
    selectedRangeDescription: "選定的範圍：{dateRange}",
    startRangeSelectionPrompt: "按一下以開始選取日期範圍",
    todayDate: "今天，{date}",
    todayDateSelected: "已選取今天，{date}"
  }
};

const CalendarCellContext = createContext();
function useCalendarCellContext() {
  const context = useContext(CalendarCellContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarCellContext` must be used within a `Calendar.Cell` component");
  }
  return context;
}

const CalendarContext = createContext();
function useCalendarContext() {
  const context = useContext(CalendarContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarContext` must be used within a `Calendar` component");
  }
  return context;
}

const CalendarMonthContext = createContext();
function useCalendarMonthContext() {
  const context = useContext(CalendarMonthContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCalendarMonthContext` must be used within a `Calendar.Month` component");
  }
  return context;
}

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-stately/calendar/src/utils.ts
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/calendar/src/utils.ts
 */
function isInvalid(date, minValue, maxValue) {
  return minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0;
}
function alignCenter(date, duration, locale, minValue, maxValue) {
  const halfDuration = {};
  for (const key in duration) {
    //@ts-ignore
    halfDuration[key] = Math.floor(duration[key] / 2);

    //@ts-ignore
    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {
      //@ts-ignore
      halfDuration[key]--;
    }
  }
  const aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, minValue, maxValue);
}
function alignStart(date, duration, locale, minValue, maxValue) {
  // align to the start of the largest unit
  let aligned = date;
  if (duration.years) {
    aligned = startOfYear(date);
  } else if (duration.months) {
    aligned = startOfMonth(date);
  } else if (duration.weeks) {
    aligned = startOfWeek(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, minValue, maxValue);
}
function alignEnd(date, duration, locale, minValue, maxValue) {
  const d = {
    ...duration
  };

  // subtract 1 from the smallest unit
  if (duration.days) {
    d.days--;
  } else if (duration.weeks) {
    d.weeks--;
  } else if (duration.months) {
    d.months--;
  } else if (duration.years) {
    d.years--;
  }
  const aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, minValue, maxValue);
}
function constrainStart(date, aligned, duration, locale, minValue, maxValue) {
  if (minValue && date.compare(minValue) >= 0) {
    aligned = maxDate(aligned, alignStart(toCalendarDate(minValue), duration, locale));
  }
  if (maxValue && date.compare(maxValue) <= 0) {
    aligned = minDate(aligned, alignEnd(toCalendarDate(maxValue), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue) {
  if (minValue) {
    date = maxDate(date, toCalendarDate(minValue));
  }
  if (maxValue) {
    date = minDate(date, toCalendarDate(maxValue));
  }
  return date;
}
function previousAvailableDate(date, minValue, isDateUnavailable) {
  if (!isDateUnavailable) {
    return date;
  }
  while (date.compare(minValue) >= 0 && isDateUnavailable(date)) {
    date = date.subtract({
      days: 1
    });
  }
  if (date.compare(minValue) >= 0) {
    return date;
  }
}
function getEraFormat(date) {
  return date?.calendar.identifier === "gregory" && date.era === "BC" ? "short" : undefined;
}
function formatRange(dateFormatter, stringFormatter, start, end, timeZone) {
  const parts = dateFormatter.formatRangeToParts(start.toDate(timeZone), end.toDate(timeZone));

  // Find the separator between the start and end date. This is determined
  // by finding the last shared literal before the end range.
  let separatorIndex = -1;
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }

  // Now we can combine the parts into start and end strings.
  let startValue = "";
  let endValue = "";
  for (let i = 0; i < parts.length; i++) {
    if (i < separatorIndex) {
      startValue += parts[i].value;
    } else if (i > separatorIndex) {
      endValue += parts[i].value;
    }
  }
  return stringFormatter.format("dateRange", {
    startDate: startValue,
    endDate: endValue
  });
}
function unitDuration(duration) {
  const unit = {
    ...duration
  };
  for (const key in duration) {
    // @ts-ignore
    unit[key] = 1;
  }
  return unit;
}

const _tmpl$$9 = /*#__PURE__*/template(`<td></td>`, 2);
const CalendarCellBase = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  props = mergeDefaultProps({
    as: "td"
  }, props);
  const [local, others] = splitProps(props, ["as", "date", "isDisabled"]);
  const state = () => calendarContext.state();
  const stringFormatter = createLocalizedStringFormatter(() => CALENDAR_INTL_MESSAGES);
  const dateFormatter = createDateFormatter(() => ({
    weekday: "long",
    day: "numeric",
    month: "long",
    year: "numeric",
    era: getEraFormat(local.date),
    timeZone: state().timeZone()
  }));
  const isInvalid = () => {
    const state = calendarContext.state();
    const isInvalid = state.validationState() === "invalid";
    if ("highlightedRange" in state) {
      const highlightedRange = state.highlightedRange();
      return isInvalid && !state.anchorDate() && highlightedRange != null && local.date.compare(highlightedRange.start) >= 0 && local.date.compare(highlightedRange.end) <= 0;
    }
    const value = state.value();
    return isInvalid && value != null && isSameDay(value, local.date);
  };
  const isSelected = () => isInvalid() || state().isSelected(local.date);
  const isDisabled = () => local.isDisabled || state().isCellDisabled(local.date);
  const isUnavailable = () => state().isCellUnavailable(local.date);
  const isSelectable = () => !isDisabled() && !isUnavailable();
  const nativeDate = createMemo(() => local.date.toDate(calendarContext.state().timeZone()));

  // aria-label should be localized Day of week, Month, Day and Year without Time.
  const label = createMemo(() => {
    const state = calendarContext.state();
    let label = "";

    // If this is a range calendar, add a description of the full selected range
    // to the first and last selected date.
    if ("highlightedRange" in state) {
      const value = state.value();
      if (value && !state.anchorDate() && (isSameDay(local.date, value.start) || isSameDay(local.date, value.end))) {
        label = calendarContext.selectedDateDescription() + ", ";
      }
    }
    label += dateFormatter().format(nativeDate());
    if (isToday(local.date, state.timeZone())) {
      // If date is today, set appropriate string depending on selected state:
      label = stringFormatter().format(isSelected() ? "todayDateSelected" : "todayDate", {
        date: label
      });
    } else if (isSelected()) {
      // If date is selected but not today:
      label = stringFormatter().format("dateSelected", {
        date: label
      });
    }
    const minValue = state.minValue();
    const maxValue = state.maxValue();
    if (minValue && isSameDay(local.date, minValue)) {
      label += ", " + stringFormatter().format("minimumDate");
    } else if (maxValue && isSameDay(local.date, maxValue)) {
      label += ", " + stringFormatter().format("maximumDate");
    }
    return label;
  });
  const context = {
    isSelectable,
    isDisabled,
    isUnavailable,
    isSelected,
    isInvalid,
    date: () => local.date,
    label,
    nativeDate
  };
  return createComponent(CalendarCellContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        role: "gridcell",
        get ["aria-disabled"]() {
          return !isSelectable() || undefined;
        },
        get ["aria-selected"]() {
          return isSelected() || undefined;
        },
        get ["aria-invalid"]() {
          return isInvalid() || undefined;
        }
      }, others));
    }
  });
});
/**
 * The wrapper component for a `Calendar.Day`.
 */
const CalendarCell = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  const monthContext = useCalendarMonthContext();
  const [local, others] = splitProps(props, ["as", "date", "isDisabled"]);
  const shouldMountCell = () => {
    if (!local.date) {
      return false;
    }
    if (calendarContext.hideDatesOutsideMonth()) {
      return isSameMonth(monthContext.startDate(), local.date);
    }
    return true;
  };
  return createComponent(Show, {
    get when() {
      return shouldMountCell();
    },
    get fallback() {
      return _tmpl$$9.cloneNode(true);
    },
    get children() {
      return createComponent(CalendarCellBase, mergeProps$1({
        get date() {
          return local.date;
        },
        get isDisabled() {
          return local.isDisabled;
        }
      }, others));
    }
  });
});

/**
 * A day of the `Calendar.Month` which can be selected by the user.
 */
const CalendarDay = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  const monthContext = useCalendarMonthContext();
  const context = useCalendarCellContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "onFocus", "onContextMenu", "onKeyDown", "onKeyUp", "onClick", "onPointerDown", "onPointerUp", "onMouseDown", "onDragStart", "onPointerEnter", "onPointerLeave", "onFocusIn", "onFocusOut"]);
  const cellDateFormatter = createDateFormatter(() => ({
    day: "numeric",
    timeZone: calendarContext.state().timeZone(),
    calendar: context.date().calendar.identifier
  }));
  const isLastSelectedBeforeDisabled = () => {
    const state = calendarContext.state();
    return !context.isDisabled() && !context.isInvalid() && state.isCellUnavailable(context.date().add({
      days: 1
    }));
  };
  const isFirstSelectedAfterDisabled = () => {
    const state = calendarContext.state();
    return !context.isDisabled() && !context.isInvalid() && state.isCellUnavailable(context.date().subtract({
      days: 1
    }));
  };
  const dayOfWeek = () => {
    return getDayOfWeek(context.date(), calendarContext.state().locale());
  };
  const isRangeStart = () => {
    return context.isSelected() && (isFirstSelectedAfterDisabled() || dayOfWeek() === 0 || context.date().day === 1);
  };
  const isRangeEnd = () => {
    const currentMonth = calendarContext.state().visibleRange().start;
    return context.isSelected() && (isLastSelectedBeforeDisabled() || dayOfWeek() === 6 || context.date().day === currentMonth.calendar.getDaysInMonth(currentMonth));
  };
  const isRangeSelection = () => {
    return context.isSelected() && "highlightedRange" in calendarContext.state();
  };
  const isSelectionStart = () => {
    const state = calendarContext.state();
    if ("highlightedRange" in state) {
      const highlightedRange = state.highlightedRange();
      return context.isSelected() && highlightedRange != null && isSameDay(context.date(), highlightedRange.start);
    }
    return false;
  };
  const isSelectionEnd = () => {
    const state = calendarContext.state();
    if ("highlightedRange" in state) {
      const highlightedRange = state.highlightedRange();
      return context.isSelected() && highlightedRange != null && isSameDay(context.date(), highlightedRange.end);
    }
    return false;
  };
  const isOutsideMonth = () => {
    return !isSameMonth(monthContext.startDate(), context.date());
  };
  const isFocused = () => {
    return calendarContext.state().isCellFocused(context.date());
  };
  const formattedDate = createMemo(() => {
    return cellDateFormatter().format(context.nativeDate());
  });
  const tabIndex = () => {
    if (context.isDisabled() || isOutsideMonth()) {
      return undefined;
    }
    const state = calendarContext.state();
    return isSameDay(context.date(), state.focusedDate()) ? 0 : -1;
  };
  let isAnchorPressed = false;
  let isRangeBoundaryPressed = false;
  let touchDragTimeoutId = null;
  const {
    isPressed,
    pressHandlers
  } = createPress({
    // When dragging to select a range, we don't want dragging over the original anchor
    // again to trigger onPressStart. Cancel presses immediately when the pointer exits.
    cancelOnPointerExit: () => {
      const state = calendarContext.state();
      return "anchorDate" in state && !!state.anchorDate();
    },
    preventFocusOnPress: true,
    isDisabled: () => !context.isSelectable(),
    onPressStart: e => {
      const state = calendarContext.state();
      if (state.isReadOnly()) {
        state.setFocusedDate(context.date());
        return;
      }
      if ("highlightedRange" in state && !state.anchorDate() && (e.pointerType === "mouse" || e.pointerType === "touch")) {
        const highlightedRange = state.highlightedRange();

        // Allow dragging the start or end date of a range to modify it
        // rather than starting a new selection.
        // Don't allow dragging when invalid, or weird jumping behavior may occur as date ranges
        // are constrained to available dates. The user will need to select a new range in this case.
        if (highlightedRange != null && !context.isInvalid()) {
          if (isSameDay(context.date(), highlightedRange.start)) {
            state.setAnchorDate(highlightedRange.end);
            state.setFocusedDate(context.date());
            state.setDragging(true);
            isRangeBoundaryPressed = true;
            return;
          } else if (isSameDay(context.date(), highlightedRange.end)) {
            state.setAnchorDate(highlightedRange.start);
            state.setFocusedDate(context.date());
            state.setDragging(true);
            isRangeBoundaryPressed = true;
            return;
          }
        }
        const startDragging = () => {
          state.setDragging(true);
          touchDragTimeoutId = null;
          state.selectDate(context.date());
          state.setFocusedDate(context.date());
          isAnchorPressed = true;
        };

        // Start selection on mouse/touch down so users can drag to select a range.
        // On touch, delay dragging to determine if the user really meant to scroll.
        if (e.pointerType === "touch") {
          touchDragTimeoutId = window.setTimeout(startDragging, 200);
        } else {
          startDragging();
        }
      }
    },
    onPressEnd: () => {
      isRangeBoundaryPressed = false;
      isAnchorPressed = false;
      if (touchDragTimeoutId != null) {
        window.clearTimeout(touchDragTimeoutId);
      }
      touchDragTimeoutId = null;
    },
    onPress: () => {
      const state = calendarContext.state();

      // For non-range selection, always select on press up.
      if (!("anchorDate" in state) && !state.isReadOnly()) {
        state.selectDate(context.date());
        state.setFocusedDate(context.date());
      }
    },
    onPressUp: e => {
      const state = calendarContext.state();
      if (state.isReadOnly()) {
        return;
      }

      // If the user tapped quickly, the date won't be selected yet and the
      // timer will still be in progress. In this case, select the date on touch up.
      // Timer is cleared in onPressEnd.
      if ("anchorDate" in state && touchDragTimeoutId) {
        state.selectDate(context.date());
        state.setFocusedDate(context.date());
      }
      if ("anchorDate" in state) {
        if (isRangeBoundaryPressed) {
          // When clicking on the start or end date of an already selected range,
          // start a new selection on press up to also allow dragging the date to
          // change the existing range.
          state.setAnchorDate(context.date());
        } else if (state.anchorDate() && !isAnchorPressed) {
          // When releasing a drag or pressing the end date of a range, select it.
          state.selectDate(context.date());
          state.setFocusedDate(context.date());
        } else if (e.pointerType === "keyboard" && !state.anchorDate()) {
          // For range selection, auto-advance the focused date by one if using keyboard.
          // This gives an indication that you're selecting a range rather than a single date.
          // For mouse, this is unnecessary because users will see the indication on hover. For screen readers,
          // there will be an announcement to "click to finish selecting range" (above).
          state.selectDate(context.date());
          let nextDay = context.date().add({
            days: 1
          });
          if (state.isInvalid(nextDay)) {
            nextDay = context.date().subtract({
              days: 1
            });
          }
          if (!state.isInvalid(nextDay)) {
            state.setFocusedDate(nextDay);
          }
        } else if (e.pointerType === "virtual") {
          // For screen readers, just select the date on click.
          state.selectDate(context.date());
          state.setFocusedDate(context.date());
        }
      }
    }
  });
  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled: () => !context.isSelectable()
  });
  const {
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  const onFocus = e => {
    const state = calendarContext.state();
    if (!context.isDisabled()) {
      state.setFocusedDate(context.date());
    }
  };
  const onPointerEnter = e => {
    const state = calendarContext.state();

    // Highlight the date on hover or drag over a date when selecting a range.
    if ("highlightDate" in state && (e.pointerType !== "touch" || state.isDragging()) && context.isSelectable()) {
      state.highlightDate(context.date());
    }
  };
  const onPointerDown = e => {
    // This is necessary on touch devices to allow dragging
    // outside the original pressed element.
    // (JSDOM does not support this)
    if ("releasePointerCapture" in e.target) {
      e.target.releasePointerCapture(e.pointerId);
    }
  };
  const onContextMenu = e => {
    // Prevent context menu on long press.
    e.preventDefault();
  };
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "button",
    get tabIndex() {
      return tabIndex();
    },
    get children() {
      return formattedDate();
    },
    get ["aria-label"]() {
      return context.label();
    },
    get ["aria-disabled"]() {
      return !context.isSelectable() || undefined;
    },
    get ["data-date"]() {
      return context.date();
    },
    get ["data-today"]() {
      return isToday(context.date(), calendarContext.state().timeZone()) ? "" : undefined;
    },
    get ["data-unavailable"]() {
      return context.isUnavailable() ? "" : undefined;
    },
    get ["data-outside-month"]() {
      return isOutsideMonth() ? "" : undefined;
    },
    get ["data-range-start"]() {
      return isRangeStart() ? "" : undefined;
    },
    get ["data-range-end"]() {
      return isRangeEnd() ? "" : undefined;
    },
    get ["data-range-selection"]() {
      return isRangeSelection() ? "" : undefined;
    },
    get ["data-selection-start"]() {
      return isSelectionStart() ? "" : undefined;
    },
    get ["data-selection-end"]() {
      return isSelectionEnd() ? "" : undefined;
    },
    get ["data-selected"]() {
      return context.isSelected() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return context.isDisabled() ? "" : undefined;
    },
    get ["data-invalid"]() {
      return context.isInvalid() ? "" : undefined;
    },
    get ["data-hover"]() {
      return isHovered() ? "" : undefined;
    },
    get ["data-focus"]() {
      return isFocused() ? "" : undefined;
    },
    get ["data-focus-visible"]() {
      return isFocusVisible() ? "" : undefined;
    },
    get ["data-active"]() {
      return isPressed() ? "" : undefined;
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, onFocus]);
    },
    get onContextMenu() {
      return composeEventHandlers([local.onContextMenu, onContextMenu]);
    },
    get onKeyDown() {
      return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
    },
    get onKeyUp() {
      return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
    },
    get onClick() {
      return composeEventHandlers([local.onClick, pressHandlers.onClick]);
    },
    get onPointerDown() {
      return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown, onPointerDown]);
    },
    get onPointerUp() {
      return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
    },
    get onDragStart() {
      return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
    },
    get onPointerEnter() {
      return composeEventHandlers([local.onPointerEnter, onPointerEnter, hoverHandlers.onPointerEnter]);
    },
    get onPointerLeave() {
      return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
    }
  }, others));
});

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-aria/calendar/src/utils.ts
 */
function createSelectedDateDescription(state) {
  const stringFormatter = createLocalizedStringFormatter(() => CALENDAR_INTL_MESSAGES);
  const start = () => {
    if ("highlightedRange" in state) {
      return state.highlightedRange()?.start;
    } else {
      return state.value();
    }
  };
  const end = () => {
    if ("highlightedRange" in state) {
      return state.highlightedRange()?.end;
    } else {
      return state.value();
    }
  };
  const dateFormatter = createDateFormatter(() => {
    const startDate = start();
    const endDate = end();
    let era = startDate ? getEraFormat(startDate) : undefined;
    if (era == null && endDate != null) {
      era = getEraFormat(endDate);
    }
    return {
      weekday: "long",
      month: "long",
      year: "numeric",
      day: "numeric",
      era,
      timeZone: state.timeZone()
    };
  });
  const anchorDate = () => "anchorDate" in state ? state.anchorDate() : null;
  return createMemo(() => {
    const startDate = start();
    const endDate = end();

    // No message if currently selecting a range, or there is nothing highlighted.
    if (!anchorDate() && startDate && endDate) {
      // Use a single date message if the start and end dates are the same day,
      // otherwise include both dates.
      if (isSameDay(startDate, endDate)) {
        const date = dateFormatter().format(startDate.toDate(state.timeZone()));
        return stringFormatter().format("selectedDateDescription", {
          date
        });
      } else {
        const dateRange = formatRange(dateFormatter(), stringFormatter(), startDate, endDate, state.timeZone());
        return stringFormatter().format("selectedRangeDescription", {
          dateRange
        });
      }
    }
    return "";
  });
}
function createVisibleRangeDescription(props) {
  const stringFormatter = createLocalizedStringFormatter(() => CALENDAR_INTL_MESSAGES);
  const era = () => {
    return getEraFormat(props.startDate()) || getEraFormat(props.endDate());
  };
  const monthFormatter = createDateFormatter(() => ({
    month: "long",
    year: "numeric",
    era: era(),
    calendar: props.startDate().calendar.identifier,
    timeZone: props.timeZone()
  }));
  const dateFormatter = createDateFormatter(() => ({
    month: "long",
    year: "numeric",
    day: "numeric",
    era: era(),
    calendar: props.startDate().calendar.identifier,
    timeZone: props.timeZone()
  }));
  return createMemo(() => {
    // Special case for month granularity. Format as a single month if only a
    // single month is visible, otherwise format as a range of months.
    if (isSameDay(props.startDate(), startOfMonth(props.startDate()))) {
      if (isSameDay(props.endDate(), endOfMonth(props.startDate()))) {
        return monthFormatter().format(props.startDate().toDate(props.timeZone()));
      } else if (isSameDay(props.endDate(), endOfMonth(props.endDate()))) {
        if (props.isAria()) {
          return formatRange(monthFormatter(), stringFormatter(), props.startDate(), props.endDate(), props.timeZone());
        } else {
          return monthFormatter().formatRange(props.startDate().toDate(props.timeZone()), props.endDate().toDate(props.timeZone()));
        }
      }
    }
    if (props.isAria()) {
      return formatRange(dateFormatter(), stringFormatter(), props.startDate(), props.endDate(), props.timeZone());
    } else {
      return dateFormatter().formatRange(props.startDate().toDate(props.timeZone()), props.endDate().toDate(props.timeZone()));
    }
  });
}

/**
 * A single grid of days within a `Calendar.Month` which
 * can be navigated via keyboard and selected by the user.
 */
const CalendarGrid = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  const monthContext = useCalendarMonthContext();
  props = mergeDefaultProps({
    as: "table"
  }, props);
  const [local, others] = splitProps(props, ["as", "onKeyDown", "onFocusIn", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const visibleRangeDescription = createVisibleRangeDescription({
    startDate: () => monthContext.startDate(),
    endDate: () => monthContext.endDate(),
    timeZone: () => calendarContext.state().timeZone(),
    isAria: () => true
  });
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    const state = calendarContext.state();
    switch (e.key) {
      case "Enter":
      case " ":
        e.preventDefault();
        state.selectFocusedDate();
        break;
      case "PageUp":
        e.preventDefault();
        e.stopPropagation();
        state.focusPreviousSection(e.shiftKey);
        break;
      case "PageDown":
        e.preventDefault();
        e.stopPropagation();
        state.focusNextSection(e.shiftKey);
        break;
      case "End":
        e.preventDefault();
        e.stopPropagation();
        state.focusSectionEnd();
        break;
      case "Home":
        e.preventDefault();
        e.stopPropagation();
        state.focusSectionStart();
        break;
      case "ArrowLeft":
        e.preventDefault();
        e.stopPropagation();
        if (direction() === "rtl") {
          state.focusNextDay();
        } else {
          state.focusPreviousDay();
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        e.stopPropagation();
        state.focusPreviousRow();
        break;
      case "ArrowRight":
        e.preventDefault();
        e.stopPropagation();
        if (direction() === "rtl") {
          state.focusPreviousDay();
        } else {
          state.focusNextDay();
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        e.stopPropagation();
        state.focusNextRow();
        break;
      case "Escape":
        // Cancel the selection.
        if ("setAnchorDate" in state) {
          e.preventDefault();
          state.setAnchorDate(undefined);
        }
        break;
    }
  };
  const onFocusIn = e => {
    callHandler(e, local.onFocusIn);
    calendarContext.state().setFocused(true);
  };
  const onFocusOut = e => {
    callHandler(e, local.onFocusOut);
    calendarContext.state().setFocused(false);
  };
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    role: "grid",
    get ["aria-readonly"]() {
      return calendarContext.state().isReadOnly() || undefined;
    },
    get ["aria-disabled"]() {
      return calendarContext.state().isDisabled() || undefined;
    },
    get ["aria-multiselectable"]() {
      return "highlightedRange" in calendarContext.state() || undefined;
    },
    get ["aria-label"]() {
      return [calendarContext.ariaLabel(), visibleRangeDescription()].filter(Boolean).join(", ");
    },
    get ["aria-labelledby"]() {
      return calendarContext.ariaLabelledBy();
    },
    onKeyDown: onKeyDown,
    onFocusIn: onFocusIn,
    onFocusOut: onFocusOut
  }, others));
});

/**
 * Contains the day cells of a `Calendar.Grid`.
 */
const CalendarGridBody = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  const monthContext = useCalendarMonthContext();
  props = mergeDefaultProps({
    as: "tbody"
  }, props);
  const [local, others] = splitProps(props, ["as", "children"]);
  const weekIndexes = () => {
    const weeksInMonth = getWeeksInMonth(monthContext.startDate(), calendarContext.state().locale());
    return [...new Array(weeksInMonth).keys()];
  };
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, others, {
    get children() {
      return createComponent(Index, {
        get each() {
          return weekIndexes();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
});

/**
 * The header of a `Calendar.Grid`.
 */
const CalendarGridHeader = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "thead"
  }, props);
  const [local, others] = splitProps(props, ["as"]);

  // Column headers are hidden to screen readers to make navigating with a touch screen reader easier.
  // The day names are already included in the label of each cell, so there's no need to announce them twice.
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    "aria-hidden": "true"
  }, others));
});

/**
 * Contains the title and navigation buttons of a `Calendar.Month`.
 */
const CalendarHeader = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, others));
});

/**
 * Root container for a month within a calendar or range calendar.
 */
const CalendarMonth = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "offset"]);
  const startDate = createMemo(() => {
    const offset = local.offset != null ? {
      months: local.offset
    } : {};
    return calendarContext.state().visibleRange().start.add(offset);
  });
  const endDate = createMemo(() => {
    return endOfMonth(startDate());
  });
  const context = {
    startDate,
    endDate
  };
  return createComponent(CalendarMonthContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }
      }, others));
    }
  });
});

/**
 * A navigation button to go to the next page within a calendar or range calendar.
 */
const CalendarNextPageButton = createPolymorphicComponent(props => {
  const context = useCalendarContext();
  const [local, others] = splitProps(props, ["onPress", "onFocus", "onBlur"]);
  const stringFormatter = createLocalizedStringFormatter(() => CALENDAR_INTL_MESSAGES);
  const onPress = e => {
    local.onPress?.(e);
    context.state().focusNextPage();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    context.setNextFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.setNextFocused(false);
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get isDisabled() {
      return context.isNextDisabled();
    },
    get ["aria-label"]() {
      return stringFormatter().format("next");
    },
    onPress: onPress,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
});

/**
 * A navigation button to go to the previous page within a calendar or range calendar.
 */
const CalendarPrevPageButton = createPolymorphicComponent(props => {
  const context = useCalendarContext();
  const [local, others] = splitProps(props, ["onPress", "onFocus", "onBlur"]);
  const stringFormatter = createLocalizedStringFormatter(() => CALENDAR_INTL_MESSAGES);
  const onPress = e => {
    local.onPress?.(e);
    context.state().focusPreviousPage();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    context.setPreviousFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.setPreviousFocused(false);
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get isDisabled() {
      return context.isPreviousDisabled();
    },
    get ["aria-label"]() {
      return stringFormatter().format("previous");
    },
    onPress: onPress,
    onFocus: onFocus,
    onBlur: onBlur
  }, others));
});

/**
 * Base component for a calendar, provide context for its children.
 * Used to build calendar and range calendar.
 */
const CalendarBase = createPolymorphicComponent(props => {
  let ref;
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "state", "isDisabled", "hideDatesOutsideMonth", "aria-label", "aria-labelledby"]);
  const visibleRangeDescription = createVisibleRangeDescription({
    startDate: () => local.state.visibleRange().start,
    endDate: () => local.state.visibleRange().end,
    timeZone: () => local.state.timeZone(),
    isAria: () => true
  });
  const selectedDateDescription = createSelectedDateDescription(local.state);
  let isNextFocused = false;
  const isNextDisabled = () => local.isDisabled || local.state.isNextVisibleRangeInvalid();
  let isPreviousFocused = false;
  const isPreviousDisabled = () => local.isDisabled || local.state.isPreviousVisibleRangeInvalid();
  onMount(() => {
    if (ref) {
      local.state.setCalendarRef(ref);
    }
  });

  // Announce when the visible date range changes.
  createEffect(on(visibleRangeDescription, visibleRangeDescription => {
    // Only when pressing the Previous or Next button.
    if (!local.state.isFocused()) {
      announce(visibleRangeDescription);
    }
  }, {
    defer: true
  }));

  // Announce when the selected value changes,
  // handle an update to the caption that describes the currently selected range, to announce the new value
  createEffect(on(selectedDateDescription, selectedDateDescription => {
    if (selectedDateDescription) {
      announce(selectedDateDescription, "polite", 4000);
    }
  }, {
    defer: true
  }));

  // If the next or previous buttons become disabled while they are focused, move focus to the calendar body.
  createEffect(() => {
    if (isNextDisabled() && isNextFocused) {
      isNextFocused = false;
      local.state.setFocused(true);
    }
    if (isPreviousDisabled() && isPreviousFocused) {
      isPreviousFocused = false;
      local.state.setFocused(true);
    }
  });
  const context = {
    state: () => local.state,
    selectedDateDescription,
    isPreviousDisabled,
    isNextDisabled,
    hideDatesOutsideMonth: () => local.hideDatesOutsideMonth ?? false,
    ariaLabel: () => local["aria-label"],
    ariaLabelledBy: () => local["aria-labelledby"],
    setPreviousFocused: newValue => isPreviousFocused = newValue,
    setNextFocused: newValue => isNextFocused = newValue
  };
  return createComponent(CalendarContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "group",
        get ["aria-label"]() {
          return [local["aria-label"], visibleRangeDescription()].filter(Boolean).join(", ");
        },
        get ["aria-labelledby"]() {
          return local["aria-labelledby"];
        }
      }, others));
    }
  });
});

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/15e101b74966bd5eb719c6529ce71ce57eaed430/packages/@react-stately/calendar/src/useCalendarState.ts
 */
/**
 * Provides state management for a calendar component.
 * A calendar displays one or more date grids and allows users to select a single date.
 */
function createCalendarState(props) {
  const {
    locale: defaultLocale
  } = useLocale();
  props = mergeDefaultProps({
    locale: () => defaultLocale(),
    visibleMonths: 1,
    createCalendar
  }, props);
  const [selectedDate, setSelectedDate] = createControllableSignal({
    value: () => access(props.value),
    defaultValue: () => access(props.defaultValue),
    onChange: value => props.onValueChange?.(value)
  });
  const [calendarRef, setCalendarRef] = createSignal();
  const visibleDuration = createMemo(() => {
    return {
      months: access(props.visibleMonths)
    };
  });
  const defaultFormatter = createMemo(() => new DateFormatter(access(props.locale)));
  const resolvedOptions = createMemo(() => defaultFormatter().resolvedOptions());
  const calendar = createMemo(() => props.createCalendar(resolvedOptions().calendar));
  const calendarDateValue = createMemo(() => {
    const value = selectedDate();
    if (value != null) {
      return toCalendar(toCalendarDate(value), calendar());
    }
    return undefined;
  });
  const timeZone = createMemo(() => {
    const value = selectedDate();
    if (value != null && "timeZone" in value) {
      return value.timeZone;
    }
    return resolvedOptions().timeZone;
  });
  const focusedCalendarDate = createMemo(() => {
    const focusedValue = access(props.focusedValue);
    if (focusedValue == null) {
      return undefined;
    }
    const date = toCalendar(toCalendarDate(focusedValue), calendar());
    return constrainValue(date, access(props.minValue), access(props.maxValue));
  });
  const defaultFocusedCalendarDate = createMemo(() => {
    const defaultFocusedValue = access(props.defaultFocusedValue);
    let date;
    if (defaultFocusedValue) {
      date = toCalendar(toCalendarDate(defaultFocusedValue), calendar());
    } else {
      date = calendarDateValue() || toCalendar(today(timeZone()), calendar());
    }
    return constrainValue(date, access(props.minValue), access(props.maxValue));
  });
  const [focusedDate, setFocusedDate] = createControllableSignal({
    value: focusedCalendarDate,
    defaultValue: defaultFocusedCalendarDate,
    onChange: value => props.onFocusChange?.(value)
  });
  const getInitialStartDate = () => {
    // Can't be undefined because of the `defaultFocusedCalendarDate` value.
    const date = focusedDate();

    // Can't be undefined because of the default props.
    const locale = access(props.locale);
    const minValue = access(props.minValue);
    const maxValue = access(props.maxValue);
    switch (access(props.selectionAlignment)) {
      case "start":
        return alignStart(date, visibleDuration(), locale, minValue, maxValue);
      case "end":
        return alignEnd(date, visibleDuration(), locale, minValue, maxValue);
      case "center":
      default:
        return alignCenter(date, visibleDuration(), locale, minValue, maxValue);
    }
  };
  const [startDate, setStartDate] = createSignal(getInitialStartDate());
  const [isFocused, setFocused] = createSignal(access(props.autoFocus) || false);
  const endDate = createMemo(() => {
    return startDate().add({
      ...visibleDuration(),
      days: -1
    });
  });
  const isUnavailable = createMemo(() => {
    const value = calendarDateValue();
    if (!value) {
      return false;
    }
    if (props.isDateUnavailable && props.isDateUnavailable(value)) {
      return true;
    }
    return isInvalid(value, access(props.minValue), access(props.maxValue));
  });
  const validationState = () => {
    return access(props.validationState) || (isUnavailable() ? "invalid" : undefined);
  };

  // Sets focus to a specific cell date
  const focusCell = date => {
    date = constrainValue(date, access(props.minValue), access(props.maxValue));
    setFocusedDate(date);

    // Focus the first tabbable cell button with the focused date in the calendar root DOM subtree.
    const cellButton = calendarRef()?.querySelector(`[data-date='${date}'][tabindex='0']`);
    if (cellButton) {
      focusWithoutScrolling(cellButton);

      // Scroll into view if navigating with a keyboard, otherwise
      // try not to shift the view under the user's mouse/finger.
      // Only scroll the direct scroll parent, not the whole page, so
      // we don't scroll to the bottom when opening date picker popover.
      if (getInteractionModality() !== "pointer") {
        scrollIntoView$1(getScrollParent(cellButton), cellButton);
      }
    }
  };
  const setValue = date => {
    if (access(props.isDisabled) || access(props.isReadOnly)) {
      return;
    }
    const minValue = access(props.minValue);
    const maxValue = access(props.maxValue);
    let newValue = constrainValue(date, minValue, maxValue);
    newValue = previousAvailableDate(newValue, startDate(), props.isDateUnavailable);
    if (!newValue) {
      return;
    }
    const value = selectedDate();

    // The display calendar should not have any effect on the emitted value.
    // Emit dates in the same calendar as the original value, if any, otherwise gregorian.
    newValue = toCalendar(newValue, value?.calendar || new GregorianCalendar());

    // Preserve time if the input value had one.
    if (value && "hour" in value) {
      setSelectedDate(value.set(newValue));
    } else {
      setSelectedDate(newValue);
    }
  };

  // Reset focused date and visible range when calendar changes.
  createEffect(on(() => calendar().identifier, () => {
    const locale = access(props.locale);
    const minValue = access(props.minValue);
    const maxValue = access(props.maxValue);
    const newFocusedDate = toCalendar(focusedDate(), calendar());
    setStartDate(alignCenter(newFocusedDate, visibleDuration(), locale, minValue, maxValue));
    setFocusedDate(newFocusedDate);
  }));
  createEffect(() => {
    let date = focusedDate();
    const locale = access(props.locale);
    const minValue = access(props.minValue);
    const maxValue = access(props.maxValue);
    if (isInvalid(date, minValue, maxValue)) {
      // If the focused date was moved to an invalid value, it can't be focused, so constrain it.
      date = constrainValue(date, minValue, maxValue);
      setFocusedDate(date);
    }
    if (date.compare(startDate()) < 0) {
      setStartDate(alignEnd(date, visibleDuration(), locale, minValue, maxValue));
    } else if (date.compare(endDate()) > 0) {
      setStartDate(alignStart(date, visibleDuration(), locale, minValue, maxValue));
    }
  });
  return {
    setCalendarRef,
    isDisabled: () => access(props.isDisabled) ?? false,
    isReadOnly: () => access(props.isReadOnly) ?? false,
    value: () => calendarDateValue(),
    setValue,
    visibleRange: () => ({
      start: startDate(),
      end: endDate()
    }),
    minValue: () => access(props.minValue),
    maxValue: () => access(props.maxValue),
    focusedDate: () => focusedDate(),
    locale: () => access(props.locale),
    timeZone,
    validationState,
    setFocusedDate(date) {
      focusCell(date);
      setFocused(true);
    },
    focusNextDay() {
      focusCell(focusedDate().add({
        days: 1
      }));
    },
    focusPreviousDay() {
      focusCell(focusedDate().subtract({
        days: 1
      }));
    },
    focusNextRow() {
      focusCell(focusedDate().add({
        weeks: 1
      }));
    },
    focusPreviousRow() {
      focusCell(focusedDate().subtract({
        weeks: 1
      }));
    },
    focusNextPage() {
      const locale = access(props.locale);
      const minValue = access(props.minValue);
      const maxValue = access(props.maxValue);
      const start = startDate().add(visibleDuration());
      const newFocusedDate = constrainValue(focusedDate().add(visibleDuration()), minValue, maxValue);
      setFocusedDate(newFocusedDate);
      setStartDate(alignStart(constrainStart(newFocusedDate, start, visibleDuration(), locale, minValue, maxValue), visibleDuration(), locale));
    },
    focusPreviousPage() {
      const locale = access(props.locale);
      const minValue = access(props.minValue);
      const maxValue = access(props.maxValue);
      const start = startDate().subtract(visibleDuration());
      const newFocusedDate = constrainValue(focusedDate().subtract(visibleDuration()), minValue, maxValue);
      setFocusedDate(newFocusedDate);
      setStartDate(alignStart(constrainStart(newFocusedDate, start, visibleDuration(), locale, minValue, maxValue), visibleDuration(), locale));
    },
    focusSectionStart() {
      focusCell(startOfMonth(focusedDate()));
    },
    focusSectionEnd() {
      focusCell(endOfMonth(focusedDate()));
    },
    focusNextSection(larger) {
      if (!larger) {
        focusCell(focusedDate().add(unitDuration(visibleDuration())));
        return;
      }
      focusCell(focusedDate().add({
        years: 1
      }));
    },
    focusPreviousSection(larger) {
      if (!larger) {
        focusCell(focusedDate().subtract(unitDuration(visibleDuration())));
        return;
      }
      focusCell(focusedDate().subtract({
        years: 1
      }));
    },
    selectFocusedDate() {
      setValue(focusedDate());
    },
    selectDate(date) {
      setValue(date);
    },
    isFocused,
    setFocused,
    isInvalid(date) {
      return isInvalid(date, access(props.minValue), access(props.maxValue));
    },
    isSelected(date) {
      const value = calendarDateValue();
      return value != null && isSameDay(date, value) && !this.isCellDisabled(date) && !this.isCellUnavailable(date);
    },
    isCellFocused(date) {
      const resolvedFocusedDate = focusedDate();
      return isFocused() && resolvedFocusedDate != null && isSameDay(date, resolvedFocusedDate);
    },
    isCellDisabled(date) {
      return access(props.isDisabled) || date.compare(startDate()) < 0 || date.compare(endDate()) > 0 || this.isInvalid(date);
    },
    isCellUnavailable(date) {
      return props.isDateUnavailable?.(date) ?? false;
    },
    isPreviousVisibleRangeInvalid() {
      const prev = startDate().subtract({
        days: 1
      });
      return isSameDay(prev, startDate()) || this.isInvalid(prev);
    },
    isNextVisibleRangeInvalid() {
      // Adding may return the same date if we reached the end of time
      // according to the calendar system (e.g. 9999-12-31).
      const next = endDate().add({
        days: 1
      });
      return isSameDay(next, endDate()) || this.isInvalid(next);
    },
    getDatesInWeek(weekIndex, from) {
      const locale = access(props.locale);
      const start = from ?? startDate();
      let date = start.add({
        weeks: weekIndex
      });
      const dates = [];
      date = startOfWeek(date, locale);

      // startOfWeek will clamp dates within the calendar system's valid range, which may
      // start in the middle of a week. In this case, add null placeholders.
      const dayOfWeek = getDayOfWeek(date, locale);
      for (let i = 0; i < dayOfWeek; i++) {
        dates.push(null);
      }
      while (dates.length < 7) {
        dates.push(date);
        const nextDate = date.add({
          days: 1
        });
        if (isSameDay(date, nextDate)) {
          // If the next day is the same, we have hit the end of the calendar system.
          break;
        }
        date = nextDate;
      }

      // Add null placeholders if at the end of the calendar system.
      while (dates.length < 7) {
        dates.push(null);
      }
      return dates;
    }
  };
}

/**
 * Displays one or more date grids and allows users to select a single date.
 */
const CalendarRoot = createPolymorphicComponent(props => {
  const [calendarProps, others] = splitProps(props, ["value", "defaultValue", "onValueChange", "locale", "createCalendar", "visibleMonths", "selectionAlignment", "minValue", "maxValue", "isDateUnavailable", "isDisabled", "isReadOnly", "autoFocus", "focusedValue", "defaultFocusedValue", "onFocusChange", "validationState"]);
  const state = createCalendarState(calendarProps);
  return createComponent(CalendarBase, mergeProps$1({
    state: state,
    get isDisabled() {
      return access(calendarProps.isDisabled);
    }
  }, others));
});

/**
 * Contains a row of day cells within a `Calendar.Grid`.
 */
const CalendarRow = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  const monthContext = useCalendarMonthContext();
  props = mergeDefaultProps({
    as: "tr"
  }, props);
  const [local, others] = splitProps(props, ["as", "children", "weekIndex"]);
  const datesInWeek = () => {
    return calendarContext.state().getDatesInWeek(local.weekIndex, monthContext.startDate());
  };
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, others, {
    get children() {
      return createComponent(Index, {
        get each() {
          return datesInWeek();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
});

/**
 * A description of the visible `Calendar.Month`.
 */
const CalendarTitle = createPolymorphicComponent(props => {
  const calendarContext = useCalendarContext();
  const monthContext = useCalendarMonthContext();
  props = mergeDefaultProps({
    as: "h2"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  const title = createVisibleRangeDescription({
    startDate: () => monthContext.startDate(),
    endDate: () => monthContext.endDate(),
    timeZone: () => calendarContext.state().timeZone(),
    isAria: () => false
  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get children() {
      return title();
    }
  }, others));
});

/**
 * A weekday cell of a `Calendar.Grid`.
 */
const CalendarWeekDay = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "th"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, others));
});

/**
 * A row in the `Calendar.GridHeader`, used to contain the weekday cells.
 */
const CalendarWeekDays = createPolymorphicComponent(props => {
  const context = useCalendarContext();
  props = mergeDefaultProps({
    as: "tr",
    format: "short"
  }, props);
  const [local, others] = splitProps(props, ["as", "children", "format"]);
  const dayFormatter = createDateFormatter(() => ({
    weekday: local.format,
    timeZone: context.state().timeZone()
  }));
  const weekDays = createMemo(() => {
    const weekStart = startOfWeek(today(context.state().timeZone()), context.state().locale());
    return [...new Array(7).keys()].map(index => {
      const date = weekStart.add({
        days: index
      });
      const dateDay = date.toDate(context.state().timeZone());
      return dayFormatter().format(dateDay);
    });
  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, others, {
    get children() {
      return createComponent(Index, {
        get each() {
          return weekDays();
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
});

var index$i = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Cell: CalendarCell,
  Day: CalendarDay,
  Grid: CalendarGrid,
  GridBody: CalendarGridBody,
  GridHeader: CalendarGridHeader,
  Header: CalendarHeader,
  Month: CalendarMonth,
  NextPageButton: CalendarNextPageButton,
  PrevPageButton: CalendarPrevPageButton,
  Root: CalendarRoot,
  Row: CalendarRow,
  Title: CalendarTitle,
  WeekDay: CalendarWeekDay,
  WeekDays: CalendarWeekDays
});

const CheckboxContext = createContext();
function useCheckboxContext() {
  const context = useContext(CheckboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useCheckboxContext` must be used within a `Checkbox` component");
  }
  return context;
}

/**
 * The element that visually represents a checkbox.
 */
const CheckboxControl = createPolymorphicComponent(props => {
  const context = useCheckboxContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

/**
 * The visual indicator rendered when the checkbox is in a checked or indeterminate state.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
const CheckboxIndicator = createPolymorphicComponent(props => {
  const context = useCheckboxContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(props, ["as", "forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isIndeterminate() || context.isChecked();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }
      }, () => context.dataset(), others));
    }
  });
});

const _tmpl$$8 = /*#__PURE__*/template(`<input type="checkbox">`, 1);
/**
 * The native html input that is visually hidden in the checkbox.
 */
function CheckboxInput(props) {
  let ref;
  const context = useCheckboxContext();
  props = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, others] = splitProps(props, ["ref", "style", "onChange", "aria-labelledby", ...PRESS_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const {
    pressHandlers
  } = createPress({
    isDisabled: context.isDisabled
  });
  const {
    focusRingHandlers
  } = createFocusRing({
    onFocusChange: value => context.setIsFocused(value),
    onFocusVisibleChange: value => context.setIsFocusVisible(value)
  });
  const ariaLabelledBy = () => {
    return [local["aria-labelledby"],
    // If there is both an aria-label and aria-labelledby, add the input itself has an aria-labelledby
    local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined].filter(Boolean).join(" ") || undefined;
  };
  const onChange = e => {
    callHandler(e, local.onChange);
    e.stopPropagation();
    const target = e.target;
    context.setIsChecked(target.checked);

    // Unlike in React, inputs `checked` state can be out of sync with our toggle state.
    // for example a readonly `<input type="checkbox" />` is always "checkable".
    //
    // Also, even if an input is controlled (ex: `<input type="checkbox" checked={isChecked} />`,
    // clicking on the input will change its internal `checked` state.
    //
    // To prevent this, we need to force the input `checked` state to be in sync with the toggle state.
    target.checked = context.isChecked();
  };

  // indeterminate is a property, but it can only be set via javascript
  // https://css-tricks.com/indeterminate-checkboxes/
  // Unlike in React, inputs `indeterminate` state can be out of sync with our.
  // Clicking on the input will change its internal `indeterminate` state.
  // To prevent this, we need to force the input `indeterminate` state to be in sync with our.
  createEffect(on([() => ref, () => context.isChecked()], ([ref]) => {
    if (ref) {
      ref.indeterminate = context.isIndeterminate() || false;
    }
  }));
  return (() => {
    const _el$ = _tmpl$$8.cloneNode(true);
    _el$.addEventListener("change", onChange);
    const _ref$ = mergeRefs(el => ref = el, local.ref);
    typeof _ref$ === "function" && use(_ref$, _el$);
    spread(_el$, mergeProps$1({
      get name() {
        return context.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.isChecked();
      },
      get required() {
        return context.isRequired();
      },
      get disabled() {
        return context.isDisabled();
      },
      get readonly() {
        return context.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-labelledby"]() {
        return ariaLabelledBy();
      },
      get ["aria-invalid"]() {
        return context.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return context.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return context.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return context.isReadOnly() || undefined;
      },
      get onKeyDown() {
        return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
      },
      get onKeyUp() {
        return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
      },
      get onClick() {
        return composeEventHandlers([local.onClick, pressHandlers.onClick]);
      },
      get onPointerDown() {
        return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown]);
      },
      get onPointerUp() {
        return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
      },
      get onMouseDown() {
        return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
      },
      get onDragStart() {
        return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
      },
      get onFocusIn() {
        return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
      },
      get onFocusOut() {
        return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
      }
    }, others), false, false);
    return _el$;
  })();
}

/**
 * The label that gives the user information on the checkbox.
 */
const CheckboxLabel = createPolymorphicComponent(props => {
  const context = useCheckboxContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

const _tmpl$$7 = /*#__PURE__*/template(`<label></label>`, 2);
/**
 * A control that allows the user to toggle between checked and not checked.
 */
const CheckboxRoot = props => {
  let ref;
  const defaultId = `checkbox-${createUniqueId()}`;
  props = mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["ref", "children", "value", "isChecked", "defaultIsChecked", "onCheckedChange", "name", "value", "validationState", "isRequired", "isDisabled", "isReadOnly", "isIndeterminate", ...PRESS_HANDLERS_PROP_NAMES, ...HOVER_HANDLERS_PROP_NAMES]);
  const [isFocused, setIsFocused] = createSignal(false);
  const [isFocusVisible, setIsFocusVisible] = createSignal(false);
  const state = createToggleState({
    isSelected: () => local.isChecked,
    defaultIsSelected: () => local.defaultIsChecked,
    onSelectedChange: selected => local.onCheckedChange?.(selected),
    isDisabled: () => local.isDisabled,
    isReadOnly: () => local.isReadOnly
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultIsChecked ?? false));
  const {
    isPressed,
    pressHandlers
  } = createPress({
    isDisabled: () => local.isDisabled,
    preventFocusOnPress: () => isFocused() // For consistency with native, prevent the input blurs.
  });

  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled: () => local.isDisabled
  });
  const dataset = createMemo(() => ({
    "data-valid": local.validationState === "valid" ? "" : undefined,
    "data-invalid": local.validationState === "invalid" ? "" : undefined,
    "data-checked": state.isSelected() ? "" : undefined,
    "data-indeterminate": local.isIndeterminate ? "" : undefined,
    "data-required": local.isRequired ? "" : undefined,
    "data-disabled": local.isDisabled ? "" : undefined,
    "data-readonly": local.isReadOnly ? "" : undefined,
    "data-hover": isHovered() ? "" : undefined,
    "data-focus": isFocused() ? "" : undefined,
    "data-focus-visible": isFocusVisible() ? "" : undefined,
    "data-active": isPressed() ? "" : undefined
  }));
  const context = {
    name: () => local.name ?? others.id,
    value: () => local.value,
    dataset,
    validationState: () => local.validationState,
    isChecked: () => state.isSelected(),
    isRequired: () => local.isRequired ?? false,
    isDisabled: () => local.isDisabled ?? false,
    isReadOnly: () => local.isReadOnly ?? false,
    isIndeterminate: () => local.isIndeterminate ?? false,
    generateId: part => `${others.id}-${part}`,
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setIsFocusVisible
  };
  return createComponent(CheckboxContext.Provider, {
    value: context,
    get children() {
      const _el$ = _tmpl$$7.cloneNode(true);
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && use(_ref$, _el$);
      spread(_el$, mergeProps$1({
        get onKeyDown() {
          return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
        },
        get onKeyUp() {
          return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
        },
        get onClick() {
          return composeEventHandlers([local.onClick, pressHandlers.onClick]);
        },
        get onPointerDown() {
          return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown]);
        },
        get onPointerUp() {
          return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
        },
        get onDragStart() {
          return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
        },
        get onPointerEnter() {
          return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
        },
        get onPointerLeave() {
          return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
        }
      }, dataset, others), false, true);
      insert(_el$, createComponent(CheckboxRootChild, {
        state: context,
        get children() {
          return local.children;
        }
      }));
      return _el$;
    }
  });
};
function CheckboxRootChild(props) {
  return children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
}

var index$h = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Control: CheckboxControl,
  Indicator: CheckboxIndicator,
  Input: CheckboxInput,
  Label: CheckboxLabel,
  Root: CheckboxRoot
});

const PopperContext = createContext();
function usePopperContext() {
  const context = useContext(PopperContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopperContext` must be used within a `Popper` component");
  }
  return context;
}

const _tmpl$$6 = /*#__PURE__*/template(`<svg display="block" viewBox="0 0 30 30"><g><path fill="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"></path><path stroke="none" d="M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z"></path></g></svg>`, 8);
const DEFAULT_SIZE = 30;
const HALF_DEFAULT_SIZE = DEFAULT_SIZE / 2;
const ROTATION_DEG = {
  top: 180,
  right: -90,
  bottom: 0,
  left: 90
};
/**
 * An optional arrow element to render alongside the popper content.
 * Must be rendered in the popper content.
 */
const PopperArrow = createPolymorphicComponent(props => {
  const context = usePopperContext();
  props = mergeDefaultProps({
    as: "div",
    size: DEFAULT_SIZE
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "style", "children", "size"]);
  const dir = () => context.currentPlacement().split("-")[0];
  const contentStyle = createComputedStyle(context.contentRef);
  const fill = () => contentStyle()?.getPropertyValue("background-color") || "none";
  const stroke = () => contentStyle()?.getPropertyValue(`border-${dir()}-color`) || "none";
  const borderWidth = () => contentStyle()?.getPropertyValue(`border-${dir()}-width`) || "0px";
  const strokeWidth = () => {
    return parseInt(borderWidth()) * 2 * (DEFAULT_SIZE / local.size);
  };
  const rotate = () => {
    return `rotate(${ROTATION_DEG[dir()]} ${HALF_DEFAULT_SIZE} ${HALF_DEFAULT_SIZE})`;
  };
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(context.setArrowRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-hidden": "true",
    get style() {
      return {
        // server side rendering
        position: "absolute",
        "font-size": `${local.size}px`,
        width: "1em",
        height: "1em",
        "pointer-events": "none",
        fill: fill(),
        stroke: stroke(),
        "stroke-width": strokeWidth(),
        ...local.style
      };
    }
  }, others, {
    get children() {
      const _el$ = _tmpl$$6.cloneNode(true),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.firstChild;
        _el$3.nextSibling;
      effect(() => setAttribute(_el$2, "transform", rotate()));
      return _el$;
    }
  }));
});
function createComputedStyle(element) {
  const [style, setStyle] = createSignal();
  createEffect(() => {
    const el = element();
    el && setStyle(getWindow(el).getComputedStyle(el));
  });
  return style;
}

/**
 * The wrapper component that positions the popper content relative to the popper anchor.
 */
const PopperPositioner = createPolymorphicComponent(props => {
  const context = usePopperContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "style"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(context.setPositionerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "data-popper-positioner": "",
    get style() {
      return {
        position: "absolute",
        top: 0,
        left: 0,
        "min-width": "max-content",
        ...local.style
      };
    }
  }, others));
});

function createDOMRect(anchorRect) {
  const {
    x = 0,
    y = 0,
    width = 0,
    height = 0
  } = anchorRect ?? {};
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }

  // JSDOM doesn't support DOMRect constructor.
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return {
    ...rect,
    toJSON: () => rect
  };
}
function getAnchorElement(anchor, getAnchorRect) {
  // https://floating-ui.com/docs/virtual-elements
  const contextElement = anchor;
  return {
    contextElement,
    getBoundingClientRect: () => {
      const anchorRect = getAnchorRect(anchor);
      if (anchorRect) {
        return createDOMRect(anchorRect);
      }
      if (anchor) {
        return anchor.getBoundingClientRect();
      }
      return createDOMRect();
    }
  };
}
function isValidPlacement(flip) {
  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(flip);
}
const REVERSE_BASE_PLACEMENT = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
function getTransformOrigin(placement, readingDirection) {
  const [basePlacement, alignment] = placement.split("-");
  const reversePlacement = REVERSE_BASE_PLACEMENT[basePlacement];
  if (!alignment) {
    return `${reversePlacement} center`;
  }
  if (basePlacement === "left" || basePlacement === "right") {
    return `${reversePlacement} ${alignment === "start" ? "top" : "bottom"}`;
  }
  if (alignment === "start") {
    return `${reversePlacement} ${readingDirection === "rtl" ? "right" : "left"}`;
  }
  return `${reversePlacement} ${readingDirection === "rtl" ? "left" : "right"}`;
}

/**
 * Display a floating content relative to an anchor element with an optional arrow.
 */
const PopperRoot = props => {
  props = mergeDefaultProps({
    getAnchorRect: anchor => anchor?.getBoundingClientRect(),
    placement: "bottom",
    gutter: 0,
    shift: 0,
    flip: true,
    slide: true,
    overlap: false,
    sameWidth: false,
    fitViewport: false,
    hideWhenDetached: false,
    detachedPadding: 0,
    arrowPadding: 4,
    overflowPadding: 8
  }, props);
  const [positionerRef, setPositionerRef] = createSignal();
  const [arrowRef, setArrowRef] = createSignal();
  const [currentPlacement, setCurrentPlacement] = createSignal(props.placement);

  // Floating UI - reference element.
  const anchorRef = () => getAnchorElement(props.anchorRef(), props.getAnchorRect);
  const {
    direction
  } = useLocale();
  async function updatePosition() {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    const arrowEl = arrowRef();
    if (!referenceEl || !floatingEl) {
      return;
    }
    const arrowOffset = (arrowEl?.clientHeight || 0) / 2;
    const finalGutter = typeof props.gutter === "number" ? props.gutter + arrowOffset : props.gutter ?? arrowOffset;
    floatingEl.style.setProperty("--kb-popper-content-overflow-padding", `${props.overflowPadding}px`);

    // Virtual element doesn't work without this ¯\_(ツ)_/¯
    referenceEl.getBoundingClientRect();
    const middleware = [
    // https://floating-ui.com/docs/offset
    offset(({
      placement
    }) => {
      // If there's no placement alignment (*-start or *-end), we'll
      // fall back to the crossAxis offset as it also works for
      // center-aligned placements.
      const hasAlignment = !!placement.split("-")[1];
      return {
        mainAxis: finalGutter,
        crossAxis: !hasAlignment ? props.shift : undefined,
        alignmentAxis: props.shift
      };
    })];
    if (props.flip !== false) {
      const fallbackPlacements = typeof props.flip === "string" ? props.flip.split(" ") : undefined;
      if (fallbackPlacements !== undefined && !fallbackPlacements.every(isValidPlacement)) {
        throw new Error("`flip` expects a spaced-delimited list of placements");
      }

      // https://floating-ui.com/docs/flip
      middleware.push(flip({
        padding: props.overflowPadding,
        fallbackPlacements: fallbackPlacements
      }));
    }
    if (props.slide || props.overlap) {
      // https://floating-ui.com/docs/shift
      middleware.push(shift({
        mainAxis: props.slide,
        crossAxis: props.overlap,
        padding: props.overflowPadding
      }));
    }

    // https://floating-ui.com/docs/size
    middleware.push(size({
      padding: props.overflowPadding,
      apply({
        availableWidth,
        availableHeight,
        rects
      }) {
        const referenceWidth = Math.round(rects.reference.width);
        availableWidth = Math.floor(availableWidth);
        availableHeight = Math.floor(availableHeight);
        floatingEl.style.setProperty("--kb-popper-anchor-width", `${referenceWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-width", `${availableWidth}px`);
        floatingEl.style.setProperty("--kb-popper-content-available-height", `${availableHeight}px`);
        if (props.sameWidth) {
          floatingEl.style.width = `${referenceWidth}px`;
        }
        if (props.fitViewport) {
          floatingEl.style.maxWidth = `${availableWidth}px`;
          floatingEl.style.maxHeight = `${availableHeight}px`;
        }
      }
    }));

    // https://floating-ui.com/docs/hide
    if (props.hideWhenDetached) {
      middleware.push(hide({
        padding: props.detachedPadding
      }));
    }

    // https://floating-ui.com/docs/arrow
    if (arrowEl) {
      middleware.push(arrow({
        element: arrowEl,
        padding: props.arrowPadding
      }));
    }

    // https://floating-ui.com/docs/computePosition
    const pos = await computePosition(referenceEl, floatingEl, {
      placement: props.placement,
      strategy: "absolute",
      middleware,
      platform: {
        ...platform,
        isRTL: () => direction() === "rtl"
      }
    });

    // Sync the new updated placement of floating-ui with our current placement and notify parent.
    setCurrentPlacement(pos.placement);
    props.onCurrentPlacementChange?.(pos.placement);
    if (!floatingEl) {
      return;
    }
    floatingEl.style.setProperty("--kb-popper-content-transform-origin", getTransformOrigin(pos.placement, direction()));
    const x = Math.round(pos.x);
    const y = Math.round(pos.y);
    let visibility;
    if (props.hideWhenDetached) {
      visibility = pos.middlewareData.hide?.referenceHidden ? "hidden" : "visible";
    }

    // https://floating-ui.com/docs/misc#subpixel-and-accelerated-positioning
    Object.assign(floatingEl.style, {
      top: "0",
      left: "0",
      transform: `translate3d(${x}px, ${y}px, 0)`,
      visibility
    });

    // https://floating-ui.com/docs/arrow#usage
    if (arrowEl && pos.middlewareData.arrow) {
      const {
        x: arrowX,
        y: arrowY
      } = pos.middlewareData.arrow;
      const dir = pos.placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: arrowX != null ? `${arrowX}px` : "",
        top: arrowY != null ? `${arrowY}px` : "",
        [dir]: "100%"
      });
    }
  }
  createEffect(() => {
    const referenceEl = anchorRef();
    const floatingEl = positionerRef();
    if (!referenceEl || !floatingEl) {
      return;
    }

    // https://floating-ui.com/docs/autoUpdate
    const cleanupAutoUpdate = autoUpdate(referenceEl, floatingEl, updatePosition, {
      // JSDOM doesn't support ResizeObserver
      elementResize: typeof ResizeObserver === "function"
    });
    onCleanup(cleanupAutoUpdate);
  });

  // Makes sure the positioner element has the same z-index as the popper content element,
  // so users only need to set the z-index once.
  createEffect(() => {
    const positioner = positionerRef();
    const content = props.contentRef();
    if (!positioner || !content) {
      return;
    }
    positioner.style.zIndex = getComputedStyle(content).zIndex;
  });
  const context = {
    currentPlacement,
    contentRef: () => props.contentRef(),
    setPositionerRef,
    setArrowRef
  };
  return createComponent(PopperContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
};

const MenuContext = createContext();
function useOptionalMenuContext() {
  return useContext(MenuContext);
}
function useMenuContext() {
  const context = useOptionalMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuContext` must be used within a `Menu` component");
  }
  return context;
}

const MenuRootContext = createContext();
function useMenuRootContext() {
  const context = useContext(MenuRootContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRootContext` must be used within a `MenuRoot` component");
  }
  return context;
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/menu/src/Menu.tsx
 */
/**
 * Construct a polygon based on pointer clientX/clientY and an element bounding rect.
 */
function getPointerGraceArea(placement, event, contentEl) {
  const basePlacement = placement.split("-")[0];
  const contentRect = contentEl.getBoundingClientRect();
  const polygon = [];
  const pointerX = event.clientX;
  const pointerY = event.clientY;
  switch (basePlacement) {
    case "top":
      polygon.push([pointerX, pointerY + 5]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      break;
    case "right":
      polygon.push([pointerX - 5, pointerY]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      break;
    case "bottom":
      polygon.push([pointerX, pointerY - 5]);
      polygon.push([contentRect.right, contentRect.top]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      break;
    case "left":
      polygon.push([pointerX + 5, pointerY]);
      polygon.push([contentRect.right, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.bottom]);
      polygon.push([contentRect.left, contentRect.top]);
      polygon.push([contentRect.right, contentRect.top]);
      break;
  }
  return polygon;
}
function isPointerInGraceArea(event, area) {
  if (!area) {
    return false;
  }
  return isPointInPolygon([event.clientX, event.clientY], area);
}

/**
 * Container for menu items and nested menu, provide context for its children.
 */
function Menu(props) {
  const rootContext = useMenuRootContext();
  const parentDomCollectionContext = useOptionalDomCollectionContext();
  const parentMenuContext = useOptionalMenuContext();
  props = mergeDefaultProps({
    placement: "bottom-start"
  }, props);
  const [local, others] = splitProps(props, ["isOpen", "defaultIsOpen", "onOpenChange"]);
  let pointerGraceTimeoutId = 0;
  let pointerGraceIntent = null;
  let pointerDir = "right";
  const [triggerId, setTriggerId] = createSignal();
  const [contentId, setContentId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [focusStrategy, setFocusStrategy] = createSignal(true);
  const [currentPlacement, setCurrentPlacement] = createSignal(others.placement);
  const [nestedMenus, setNestedMenus] = createSignal([]);
  const [items, setItems] = createSignal([]);
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const disclosureState = createDisclosureState({
    isOpen: () => local.isOpen,
    defaultIsOpen: () => local.defaultIsOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const listState = createListState({
    selectionMode: "none",
    dataSource: items
  });
  const open = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.open();
  };
  const close = () => {
    disclosureState.close();
  };
  const toggle = focusStrategy => {
    setFocusStrategy(focusStrategy);
    disclosureState.toggle();
  };
  const focusContent = () => {
    const content = contentRef();
    if (content) {
      focusSafely(content);
      listState.selectionManager().setFocused(true);
      listState.selectionManager().setFocusedKey(undefined);
    }
  };
  const registerNestedMenu = element => {
    setNestedMenus(prev => [...prev, element]);
    const parentUnregister = parentMenuContext?.registerNestedMenu(element);
    return () => {
      setNestedMenus(prev => removeItemFromArray(prev, element));
      parentUnregister?.();
    };
  };
  const isPointerMovingToSubmenu = e => {
    const isMovingTowards = pointerDir === pointerGraceIntent?.side;
    return isMovingTowards && isPointerInGraceArea(e, pointerGraceIntent?.area);
  };
  const onItemEnter = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };
  const onItemLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      return;
    }
    focusContent();
  };
  const onTriggerLeave = e => {
    if (isPointerMovingToSubmenu(e)) {
      e.preventDefault();
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => {
      // Apply only on root menu when opened and modal.
      return !(parentMenuContext == null && disclosureState.isOpen() && rootContext.isModal());
    },
    targets: () => [contentRef(), ...nestedMenus()].filter(Boolean)
  });
  createEffect(() => {
    const contentEl = contentRef();
    if (!contentEl || !parentMenuContext) {
      return;
    }
    const parentUnregister = parentMenuContext.registerNestedMenu(contentEl);
    onCleanup(() => {
      parentUnregister();
    });
  });
  const context = {
    isOpen: disclosureState.isOpen,
    shouldMount: () => rootContext.forceMount() || disclosureState.isOpen(),
    currentPlacement,
    pointerGraceTimeoutId: () => pointerGraceTimeoutId,
    autoFocus: focusStrategy,
    listState: () => listState,
    parentMenuContext: () => parentMenuContext,
    triggerRef,
    contentRef,
    triggerId,
    contentId,
    setTriggerRef,
    setContentRef,
    open,
    close,
    toggle,
    focusContent,
    onItemEnter,
    onItemLeave,
    onTriggerLeave,
    setPointerDir: dir => pointerDir = dir,
    setPointerGraceTimeoutId: id => pointerGraceTimeoutId = id,
    setPointerGraceIntent: intent => pointerGraceIntent = intent,
    registerNestedMenu,
    registerItemToParentDomCollection: parentDomCollectionContext?.registerItem,
    registerTriggerId: createRegisterId(setTriggerId),
    registerContentId: createRegisterId(setContentId)
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(MenuContext.Provider, {
        value: context,
        get children() {
          return createComponent(PopperRoot, mergeProps$1({
            anchorRef: triggerRef,
            contentRef: contentRef,
            onCurrentPlacementChange: setCurrentPlacement
          }, others));
        }
      });
    }
  });
}

const MenuItemContext = createContext();
function useMenuItemContext() {
  const context = useContext(MenuItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuItemContext` must be used within a `Menu.Item` component");
  }
  return context;
}

/**
 * Base component for a menu item.
 */
const MenuItemBase = createPolymorphicComponent(props => {
  let ref;
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  props = mergeDefaultProps({
    as: "div",
    id: rootContext.generateId(`item-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "textValue", "isDisabled", "closeOnSelect", "isChecked", "isIndeterminate", "onSelect", "onPressStart", "onPressUp", "onPress", "onPressChange", "onLongPress", "onFocus", "onMouseDown", "onDragStart", "onKeyDown", "onPointerMove", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const [labelId, setLabelId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [labelRef, setLabelRef] = createSignal();
  const [isPressed, setIsPressed] = createSignal();
  const selectionManager = () => menuContext.listState().selectionManager();
  const key = () => others.id;
  const isFocused = () => selectionManager().focusedKey() === key();
  const onSelect = () => {
    local.onSelect?.();
    if (local.closeOnSelect) {
      rootContext.close();
    }
  };
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      key: key(),
      label: "",
      // not applicable here
      textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
      isDisabled: local.isDisabled ?? false
    })
  });
  const selectableItem = createSelectableItem({
    key,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    isDisabled: () => local.isDisabled
  }, () => ref);
  const {
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  const {
    hoverHandlers,
    isHovered
  } = createHover({
    isDisabled: () => local.isDisabled
  });
  const onPressUp = e => {
    local.onPressUp?.(e);
    if (e.pointerType !== "keyboard") {
      onSelect();
    }
  };

  /**
   * We focus items on `pointerMove` to achieve the following:
   *
   * - Mouse over an item (it focuses)
   * - Leave mouse where it is and use keyboard to focus a different item
   * - Wiggle mouse without it leaving previously focused item
   * - Previously focused item should re-focus
   *
   * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse
   * wiggles. This is to match native menu implementation.
   */
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    if (local.isDisabled) {
      menuContext.onItemLeave(e);
    } else {
      menuContext.onItemEnter(e);
      if (!e.defaultPrevented) {
        focusSafely(e.currentTarget);
        menuContext.listState().selectionManager().setFocused(true);
        menuContext.listState().selectionManager().setFocusedKey(key());
      }
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    menuContext.onItemLeave(e);
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);

    // Ignore repeating events, which may have started on the menu trigger before moving
    // focus to the menu item. We want to wait for a second complete key press sequence.
    if (e.repeat) {
      return;
    }
    if (local.isDisabled) {
      return;
    }
    switch (e.key) {
      case "Enter":
      case " ":
        onSelect();
        break;
    }
  };
  const ariaChecked = createMemo(() => {
    if (local.isIndeterminate) {
      return "mixed";
    }
    if (local.isChecked == null) {
      return undefined;
    }
    return local.isChecked;
  });
  const dataset = createMemo(() => ({
    "data-indeterminate": local.isIndeterminate ? "" : undefined,
    "data-checked": local.isChecked && !local.isIndeterminate ? "" : undefined,
    "data-disabled": local.isDisabled ? "" : undefined,
    "data-hover": isHovered() ? "" : undefined,
    "data-focus": isFocused() ? "" : undefined,
    "data-focus-visible": isFocusVisible() ? "" : undefined,
    "data-active": isPressed() ? "" : undefined
  }));
  const context = {
    isChecked: () => local.isChecked,
    dataset,
    setLabelRef,
    generateId: createGenerateId(() => others.id),
    registerLabel: createRegisterId(setLabelId),
    registerDescription: createRegisterId(setDescriptionId)
  };
  return createComponent(MenuItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Pressable, mergeProps$1({
        get as() {
          return local.as;
        },
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get isDisabled() {
          return selectableItem.isDisabled();
        },
        get preventFocusOnPress() {
          return selectableItem.preventFocusOnPress();
        },
        get ["aria-checked"]() {
          return ariaChecked();
        },
        get ["aria-labelledby"]() {
          return labelId();
        },
        get ["aria-describedby"]() {
          return descriptionId();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onFocus() {
          return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        get onPressStart() {
          return composeEventHandlers([local.onPressStart, selectableItem.onPressStart]);
        },
        get onPressUp() {
          return composeEventHandlers([onPressUp, selectableItem.onPressUp]);
        },
        get onPress() {
          return composeEventHandlers([local.onPress, selectableItem.onPress]);
        },
        get onPressChange() {
          return composeEventHandlers([local.onPressChange, setIsPressed]);
        },
        get onLongPress() {
          return composeEventHandlers([local.onLongPress, selectableItem.onLongPress]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onDragStart() {
          return composeEventHandlers([local.onDragStart, selectableItem.onDragStart]);
        },
        onKeyDown: onKeyDown,
        onPointerMove: onPointerMove,
        get onPointerEnter() {
          return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
        },
        get onPointerLeave() {
          return composeEventHandlers([onPointerLeave, hoverHandlers.onPointerLeave]);
        },
        get onFocusIn() {
          return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
        },
        get onFocusOut() {
          return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
        }
      }, dataset, others));
    }
  });
});

/**
 * An item that can be controlled and rendered like a checkbox.
 */
const MenuCheckboxItem = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "div",
    closeOnSelect: false
  }, props);
  const [local, others] = splitProps(props, ["isChecked", "defaultIsChecked", "onCheckedChange", "onSelect"]);
  const state = createToggleState({
    isSelected: () => local.isChecked,
    defaultIsSelected: () => local.defaultIsChecked,
    onSelectedChange: checked => local.onCheckedChange?.(checked),
    isDisabled: () => others.isDisabled
  });
  const onSelect = () => {
    local.onSelect?.();
    state.toggle();
  };
  return createComponent(MenuItemBase, mergeProps$1({
    role: "menuitemcheckbox",
    get isChecked() {
      return state.isSelected();
    },
    onSelect: onSelect
  }, others));
});

const DismissableLayerContext = createContext();
function useOptionalDismissableLayerContext() {
  return useContext(DismissableLayerContext);
}

/*!
 * Portions of this file are based on code from radix-ui-primitives.
 * MIT Licensed, Copyright (c) 2022 WorkOS.
 *
 * Credits to the Radix UI team:
 * https://github.com/radix-ui/primitives/blob/81b25f4b40c54f72aeb106ca0e64e1e09655153e/packages/react/dismissable-layer/src/DismissableLayer.tsx
 *
 * Portions of this file are based on code from zag.
 * MIT Licensed, Copyright (c) 2021 Chakra UI.
 *
 * Credits to the Chakra UI team:
 * https://github.com/chakra-ui/zag/blob/d1dbf9e240803c9e3ed81ebef363739be4273de0/packages/utilities/dismissable/src/layer-stack.ts
 */
let originalBodyPointerEvents;
let hasDisabledBodyPointerEvents = false;
const layers = [];
function indexOf(node) {
  return layers.findIndex(layer => layer.node === node);
}
function find(node) {
  return layers[indexOf(node)];
}
function isTopMostLayer(node) {
  return layers[layers.length - 1].node === node;
}
function getPointerBlockingLayers() {
  return layers.filter(layer => layer.isPointerBlocking);
}
function getTopMostPointerBlockingLayer() {
  return [...getPointerBlockingLayers()].slice(-1)[0];
}
function hasPointerBlockingLayer() {
  return getPointerBlockingLayers().length > 0;
}
function isBelowPointerBlockingLayer(node) {
  const highestBlockingIndex = indexOf(getTopMostPointerBlockingLayer()?.node);
  return indexOf(node) < highestBlockingIndex;
}
function addLayer(layer) {
  layers.push(layer);
}
function removeLayer(node) {
  const index = indexOf(node);
  if (index < 0) {
    return;
  }
  layers.splice(index, 1);
}
function assignPointerEventToLayers() {
  layers.forEach(({
    node
  }) => {
    node.style.pointerEvents = isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}

/**
 * Disable body `pointer-events` if there are "pointer blocking" layers in the stack,
 * and body `pointer-events` has not been disabled yet.
 */
function disableBodyPointerEvents(node) {
  if (hasPointerBlockingLayer() && !hasDisabledBodyPointerEvents) {
    const ownerDocument = getDocument(node);
    originalBodyPointerEvents = document.body.style.pointerEvents;
    ownerDocument.body.style.pointerEvents = "none";
    hasDisabledBodyPointerEvents = true;
  }
}

/**
 * Restore body `pointer-events` style if there is no "pointer blocking" layer in the stack.
 */
function restoreBodyPointerEvents(node) {
  if (hasPointerBlockingLayer()) {
    return;
  }
  const ownerDocument = getDocument(node);
  ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
  if (ownerDocument.body.style.length === 0) {
    ownerDocument.body.removeAttribute("style");
  }
  hasDisabledBodyPointerEvents = false;
}
const layerStack = {
  layers,
  isTopMostLayer,
  hasPointerBlockingLayer,
  isBelowPointerBlockingLayer,
  addLayer,
  removeLayer,
  indexOf,
  find,
  assignPointerEventToLayers,
  disableBodyPointerEvents,
  restoreBodyPointerEvents
};

const DismissableLayer = createPolymorphicComponent(props => {
  let ref;
  const parentContext = useOptionalDismissableLayerContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "isDismissed", "disableOutsidePointerEvents", "excludedElements", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]);
  const nestedLayers = new Set([]);
  const registerNestedLayer = element => {
    nestedLayers.add(element);
    const parentUnregister = parentContext?.registerNestedLayer(element);
    return () => {
      nestedLayers.delete(element);
      parentUnregister?.();
    };
  };
  const shouldExcludeElement = element => {
    if (!ref) {
      return false;
    }
    return local.excludedElements?.some(node => contains(node(), element)) || [...nestedLayers].some(layer => contains(layer, element));
  };
  const onPointerDownOutside = e => {
    if (!ref || layerStack.isBelowPointerBlockingLayer(ref)) {
      return;
    }
    local.onPointerDownOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented) {
      local.onDismiss?.();
    }
  };
  createInteractOutside({
    isDisabled: () => local.isDismissed,
    shouldExcludeElement,
    onPointerDownOutside,
    onFocusOutside
  }, () => ref);
  createEscapeKeyDown({
    isDisabled: () => local.isDismissed,
    ownerDocument: () => getDocument(ref),
    onEscapeKeyDown: e => {
      if (!ref || !layerStack.isTopMostLayer(ref)) {
        return;
      }
      local.onEscapeKeyDown?.(e);
      if (!e.defaultPrevented && local.onDismiss) {
        e.preventDefault();
        local.onDismiss();
      }
    }
  });
  createEffect(on([() => ref, () => local.isDismissed], ([ref, isDismissed]) => {
    if (!ref || isDismissed) {
      return;
    }
    layerStack.addLayer({
      node: ref,
      isPointerBlocking: local.disableOutsidePointerEvents,
      dismiss: local.onDismiss
    });
    const unregisterFromParentLayer = parentContext?.registerNestedLayer(ref);
    layerStack.assignPointerEventToLayers();
    layerStack.disableBodyPointerEvents(ref);
    onCleanup(() => {
      if (!ref) {
        return;
      }
      layerStack.removeLayer(ref);
      unregisterFromParentLayer?.();

      // Re-assign pointer event to remaining layers.
      layerStack.assignPointerEventToLayers();
      layerStack.restoreBodyPointerEvents(ref);
    });
  }));
  createEffect(on([() => ref, () => local.isDismissed, () => local.disableOutsidePointerEvents], ([ref, isDismissed, disableOutsidePointerEvents]) => {
    if (!ref || isDismissed) {
      return;
    }
    const layer = layerStack.find(ref);
    if (layer && layer.isPointerBlocking !== disableOutsidePointerEvents) {
      // Keep layer in sync with the prop.
      layer.isPointerBlocking = disableOutsidePointerEvents;

      // Update layers pointer-events since this layer "isPointerBlocking" has changed.
      layerStack.assignPointerEventToLayers();
    }
    if (disableOutsidePointerEvents) {
      layerStack.disableBodyPointerEvents(ref);
    }
    onCleanup(() => {
      layerStack.restoreBodyPointerEvents(ref);
    });
  }, {
    defer: true
  }));
  const context = {
    registerNestedLayer
  };
  return createComponent(DismissableLayerContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        }
      }, others));
    }
  });
});

const MenuContentBase = createPolymorphicComponent(props => {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  props = mergeDefaultProps({
    as: "div",
    id: rootContext.generateId(`content-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(props, ["ref", "id", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onEscapeKeyDown", "onFocusOutside", "onKeyDown", "onMouseDown", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  let lastPointerX = 0;

  // Only the root menu can apply "modal" behavior (block pointer-events and trap focus).
  const isRootModalContent = () => {
    return context.parentMenuContext() == null && rootContext.isModal();
  };
  const selectableList = createSelectableList({
    selectionManager: context.listState().selectionManager,
    collection: context.listState().collection,
    autoFocus: context.autoFocus,
    deferAutoFocus: true,
    // ensure all menu items are mounted and collection is not empty before trying to autofocus.
    shouldFocusWrap: true,
    disallowTypeAhead: () => !context.listState().selectionManager().isFocused()
  }, () => ref);
  const {
    isFocused,
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  createFocusScope({
    trapFocus: () => isRootModalContent() && context.isOpen(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: local.onCloseAutoFocus
  }, () => ref);
  const {
    hoverHandlers
  } = createHover({
    isDisabled: () => !context.isOpen(),
    onHoverStart: () => {
      // Remove visual focus from parent menu content.
      context.parentMenuContext()?.listState().selectionManager().setFocused(false);
      context.parentMenuContext()?.listState().selectionManager().setFocusedKey(undefined);
    }
  });
  const onKeyDown = e => {
    // Submenu key events bubble through portals. We only care about keys in this menu.
    if (!contains(e.currentTarget, e.target)) {
      return;
    }

    // Menus should not be navigated using tab key, so we prevent it.
    if (e.key === "Tab" && context.isOpen()) {
      e.preventDefault();
    }
  };
  const onEscapeKeyDown = e => {
    local.onEscapeKeyDown?.(e);

    // `createSelectableList` prevent escape key down,
    // which prevent our `onDismiss` in `DismissableLayer` to run,
    // so we force "close on escape" here.
    rootContext.close();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    if (rootContext.isModal()) {
      // When focus is trapped, a `focusout` event may still happen.
      // We make sure we don't trigger our `onDismiss` in such case.
      e.preventDefault();
    }
  };
  const onPointerMove = e => {
    if (e.pointerType !== "mouse") {
      return;
    }
    const target = e.target;
    const pointerXHasChanged = lastPointerX !== e.clientX;

    // We don't use `event.movementX` for this check because Safari will
    // always return `0` on a pointer event.
    if (contains(e.currentTarget, target) && pointerXHasChanged) {
      context.setPointerDir(e.clientX > lastPointerX ? "right" : "left");
      lastPointerX = e.clientX;
    }
  };
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "menu",
            get id() {
              return local.id;
            },
            get tabIndex() {
              return selectableList.tabIndex();
            },
            get isDismissed() {
              return !context.isOpen();
            },
            get disableOutsidePointerEvents() {
              return memo(() => !!isRootModalContent())() && context.isOpen();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.triggerId();
            },
            get ["data-focus"]() {
              return isFocused() ? "" : undefined;
            },
            get ["data-focus-visible"]() {
              return isFocusVisible() ? "" : undefined;
            },
            onEscapeKeyDown: onEscapeKeyDown,
            onFocusOutside: onFocusOutside,
            get onDismiss() {
              return context.close;
            },
            get onKeyDown() {
              return composeEventHandlers([local.onKeyDown, selectableList.handlers.onKeyDown, onKeyDown]);
            },
            get onMouseDown() {
              return composeEventHandlers([local.onMouseDown, selectableList.handlers.onMouseDown]);
            },
            get onPointerEnter() {
              return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
            },
            get onPointerLeave() {
              return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
            },
            onPointerMove: onPointerMove,
            get onFocusIn() {
              return composeEventHandlers([local.onFocusIn, selectableList.handlers.onFocusIn, focusRingHandlers.onFocusIn]);
            },
            get onFocusOut() {
              return composeEventHandlers([local.onFocusOut, selectableList.handlers.onFocusOut, focusRingHandlers.onFocusOut]);
            }
          }, others));
        }
      });
    }
  });
});

const MenuContent = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  createPreventScroll({
    isDisabled: () => !(context.isOpen() && rootContext.isModal())
  });
  return createComponent(MenuContentBase, props);
});

const MenuGroupContext = createContext();
function useMenuGroupContext() {
  const context = useContext(MenuGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuGroupContext` must be used within a `Menu.Group` component");
  }
  return context;
}

/**
 * A container used to group multiple `Menu.Item`s.
 */
const MenuGroup = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  props = mergeDefaultProps({
    as: "div",
    id: rootContext.generateId(`group-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  const [labelId, setLabelId] = createSignal();
  const context = {
    generateId: createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return createComponent(MenuGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        role: "group",
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, others));
    }
  });
});

/**
 * A component used to render the label of a `Menu.Group`.
 * It won't be focusable using arrow keys.
 */
const MenuGroupLabel = createPolymorphicComponent(props => {
  const context = useMenuGroupContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    },
    "aria-hidden": "true"
  }, others));
});

/**
 * A small icon often displayed inside the menu trigger as a visual affordance for the fact it can be open.
 * It renders a `▼` by default, but you can use your own icon by providing a `children`.
 */
const MenuIcon = createPolymorphicComponent(props => {
  const context = useMenuContext();
  props = mergeDefaultProps({
    as: "div",
    children: "▼"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    "aria-hidden": "true",
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    }
  }, others));
});

/**
 * An item of the menu.
 */
const MenuItem = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "div",
    closeOnSelect: true
  }, props);
  return createComponent(MenuItemBase, mergeProps$1({
    role: "menuitem"
  }, props));
});

/**
 * An optional accessible description to be announced for the menu item.
 * Useful for menu items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
const MenuItemDescription = createPolymorphicComponent(props => {
  const context = useMenuItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerDescription(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
});

/**
 * The visual indicator rendered when the parent menu `CheckboxItem` or `RadioItem` is checked.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
const MenuItemIndicator = createPolymorphicComponent(props => {
  const context = useMenuItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(props, ["as", "forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isChecked();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }
      }, () => context.dataset(), others));
    }
  });
});

/**
 * An accessible label to be announced for the menu item.
 * Useful for menu items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
const MenuItemLabel = createPolymorphicComponent(props => {
  const context = useMenuItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "id"]);
  createEffect(() => onCleanup(context.registerLabel(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(context.setLabelRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
});

/**
 * Portals its children into the `body` when the menu is open.
 */
function MenuPortal(props) {
  const context = useMenuContext();
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

const MenuRadioGroupContext = createContext();
function useMenuRadioGroupContext() {
  const context = useContext(MenuRadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useMenuRadioGroupContext` must be used within a `Menu.RadioGroup` component");
  }
  return context;
}

/**
 * A container used to group multiple `Menu.RadioItem`s and manage the selection.
 */
const MenuRadioGroup = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  const defaultId = rootContext.generateId(`radiogroup-${createUniqueId()}`);
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["value", "defaultValue", "onValueChange", "isDisabled"]);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onValueChange?.(value)
  });
  const context = {
    isDisabled: () => local.isDisabled,
    isSelectedValue: value => value === selected(),
    setSelectedValue: setSelected
  };
  return createComponent(MenuRadioGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(MenuGroup, others);
    }
  });
});

/**
 * An item that can be controlled and rendered like a radio.
 */
const MenuRadioItem = createPolymorphicComponent(props => {
  const context = useMenuRadioGroupContext();
  props = mergeDefaultProps({
    as: "div",
    closeOnSelect: false
  }, props);
  const [local, others] = splitProps(props, ["value", "onSelect"]);
  const onSelect = () => {
    local.onSelect?.();
    context.setSelectedValue(local.value);
  };
  return createComponent(MenuItemBase, mergeProps$1({
    role: "menuitemradio",
    get isChecked() {
      return context.isSelectedValue(local.value);
    },
    onSelect: onSelect
  }, others));
});

/**
 * Root component for a menu, provide context for its children.
 * Used to build dropdown menu, context menu and menubar.
 */
function MenuRoot(props) {
  const defaultId = `menu-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId,
    isModal: true
  }, props);
  const [local, others] = splitProps(props, ["id", "isModal", "forceMount", "isOpen", "defaultIsOpen", "onOpenChange"]);
  const disclosureState = createDisclosureState({
    isOpen: () => local.isOpen,
    defaultIsOpen: () => local.defaultIsOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    isModal: () => local.isModal ?? true,
    forceMount: () => local.forceMount ?? false,
    close: disclosureState.close,
    generateId: createGenerateId(() => local.id)
  };
  return createComponent(MenuRootContext.Provider, {
    value: context,
    get children() {
      return createComponent(Menu, mergeProps$1({
        get isOpen() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        }
      }, others));
    }
  });
}

/**
 * Contains all the parts of a submenu.
 */
function MenuSub(props) {
  const {
    direction
  } = useLocale();
  return createComponent(Menu, mergeProps$1({
    get placement() {
      return direction() === "rtl" ? "left-start" : "right-start";
    },
    flip: true
  }, props));
}

const SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};

/**
 * The component that pops out when a submenu is open.
 */
const MenuSubContent = createPolymorphicComponent(props => {
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["onFocusOutside", "onKeyDown", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const onOpenAutoFocus = e => {
    // when opening a submenu, focus content for keyboard users only (handled by `MenuSubTrigger`).
    e.preventDefault();
  };
  const onCloseAutoFocus = e => {
    // The menu might close because of focusing another menu item in the parent menu.
    // We don't want it to refocus the trigger in that case, so we handle trigger focus ourselves.
    e.preventDefault();
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);
    const target = e.target;

    // We prevent closing when the trigger is focused to avoid triggering a re-open animation
    // on pointer interaction.
    if (!contains(context.triggerRef(), target)) {
      context.close();
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);

    // Submenu key events bubble through portals. We only care about keys in this menu.
    const isKeyDownInside = contains(e.currentTarget, e.target);
    const isCloseKey = SUB_CLOSE_KEYS[direction()].includes(e.key);
    const isSubMenu = context.parentMenuContext() != null;
    if (isKeyDownInside && isCloseKey && isSubMenu) {
      context.close();

      // We focus manually because we prevented it in `onCloseAutoFocus`.
      focusWithoutScrolling(context.triggerRef());
    }
  };
  return createComponent(MenuContentBase, mergeProps$1({
    onOpenAutoFocus: onOpenAutoFocus,
    onCloseAutoFocus: onCloseAutoFocus,
    onFocusOutside: onFocusOutside,
    onKeyDown: onKeyDown
  }, others));
});

const SELECTION_KEYS = ["Enter", " "];
const SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS, "ArrowRight"],
  rtl: [...SELECTION_KEYS, "ArrowLeft"]
};

/**
 * An item that opens a submenu.
 */
const MenuSubTrigger = createPolymorphicComponent(props => {
  let ref;
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  props = mergeDefaultProps({
    as: "div",
    id: rootContext.generateId(`sub-trigger-${createUniqueId()}`)
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "id", "textValue", "isDisabled", "onPressStart", "onPressUp", "onPress", "onLongPress", "onFocus", "onMouseDown", "onDragStart", "onKeyDown", "onPointerMove", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  let openTimeoutId = null;
  const clearOpenTimeout = () => {
    if (isServer) {
      return;
    }
    if (openTimeoutId) {
      window.clearTimeout(openTimeoutId);
    }
    openTimeoutId = null;
  };
  const {
    direction
  } = useLocale();
  const key = () => local.id;
  const parentSelectionManager = () => {
    const parentMenuContext = context.parentMenuContext();
    if (parentMenuContext == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }
    return parentMenuContext.listState().selectionManager();
  };
  const collection = () => context.listState().collection();
  const isFocused = () => parentSelectionManager().focusedKey() === key();
  const selectableItem = createSelectableItem({
    key,
    selectionManager: parentSelectionManager,
    shouldSelectOnPressUp: true,
    allowsDifferentPressOrigin: true,
    isDisabled: () => local.isDisabled
  }, () => ref);
  const {
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  const {
    hoverHandlers,
    isHovered
  } = createHover({
    isDisabled: () => local.isDisabled
  });
  const onPress = e => {
    local.onPress?.(e);
    if (e.pointerType === "touch" && !context.isOpen() && !local.isDisabled) {
      context.open(true);
    }
  };
  const onPointerMove = e => {
    callHandler(e, local.onPointerMove);
    if (e.pointerType !== "mouse") {
      return;
    }
    const parentMenuContext = context.parentMenuContext();
    parentMenuContext?.onItemEnter(e);
    if (e.defaultPrevented) {
      return;
    }
    if (local.isDisabled) {
      parentMenuContext?.onItemLeave(e);
      return;
    }
    if (!context.isOpen() && !openTimeoutId) {
      context.parentMenuContext()?.setPointerGraceIntent(null);
      openTimeoutId = window.setTimeout(() => {
        context.open(false);
        clearOpenTimeout();
      }, 100);
    }
    parentMenuContext?.onItemEnter(e);
    if (!e.defaultPrevented) {
      // Remove visual focus from sub menu content.
      if (context.listState().selectionManager().isFocused()) {
        context.listState().selectionManager().setFocused(false);
        context.listState().selectionManager().setFocusedKey(undefined);
      }

      // Restore visual focus to parent menu content.
      focusSafely(e.currentTarget);
      parentMenuContext?.listState().selectionManager().setFocused(true);
      parentMenuContext?.listState().selectionManager().setFocusedKey(key());
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType !== "mouse") {
      return;
    }
    clearOpenTimeout();
    const parentMenuContext = context.parentMenuContext();
    const contentEl = context.contentRef();
    if (contentEl) {
      parentMenuContext?.setPointerGraceIntent({
        area: getPointerGraceArea(context.currentPlacement(), e, contentEl),
        // Safe because sub menu always open "left" or "right".
        side: context.currentPlacement().split("-")[0]
      });
      window.clearTimeout(parentMenuContext?.pointerGraceTimeoutId());
      const pointerGraceTimeoutId = window.setTimeout(() => {
        parentMenuContext?.setPointerGraceIntent(null);
      }, 300);
      parentMenuContext?.setPointerGraceTimeoutId(pointerGraceTimeoutId);
    } else {
      parentMenuContext?.onTriggerLeave(e);
      if (e.defaultPrevented) {
        return;
      }

      // There's 100ms where the user may leave an item before the submenu was opened.
      parentMenuContext?.setPointerGraceIntent(null);
    }
    parentMenuContext?.onItemLeave(e);
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);

    // Ignore repeating events, which may have started on the menu trigger before moving
    // focus to the menu item. We want to wait for a second complete key press sequence.
    if (e.repeat) {
      return;
    }
    if (local.isDisabled) {
      return;
    }

    // For consistency with native, open the menu on key down.
    if (SUB_OPEN_KEYS[direction()].includes(e.key)) {
      e.stopPropagation();
      e.preventDefault();

      // Clear focus on parent menu (e.g. the menu containing the trigger).
      parentSelectionManager().setFocused(false);
      parentSelectionManager().setFocusedKey(undefined);

      // We focus manually because we prevented it in MenuSubContent's `onOpenAutoFocus`.
      if (context.isOpen()) {
        context.focusContent();
        context.listState().selectionManager().setFocused(true);
        context.listState().selectionManager().setFocusedKey(collection().getFirstKey());
      } else {
        context.open("first");
      }
    }
  };
  createEffect(() => {
    // Not able to register the trigger as a menu item on parent menu means
    // `Menu.SubTrigger` is not used in the correct place, so throw an error.
    if (context.registerItemToParentDomCollection == null) {
      throw new Error("[kobalte]: `Menu.SubTrigger` must be used within a `Menu.Sub` component");
    }

    // Register the item trigger on the parent menu that contains it.
    const unregister = context.registerItemToParentDomCollection({
      ref: () => ref,
      key: key(),
      label: "",
      // not applicable here
      textValue: local.textValue ?? ref?.textContent ?? "",
      isDisabled: local.isDisabled ?? false
    });
    onCleanup(unregister);
  });
  createEffect(on(() => context.parentMenuContext()?.pointerGraceTimeoutId(), pointerGraceTimer => {
    onCleanup(() => {
      window.clearTimeout(pointerGraceTimer);
      context.parentMenuContext()?.setPointerGraceIntent(null);
    });
  }));
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  onCleanup(() => {
    clearOpenTimeout();
  });
  return createComponent(Pressable, mergeProps$1({
    get as() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => {
        context.setTriggerRef(el);
        ref = el;
      }, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    role: "menuitem",
    get tabIndex() {
      return selectableItem.tabIndex();
    },
    get isDisabled() {
      return selectableItem.isDisabled();
    },
    get preventFocusOnPress() {
      return selectableItem.preventFocusOnPress();
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    get ["data-hover"]() {
      return isHovered() ? "" : undefined;
    },
    get ["data-focus"]() {
      return isFocused() ? "" : undefined;
    },
    get ["data-focus-visible"]() {
      return isFocusVisible() ? "" : undefined;
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    get onPressStart() {
      return composeEventHandlers([local.onPressStart, selectableItem.onPressStart]);
    },
    get onPressUp() {
      return composeEventHandlers([local.onPressUp, selectableItem.onPressUp]);
    },
    get onPress() {
      return composeEventHandlers([onPress, selectableItem.onPress]);
    },
    get onLongPress() {
      return composeEventHandlers([local.onLongPress, selectableItem.onLongPress]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onDragStart() {
      return composeEventHandlers([local.onDragStart, selectableItem.onDragStart]);
    },
    onKeyDown: onKeyDown,
    onPointerMove: onPointerMove,
    get onPointerEnter() {
      return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
    },
    get onPointerLeave() {
      return composeEventHandlers([onPointerLeave, hoverHandlers.onPointerLeave]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
    }
  }, others));
});

/**
 * The button that toggles the menu.
 */
const MenuTrigger = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  props = mergeDefaultProps({
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = splitProps(props, ["ref", "id", "isDisabled", "onPressStart", "onPress", "onKeyDown"]);
  const onPressStart = e => {
    local.onPressStart?.(e);

    // For consistency with native, open the menu on mouse down, but touch up.
    if (e.pointerType !== "touch" && e.pointerType !== "keyboard" && !local.isDisabled) {
      // If opened with a screen reader, autofocus the first item.
      // Otherwise, the menu itself will be focused.
      context.toggle(e.pointerType === "virtual" ? "first" : true);
    }
  };
  const onPress = e => {
    local.onPress?.(e);
    if (e.pointerType === "touch" && !local.isDisabled) {
      context.toggle(true);
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (local.isDisabled) {
      return;
    }

    // For consistency with native, open the menu on key down.
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
    }
  };
  createEffect(() => onCleanup(context.registerTriggerId(local.id)));
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get isDisabled() {
      return local.isDisabled;
    },
    "aria-haspopup": "true",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    onPressStart: onPressStart,
    onPress: onPress,
    onKeyDown: onKeyDown
  }, others));
});

/**
 * A separator visually or semantically separates content.
 */
const SeparatorRoot = createPolymorphicComponent(props => {
  let ref;
  props = mergeDefaultProps({
    as: "hr",
    orientation: "horizontal"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "orientation"]);
  const tagName = createTagName(() => ref, () => local.as || "hr");
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get role() {
      return tagName() !== "hr" ? "separator" : undefined;
    },
    get ["aria-orientation"]() {
      return local.orientation === "vertical" ? "vertical" : undefined;
    },
    get ["data-orientation"]() {
      return local.orientation;
    }
  }, others));
});

var index$g = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: SeparatorRoot
});

const ContextMenuContent = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  const [local, others] = splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!e.defaultPrevented && hasInteractedOutside) {
      e.preventDefault();
    }
    hasInteractedOutside = false;
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!e.defaultPrevented && !rootContext.isModal()) {
      hasInteractedOutside = true;
    }
  };
  return createComponent(MenuContent, mergeProps$1({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
});

const ContextMenuContext = createContext();
function useOptionalContextMenuContext() {
  return useContext(ContextMenuContext);
}
function useContextMenuContext() {
  const context = useOptionalContextMenuContext();
  if (context === undefined) {
    throw new Error("[kobalte]: `useContextMenuContext` must be used within a `ContextMenu` component");
  }
  return context;
}

/**
 * Displays a menu located at the pointer, triggered by a right-click or a long-press.
 */
const ContextMenuRoot = props => {
  const defaultId = `contextmenu-${createUniqueId()}`;
  const {
    direction
  } = useLocale();
  props = mergeDefaultProps({
    id: defaultId,
    placement: direction() === "rtl" ? "left-start" : "right-start",
    gutter: 2,
    shift: 2
  }, props);
  const [local, others] = splitProps(props, ["onOpenChange"]);
  const [anchorRect, setAnchorRect] = createSignal({
    x: 0,
    y: 0
  });
  const disclosureState = createDisclosureState({
    defaultIsOpen: false,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const context = {
    setAnchorRect
  };
  return createComponent(ContextMenuContext.Provider, {
    value: context,
    get children() {
      return createComponent(MenuRoot, mergeProps$1({
        get isOpen() {
          return disclosureState.isOpen();
        },
        get onOpenChange() {
          return disclosureState.setIsOpen;
        },
        getAnchorRect: anchorRect
      }, others));
    }
  });
};

const ContextMenuTrigger = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  const menuContext = useMenuContext();
  const context = useContextMenuContext();
  props = mergeDefaultProps({
    as: "div",
    id: rootContext.generateId("trigger")
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "style", "isDisabled", "onContextMenu", ...PRESS_HANDLERS_PROP_NAMES]);
  const onContextMenu = e => {
    // If trigger is disabled, enable the native Context Menu.
    if (local.isDisabled) {
      callHandler(e, local.onContextMenu);
      return;
    }
    e.preventDefault();
    context.setAnchorRect({
      x: e.clientX,
      y: e.clientY
    });
    if (menuContext.isOpen()) {
      // If the menu is already open, focus the menu itself.
      menuContext.focusContent();
    } else {
      menuContext.open(true);
    }
  };
  const {
    longPressHandlers
  } = createLongPress({
    isDisabled: () => local.isDisabled,
    threshold: 700,
    onLongPress: e => {
      if (e.pointerType === "touch" || e.pointerType === "pen") {
        menuContext.open(false);
      }
    }
  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(menuContext.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get style() {
      return {
        // prevent iOS context menu from appearing
        "-webkit-touch-callout": "none",
        ...local.style
      };
    },
    get ["data-expanded"]() {
      return menuContext.isOpen() ? "" : undefined;
    },
    get ["data-disabled"]() {
      return local.isDisabled ? "" : undefined;
    },
    onContextMenu: onContextMenu,
    get onKeyDown() {
      return composeEventHandlers([local.onKeyDown, longPressHandlers.onKeyDown]);
    },
    get onKeyUp() {
      return composeEventHandlers([local.onKeyUp, longPressHandlers.onKeyUp]);
    },
    get onClick() {
      return composeEventHandlers([local.onClick, longPressHandlers.onClick]);
    },
    get onPointerDown() {
      return composeEventHandlers([local.onPointerDown, longPressHandlers.onPointerDown]);
    },
    get onPointerUp() {
      return composeEventHandlers([local.onPointerUp, longPressHandlers.onPointerUp]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, longPressHandlers.onMouseDown]);
    },
    get onDragStart() {
      return composeEventHandlers([local.onDragStart, longPressHandlers.onDragStart]);
    }
  }, others));
});

var index$f = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: ContextMenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Root: ContextMenuRoot,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: ContextMenuTrigger
});

const DialogContext = createContext();
function useDialogContext() {
  const context = useContext(DialogContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useDialogContext` must be used within a `Dialog` component");
  }
  return context;
}

/**
 * The button that closes the dialog.
 */
const DialogCloseButton = createPolymorphicComponent(props => {
  const context = useDialogContext();
  const [local, others] = splitProps(props, ["onPress", "aria-label"]);
  const stringFormatter = createLocalizedStringFormatter(() => COMMON_INTL_MESSAGES);
  const onPress = e => {
    local.onPress?.(e);
    context.close();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-label"]() {
      return local["aria-label"] || stringFormatter().format("dismiss");
    },
    onPress: onPress
  }, others));
});

/**
 * Contains the content to be rendered when the dialog is open.
 */
const DialogContent = createPolymorphicComponent(props => {
  let ref;
  const context = useDialogContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(props, ["ref", "id", "onOpenAutoFocus", "onCloseAutoFocus", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);

    // If the event is a right-click, we shouldn't close because
    // it is effectively as if we right-clicked the `Overlay`.
    if (context.isModal() && e.detail.isContextMenu) {
      e.preventDefault();
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);

    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    if (context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!context.isModal() && !e.defaultPrevented) {
      hasInteractedOutside = true;
    }
  };
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      focusWithoutScrolling(context.triggerRef());
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          focusWithoutScrolling(context.triggerRef());
        }

        // Always prevent autofocus because we either focus manually or want user agent focus
        e.preventDefault();
      }
      hasInteractedOutside = false;
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    isDisabled: () => !(context.isOpen() && context.isModal())
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(DismissableLayer, mergeProps$1({
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "dialog",
        get id() {
          return local.id;
        },
        tabIndex: -1,
        get isDismissed() {
          return !context.isOpen();
        },
        get disableOutsidePointerEvents() {
          return memo(() => !!context.isOpen())() && context.isModal();
        },
        get excludedElements() {
          return [context.triggerRef];
        },
        get ["aria-labelledby"]() {
          return context.titleId();
        },
        get ["aria-describedby"]() {
          return context.descriptionId();
        },
        get onEscapeKeyDown() {
          return local.onEscapeKeyDown;
        },
        onPointerDownOutside: onPointerDownOutside,
        onFocusOutside: onFocusOutside,
        onInteractOutside: onInteractOutside,
        get onDismiss() {
          return context.close;
        }
      }, others));
    }
  });
});

/**
 * An optional accessible description to be announced when the dialog is open.
 */
const DialogDescription = createPolymorphicComponent(props => {
  const context = useDialogContext();
  props = mergeDefaultProps({
    as: "p",
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, others));
});

/**
 * A layer that covers the inert portion of the view when the dialog is open.
 */
const DialogOverlay = createPolymorphicComponent(props => {
  const context = useDialogContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "style", "onPointerDown"]);
  const onPointerDown = e => {
    callHandler(e, local.onPointerDown);

    // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846
    if (e.target === e.currentTarget) {
      e.preventDefault();
    }
  };
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        get style() {
          return {
            "pointer-events": "auto",
            ...local.style
          };
        },
        onPointerDown: onPointerDown
      }, others));
    }
  });
});

/**
 * Portals its children into the `body` when the dialog is open.
 */
function DialogPortal(props) {
  const context = useDialogContext();
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

/**
 * A dialog is a window overlaid on either the primary window or another dialog window.
 */
const DialogRoot = props => {
  const defaultId = `dialog-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId,
    isModal: true
  }, props);
  const [contentId, setContentId] = createSignal();
  const [titleId, setTitleId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const disclosureState = createDisclosureState({
    isOpen: () => props.isOpen,
    defaultIsOpen: () => props.defaultIsOpen,
    onOpenChange: isOpen => props.onOpenChange?.(isOpen)
  });
  const context = {
    isOpen: disclosureState.isOpen,
    isModal: () => props.isModal,
    shouldMount: () => props.forceMount || disclosureState.isOpen(),
    contentId,
    titleId,
    descriptionId,
    triggerRef,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    setTriggerRef,
    generateId: createGenerateId(() => props.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(DialogContext.Provider, {
    value: context,
    get children() {
      return props.children;
    }
  });
};

/**
 * An accessible title to be announced when the dialog is open.
 */
const DialogTitle = createPolymorphicComponent(props => {
  const context = useDialogContext();
  props = mergeDefaultProps({
    as: "h2",
    id: context.generateId("title")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerTitleId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, others));
});

/**
 * The button that opens the dialog.
 */
const DialogTrigger = createPolymorphicComponent(props => {
  const context = useDialogContext();
  const [local, others] = splitProps(props, ["ref", "onPress"]);
  const onPress = e => {
    local.onPress?.(e);
    context.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    onPress: onPress
  }, others));
});

var index$e = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CloseButton: DialogCloseButton,
  Content: DialogContent,
  Description: DialogDescription,
  Overlay: DialogOverlay,
  Portal: DialogPortal,
  Root: DialogRoot,
  Title: DialogTitle,
  Trigger: DialogTrigger
});

/**
 * Contains the content to be rendered when the dropdown menu is open.
 */
const DropdownMenuContent = createPolymorphicComponent(props => {
  const rootContext = useMenuRootContext();
  const context = useMenuContext();
  const [local, others] = splitProps(props, ["onCloseAutoFocus", "onInteractOutside"]);
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (!hasInteractedOutside) {
      focusWithoutScrolling(context.triggerRef());
    }
    hasInteractedOutside = false;

    // Always prevent autofocus because we either focus manually or want user agent focus
    e.preventDefault();
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!rootContext.isModal() || e.detail.isContextMenu) {
      hasInteractedOutside = true;
    }
  };
  return createComponent(MenuContent, mergeProps$1({
    onCloseAutoFocus: onCloseAutoFocus,
    onInteractOutside: onInteractOutside
  }, others));
});

/**
 * Displays a menu to the user —such as a set of actions or functions— triggered by a button.
 */
const DropdownMenuRoot = props => {
  const defaultId = `dropdownmenu-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId
  }, props);
  return createComponent(MenuRoot, props);
};

var index$d = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  CheckboxItem: MenuCheckboxItem,
  Content: DropdownMenuContent,
  Group: MenuGroup,
  GroupLabel: MenuGroupLabel,
  Icon: MenuIcon,
  Item: MenuItem,
  ItemDescription: MenuItemDescription,
  ItemIndicator: MenuItemIndicator,
  ItemLabel: MenuItemLabel,
  Portal: MenuPortal,
  RadioGroup: MenuRadioGroup,
  RadioItem: MenuRadioItem,
  Root: DropdownMenuRoot,
  Separator: SeparatorRoot,
  Sub: MenuSub,
  SubContent: MenuSubContent,
  SubTrigger: MenuSubTrigger,
  Trigger: MenuTrigger
});

const HoverCardContext = createContext();
function useHoverCardContext() {
  const context = useContext(HoverCardContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useHoverCardContext` must be used within a `HoverCard` component");
  }
  return context;
}

/**
 * Contains the content to be rendered when the hovercard is open.
 */
const HoverCardContent = createPolymorphicComponent(props => {
  const context = useHoverCardContext();
  const [local, others] = splitProps(props, ["ref", "style"]);
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(context.setContentRef, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get isDismissed() {
              return !context.isOpen();
            },
            disableOutsidePointerEvents: false,
            get style() {
              return {
                position: "relative",
                ...local.style
              };
            },
            onFocusOutside: e => e.preventDefault(),
            get onDismiss() {
              return context.close;
            }
          }, others));
        }
      });
    }
  });
});

/**
 * Portals its children into the `body` when the hovercard is open.
 */
function HoverCardPortal(props) {
  const context = useHoverCardContext();
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

/*!
 * Portions of this file are based on code from ariakit.
 * MIT Licensed, Copyright (c) Diego Haz.
 *
 * Credits to the Ariakit team:
 * https://github.com/ariakit/ariakit/blob/84e97943ad637a582c01c9b56d880cd95f595737/packages/ariakit/src/hovercard/__utils/polygon.ts
 * https://github.com/ariakit/ariakit/blob/f2a96973de523d67e41eec983263936c489ef3e2/packages/ariakit/src/hovercard/__utils/debug-polygon.ts
 */

/**
 * Construct a polygon based on the floating element placement relative to the anchor.
 */
function getHoverCardSafeArea(placement, anchorEl, floatingEl) {
  const basePlacement = placement.split("-")[0];
  const anchorRect = anchorEl.getBoundingClientRect();
  const floatingRect = floatingEl.getBoundingClientRect();
  const polygon = [];
  const anchorCenterX = anchorRect.left + anchorRect.width / 2;
  const anchorCenterY = anchorRect.top + anchorRect.height / 2;
  switch (basePlacement) {
    case "top":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "right":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
    case "bottom":
      polygon.push([anchorRect.left, anchorCenterY]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([anchorRect.right, anchorCenterY]);
      break;
    case "left":
      polygon.push([anchorCenterX, anchorRect.top]);
      polygon.push([floatingRect.right, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.top]);
      polygon.push([floatingRect.left, floatingRect.bottom]);
      polygon.push([floatingRect.right, floatingRect.bottom]);
      polygon.push([anchorCenterX, anchorRect.bottom]);
      break;
  }
  return polygon;
}

/**
 * A popover that allows sighted users to preview content available behind a link.
 */
const HoverCardRoot = props => {
  const defaultId = `hovercard-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId,
    openDelay: 700,
    closeDelay: 300
  }, props);
  const [local, others] = splitProps(props, ["id", "isOpen", "defaultIsOpen", "onOpenChange", "openDelay", "closeDelay", "ignoreSafeArea", "forceMount"]);
  let openTimeoutId;
  let closeTimeoutId;
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [currentPlacement, setCurrentPlacement] = createSignal(others.placement);
  const disclosureState = createDisclosureState({
    isOpen: () => local.isOpen,
    defaultIsOpen: () => local.defaultIsOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const {
    addGlobalListener,
    removeGlobalListener
  } = createGlobalListeners();
  const openWithDelay = () => {
    if (isServer) {
      return;
    }
    openTimeoutId = window.setTimeout(() => {
      openTimeoutId = undefined;
      disclosureState.open();
    }, local.openDelay);
  };
  const closeWithDelay = () => {
    if (isServer) {
      return;
    }
    closeTimeoutId = window.setTimeout(() => {
      closeTimeoutId = undefined;
      disclosureState.close();
    }, local.closeDelay);
  };
  const cancelOpening = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(openTimeoutId);
    openTimeoutId = undefined;
  };
  const cancelClosing = () => {
    if (isServer) {
      return;
    }
    window.clearTimeout(closeTimeoutId);
    closeTimeoutId = undefined;
  };
  const isTargetOnHoverCard = target => {
    return contains(triggerRef(), target) || contains(contentRef(), target);
  };
  const getPolygonSafeArea = placement => {
    const triggerEl = triggerRef();
    const contentEl = contentRef();
    if (!triggerEl || !contentEl) {
      return;
    }
    return getHoverCardSafeArea(placement, triggerEl, contentEl);
  };
  const onHoverOutside = event => {
    const target = event.target;

    // Don't close if the mouse is moving through valid hovercard element.
    if (isTargetOnHoverCard(target)) {
      cancelClosing();
      return;
    }
    if (!local.ignoreSafeArea) {
      const polygon = getPolygonSafeArea(currentPlacement());

      //Don't close if the current's event mouse position is inside the polygon safe area.
      if (polygon && isPointInPolygon(getEventPoint(event), polygon)) {
        cancelClosing();
        return;
      }
    }

    // If there's already a scheduled timeout to hide the hovercard, we do nothing.
    if (closeTimeoutId) {
      return;
    }

    // Otherwise, hide the hovercard after the close delay.
    closeWithDelay();
  };
  createEffect(() => {
    if (!disclosureState.isOpen()) {
      return;
    }

    // Checks whether the mouse is moving outside the hovercard.
    // If yes, hide the card after the close delay.
    addGlobalListener(document, "pointermove", onHoverOutside, true);
    onCleanup(() => {
      removeGlobalListener(document, "pointermove", onHoverOutside, true);
    });
  });

  // cleanup all timeout on unmount.
  onCleanup(() => {
    cancelOpening();
    cancelClosing();
  });
  const context = {
    isOpen: disclosureState.isOpen,
    shouldMount: () => local.forceMount || disclosureState.isOpen(),
    openWithDelay,
    closeWithDelay,
    cancelOpening,
    cancelClosing,
    close: disclosureState.close,
    isTargetOnHoverCard,
    setTriggerRef,
    setContentRef
  };
  return createComponent(HoverCardContext.Provider, {
    value: context,
    get children() {
      return createComponent(PopperRoot, mergeProps$1({
        anchorRef: triggerRef,
        contentRef: contentRef,
        onCurrentPlacementChange: setCurrentPlacement
      }, others));
    }
  });
};

/**
 * The link that opens the hovercard when hovered.
 */
const HoverCardTrigger = createPolymorphicComponent(props => {
  const context = useHoverCardContext();
  props = mergeDefaultProps({
    as: "a"
  }, props);
  const [local, others] = splitProps(props, ["ref", "onPointerEnter", "onPointerLeave", "onFocus", "onBlur", "onTouchStart"]);
  const onPointerEnter = e => {
    callHandler(e, local.onPointerEnter);
    if (e.pointerType === "touch" || others.isDisabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onPointerLeave = e => {
    callHandler(e, local.onPointerLeave);
    if (e.pointerType === "touch") {
      return;
    }
    context.cancelOpening();
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (others.isDisabled || e.defaultPrevented) {
      return;
    }
    context.cancelClosing();
    if (!context.isOpen()) {
      context.openWithDelay();
    }
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    context.cancelOpening();
    const relatedTarget = e.relatedTarget;
    if (context.isTargetOnHoverCard(relatedTarget)) {
      return;
    }
    context.closeWithDelay();
  };
  const onTouchStart = e => {
    callHandler(e, local.onTouchStart);

    // prevent focus event on touch devices
    e.preventDefault();
  };
  onCleanup(context.cancelOpening);
  return createComponent(LinkRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    onPointerEnter: onPointerEnter,
    onPointerLeave: onPointerLeave,
    onFocus: onFocus,
    onBlur: onBlur,
    onTouchStart: onTouchStart
  }, others));
});

var index$c = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: HoverCardContent,
  Portal: HoverCardPortal,
  Root: HoverCardRoot,
  Trigger: HoverCardTrigger
});

const ImageContext = createContext();
function useImageContext() {
  const context = useContext(ImageContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useImageContext` must be used within an `Image.Root` component");
  }
  return context;
}

/**
 * An element that renders when the image hasn't loaded.
 * This means whilst it's loading, or if there was an error.
 */
const ImageFallback = createPolymorphicComponent(props => {
  const context = useImageContext();
  props = mergeDefaultProps({
    as: "span"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  const [canRender, setCanRender] = createSignal(context.fallbackDelay() === undefined);
  createEffect(() => {
    const delayMs = context.fallbackDelay();
    if (delayMs !== undefined) {
      const timerId = window.setTimeout(() => setCanRender(true), delayMs);
      onCleanup(() => window.clearTimeout(timerId));
    }
  });
  return createComponent(Show, {
    get when() {
      return memo(() => !!canRender())() && context.imageLoadingStatus() !== "loaded";
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }
      }, others));
    }
  });
});

const _tmpl$$5 = /*#__PURE__*/template(`<img>`, 1);
/**
 * The image to render. By default, it will only render when it has loaded.
 */
const ImageImg = props => {
  const context = useImageContext();
  const [loadingStatus, setLoadingStatus] = createSignal("idle");
  createEffect(on(() => props.src, src => {
    if (!src) {
      setLoadingStatus("error");
      return;
    }
    let isMounted = true;
    const image = new window.Image();
    const updateStatus = status => () => {
      if (!isMounted) {
        return;
      }
      setLoadingStatus(status);
    };
    setLoadingStatus("loading");
    image.onload = updateStatus("loaded");
    image.onerror = updateStatus("error");
    image.src = src;
    onCleanup(() => {
      isMounted = false;
    });
  }));
  createEffect(() => {
    const imageLoadingStatus = loadingStatus();
    if (imageLoadingStatus !== "idle") {
      context.onImageLoadingStatusChange(imageLoadingStatus);
    }
  });
  return createComponent(Show, {
    get when() {
      return loadingStatus() === "loaded";
    },
    get children() {
      const _el$ = _tmpl$$5.cloneNode(true);
      spread(_el$, props, false, false);
      return _el$;
    }
  });
};

/**
 * An image element with an optional fallback for loading and error status.
 */
const ImageRoot = createPolymorphicComponent(props => {
  props = mergeDefaultProps({
    as: "span"
  }, props);
  const [local, others] = splitProps(props, ["as", "fallbackDelay", "onLoadingStatusChange"]);
  const [imageLoadingStatus, setImageLoadingStatus] = createSignal("idle");
  const context = {
    fallbackDelay: () => local.fallbackDelay,
    imageLoadingStatus,
    onImageLoadingStatusChange: status => {
      setImageLoadingStatus(status);
      local.onLoadingStatusChange?.(status);
    }
  };
  return createComponent(ImageContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }
      }, others));
    }
  });
});

var index$b = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Fallback: ImageFallback,
  Img: ImageImg,
  Root: ImageRoot
});

const ListboxContext = createContext();
function useListboxContext() {
  const context = useContext(ListboxContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxContext` must be used within a `Listbox` component");
  }
  return context;
}

const ListboxGroupContext = createContext();
function useListboxGroupContext() {
  const context = useContext(ListboxGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxGroupContext` must be used within a `Listbox.Group` component");
  }
  return context;
}

/**
 * A container used to group multiple `Listbox.Option`s.
 */
const ListboxGroup = createPolymorphicComponent(props => {
  const listBoxContext = useListboxContext();
  const defaultId = `${listBoxContext.generateId("group")}-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  const [labelId, setLabelId] = createSignal();
  const context = {
    generateId: createGenerateId(() => others.id),
    registerLabel: createRegisterId(setLabelId)
  };
  return createComponent(ListboxGroupContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        role: "group",
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, others));
    }
  });
});

/**
 * A component used to render the label of a `Listbox.Group`.
 * It won't be focusable using arrow keys.
 */
const ListboxGroupLabel = createPolymorphicComponent(props => {
  const context = useListboxGroupContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerLabel(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    },
    "aria-hidden": "true"
  }, others));
});

const ListboxItemContext = createContext();
function useListboxItemContext() {
  const context = useContext(ListboxItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useListboxItemContext` must be used within a `Listbox.Item` component");
  }
  return context;
}

/**
 * An item of the listbox.
 */
const ListboxItem = createPolymorphicComponent(props => {
  let ref;
  const listBoxContext = useListboxContext();
  const defaultId = `${listBoxContext.generateId("item")}-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "value", "textValue", "isDisabled", "aria-label", "aria-labelledby", "aria-describedby", "onPressStart", "onPressUp", "onPress", "onPressChange", "onLongPress", "onFocus", "onMouseDown", "onDragStart", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const [labelId, setLabelId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const [labelRef, setLabelRef] = createSignal();
  const [isPressed, setIsPressed] = createSignal();
  const selectionManager = () => listBoxContext.listState().selectionManager();
  const isFocused = () => selectionManager().focusedKey() === local.value;
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      key: local.value,
      label: labelRef()?.textContent ?? ref?.textContent ?? "",
      textValue: local.textValue ?? labelRef()?.textContent ?? ref?.textContent ?? "",
      isDisabled: local.isDisabled ?? false
    })
  });
  const selectableItem = createSelectableItem({
    key: () => local.value,
    selectionManager: selectionManager,
    shouldSelectOnPressUp: listBoxContext.shouldSelectOnPressUp,
    allowsDifferentPressOrigin: () => {
      return listBoxContext.shouldSelectOnPressUp() && listBoxContext.shouldFocusOnHover();
    },
    shouldUseVirtualFocus: listBoxContext.shouldUseVirtualFocus,
    isDisabled: () => local.isDisabled
  }, () => ref);
  const {
    hoverHandlers,
    isHovered
  } = createHover({
    isDisabled: () => selectableItem.isDisabled(),
    onHoverStart: () => {
      if (!isKeyboardFocusVisible() && listBoxContext.shouldFocusOnHover()) {
        selectionManager().setFocused(true);
        selectionManager().setFocusedKey(local.value);
      }
    }
  });
  const {
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  const ariaSelected = () => {
    if (selectionManager().selectionMode() === "none") {
      return undefined;
    }
    return selectableItem.isSelected();
  };

  // Safari with VoiceOver on macOS misreads options with aria-labelledby or aria-label as simply "text".
  // We should not map slots to the label and description on Safari and instead just have VoiceOver read the textContent.
  // https://bugs.webkit.org/show_bug.cgi?id=209279
  const isNotSafariMacOS = createMemo(() => !(isMac() && isWebKit()));
  const ariaLabel = () => isNotSafariMacOS() ? local["aria-label"] : undefined;
  const ariaLabelledBy = () => isNotSafariMacOS() ? labelId() : undefined;
  const ariaDescribedBy = () => isNotSafariMacOS() ? descriptionId() : undefined;
  const dataset = createMemo(() => ({
    "data-disabled": selectableItem.isDisabled() ? "" : undefined,
    "data-selected": selectableItem.isSelected() ? "" : undefined,
    "data-hover": isHovered() ? "" : undefined,
    "data-focus": isFocused() ? "" : undefined,
    "data-focus-visible": isFocusVisible() ? "" : undefined,
    "data-active": isPressed() ? "" : undefined
  }));
  const context = {
    isSelected: selectableItem.isSelected,
    dataset,
    setLabelRef,
    generateId: createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(ListboxItemContext.Provider, {
    value: context,
    get children() {
      return createComponent(Pressable, mergeProps$1({
        get as() {
          return local.as;
        },
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        role: "option",
        get tabIndex() {
          return selectableItem.tabIndex();
        },
        get isDisabled() {
          return selectableItem.isDisabled();
        },
        get preventFocusOnPress() {
          return selectableItem.preventFocusOnPress();
        },
        get ["aria-selected"]() {
          return ariaSelected();
        },
        get ["aria-label"]() {
          return ariaLabel();
        },
        get ["aria-labelledby"]() {
          return ariaLabelledBy();
        },
        get ["aria-describedby"]() {
          return ariaDescribedBy();
        },
        get ["data-key"]() {
          return selectableItem.dataKey();
        },
        get onFocus() {
          return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
        },
        get onPressStart() {
          return composeEventHandlers([local.onPressStart, selectableItem.onPressStart]);
        },
        get onPressUp() {
          return composeEventHandlers([local.onPressUp, selectableItem.onPressUp]);
        },
        get onPress() {
          return composeEventHandlers([local.onPress, selectableItem.onPress]);
        },
        get onPressChange() {
          return composeEventHandlers([local.onPressChange, setIsPressed]);
        },
        get onLongPress() {
          return composeEventHandlers([local.onLongPress, selectableItem.onLongPress]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
        },
        get onDragStart() {
          return composeEventHandlers([local.onDragStart, selectableItem.onDragStart]);
        },
        get onPointerEnter() {
          return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
        },
        get onPointerLeave() {
          return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
        },
        get onFocusIn() {
          return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
        },
        get onFocusOut() {
          return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
        }
      }, dataset, others));
    }
  });
});

/**
 * An optional accessible description to be announced for the item.
 * Useful for items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
const ListboxItemDescription = createPolymorphicComponent(props => {
  const context = useListboxItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
});

/**
 * The visual indicator rendered when the item is selected.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
const ListboxItemIndicator = createPolymorphicComponent(props => {
  const context = useListboxItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(props, ["as", "forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isSelected();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        "aria-hidden": "true"
      }, () => context.dataset(), others));
    }
  });
});

/**
 * An accessible label to be announced for the item.
 * Useful for items that have more complex content (e.g. icons, multiple lines of text, etc.)
 */
const ListboxItemLabel = createPolymorphicComponent(props => {
  const context = useListboxItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(context.setLabelRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
});

/**
 * Listbox presents a list of options and allows a user to select one or more of them.
 */
const ListboxRoot = createPolymorphicComponent(props => {
  let ref;
  const defaultId = `listbox-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId,
    selectionMode: "single"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "value", "defaultValue", "onValueChange", "items", "onItemsChange", "state", "keyboardDelegate", "autoFocus", "selectionMode", "shouldFocusWrap", "shouldUseVirtualFocus", "shouldSelectOnPressUp", "shouldFocusOnHover", "allowDuplicateSelectionEvents", "disallowEmptySelection", "selectionBehavior", "selectOnFocus", "disallowTypeAhead", "allowsTabNavigation", "scrollRef", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const [items, setItems] = createControllableArraySignal({
    value: () => local.items,
    defaultValue: () => [],
    onChange: value => local.onItemsChange?.(value)
  });
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createMemo(() => {
    if (local.state) {
      return local.state;
    }
    return createListState({
      selectedKeys: () => local.value,
      defaultSelectedKeys: () => local.defaultValue,
      onSelectionChange: local.onValueChange,
      allowDuplicateSelectionEvents: () => access(local.allowDuplicateSelectionEvents),
      disallowEmptySelection: () => access(local.disallowEmptySelection),
      selectionBehavior: () => access(local.selectionBehavior),
      selectionMode: () => access(local.selectionMode),
      dataSource: items
    });
  });
  const selectableList = createSelectableList({
    selectionManager: () => listState().selectionManager(),
    collection: () => listState().collection(),
    autoFocus: () => access(local.autoFocus),
    shouldFocusWrap: () => access(local.shouldFocusWrap),
    keyboardDelegate: () => local.keyboardDelegate,
    disallowEmptySelection: () => access(local.disallowEmptySelection),
    selectOnFocus: () => access(local.selectOnFocus),
    disallowTypeAhead: () => access(local.disallowTypeAhead),
    shouldUseVirtualFocus: () => access(local.shouldUseVirtualFocus),
    allowsTabNavigation: () => access(local.allowsTabNavigation),
    isVirtualized: false
  }, () => ref, () => local.scrollRef?.());
  const context = {
    listState,
    generateId: createGenerateId(() => others.id),
    shouldUseVirtualFocus: () => props.shouldUseVirtualFocus,
    shouldSelectOnPressUp: () => props.shouldSelectOnPressUp,
    shouldFocusOnHover: () => props.shouldFocusOnHover
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(ListboxContext.Provider, {
        value: context,
        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            },
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "listbox",
            get tabIndex() {
              return selectableList.tabIndex();
            },
            get ["aria-multiselectable"]() {
              return listState().selectionManager().selectionMode() === "multiple" ? true : undefined;
            },
            get ["data-focus"]() {
              return listState().selectionManager().isFocused() ? "" : undefined;
            },
            get onKeyDown() {
              return composeEventHandlers([local.onKeyDown, selectableList.handlers.onKeyDown]);
            },
            get onMouseDown() {
              return composeEventHandlers([local.onMouseDown, selectableList.handlers.onMouseDown]);
            },
            get onFocusIn() {
              return composeEventHandlers([local.onFocusIn, selectableList.handlers.onFocusIn]);
            },
            get onFocusOut() {
              return composeEventHandlers([local.onFocusOut, selectableList.handlers.onFocusOut]);
            }
          }, others));
        }
      });
    }
  });
});

var index$a = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Group: ListboxGroup,
  GroupLabel: ListboxGroupLabel,
  Item: ListboxItem,
  ItemDescription: ListboxItemDescription,
  ItemIndicator: ListboxItemIndicator,
  ItemLabel: ListboxItemLabel,
  Root: ListboxRoot
});

const SelectContext = createContext();
function useSelectContext() {
  const context = useContext(SelectContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSelectContext` must be used within a `Select` component");
  }
  return context;
}

/**
 * The component that pops out when the select is open.
 */
const SelectContent = createPolymorphicComponent(props => {
  let ref;
  const context = useSelectContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["ref", "id", "style", "forceMount"]);
  const forceMount = () => local.forceMount || context.isOpen();
  const onEscapeKeyDown = e => {
    // `createSelectableList` prevent escape key down,
    // which prevent our `onDismiss` in `DismissableLayer` to run,
    // so we force "close on escape" here.
    context.close();
  };
  const onFocusOutside = e => {
    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    e.preventDefault();
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !context.isOpen(),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    isDisabled: () => !context.isOpen()
  });
  createFocusScope({
    trapFocus: context.isOpen,
    onMountAutoFocus: e => {
      // We prevent open autofocus because it's handled by the `Listbox`.
      e.preventDefault();
    },
    onUnmountAutoFocus: e => {
      focusWithoutScrolling(context.triggerRef());
      e.preventDefault();
    }
  }, () => ref);
  return createComponent(PopperPositioner, {
    get children() {
      return createComponent(DismissableLayer, mergeProps$1({
        ref(r$) {
          const _ref$ = mergeRefs(el => {
            context.setContentRef(el);
            ref = el;
          }, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get isDismissed() {
          return !context.isOpen();
        },
        get disableOutsidePointerEvents() {
          return context.isOpen();
        },
        get excludedElements() {
          return [context.triggerRef];
        },
        get hidden() {
          return !forceMount();
        },
        get style() {
          return {
            position: "relative",
            display: !forceMount() ? "none" : undefined,
            ...local.style
          };
        },
        onEscapeKeyDown: onEscapeKeyDown,
        onFocusOutside: onFocusOutside,
        get onDismiss() {
          return context.close;
        }
      }, others));
    }
  });
});

/**
 * A small icon often displayed next to the value as a visual affordance for the fact it can be open.
 * It renders a `▼` by default, but you can use your own icon `children`.
 */
const SelectIcon = createPolymorphicComponent(props => {
  const context = useSelectContext();
  props = mergeDefaultProps({
    as: "div",
    children: "▼"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    "aria-hidden": "true",
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    }
  }, others));
});

/**
 * The label that gives the user information on the select.
 */
const SelectLabel = createPolymorphicComponent(props => {
  const context = useSelectContext();
  const [local, others] = splitProps(props, ["onClick"]);
  const onClick = e => {
    callHandler(e, local.onClick);
    if (!context.isDisabled()) {
      context.triggerRef()?.focus();

      // Show the focus ring so the user knows where focus went
      setInteractionModality("keyboard");
    }
  };
  return createComponent(FormControlLabel, mergeProps$1({
    as: "span",
    onClick: onClick
  }, others));
});

/**
 * Contains all the items of a `Select`.
 */
const SelectListbox = createPolymorphicComponent(props => {
  const context = useSelectContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("listbox")
  }, props);
  const [local, others] = splitProps(props, ["ref", "id"]);
  createEffect(() => onCleanup(context.registerListboxId(local.id)));
  onMount(() => {
    if (!context.isOpen() || context.autoFocus() === false) {
      return;
    }
    let focusedKey = context.listState().selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (context.autoFocus() === "first") {
        focusedKey = context.listState().collection().getFirstKey();
      } else if (context.autoFocus() === "last") {
        focusedKey = context.listState().collection().getLastKey();
      }
    }
    context.listState().selectionManager().setFocused(true);
    context.listState().selectionManager().setFocusedKey(focusedKey);
  });
  return createComponent(ListboxRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setListboxRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return local.id;
    },
    get items() {
      return context.items();
    },
    get state() {
      return context.listState();
    },
    get autoFocus() {
      return memo(() => !!context.isOpen())() ? context.autoFocus() : false;
    },
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    get ["aria-labelledby"]() {
      return context.listboxAriaLabelledBy();
    },
    get onItemsChange() {
      return context.setItems;
    }
  }, others));
});

const _tmpl$$4 = /*#__PURE__*/template(`<div aria-hidden="true"><input type="text"><select tabindex="-1"><option></option></select></div>`, 7),
  _tmpl$2 = /*#__PURE__*/template(`<option></option>`, 2),
  _tmpl$3 = /*#__PURE__*/template(`<input type="hidden">`, 1);
// In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
// In Firefox, there must be a <label> to identify the <select> whereas other browsers
// seem to identify it just by surrounding text.
// The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
// 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
// non tabbable with tabIndex={-1}.
//
// In mobile browsers, there are next/previous buttons above the software keyboard for navigating
// between fields in a form. These only support native form inputs that are tabbable. In order to
// support those, an additional hidden input is used to marshall focus to the button. It is tabbable
// except when the button is focused, so that shift tab works properly to go to the actual previous
// input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
// the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
// prevent Safari from zooming in on the input when it is focused.
//
// If the current interaction modality is null, then the user hasn't interacted with the page yet.
// In this case, we set the tabIndex to -1 on the input element so that automated accessibility
// checkers don't throw false-positives about focusable elements inside an aria-hidden parent.
/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */
function HiddenSelect(props) {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  const modality = createInteractionModality();
  const selectionManager = () => context.listState().selectionManager();
  const collection = () => context.listState().collection();

  // If used in a <form>, use hidden inputs so the value can be submitted to a server.
  // If single selection mode and the collection isn't too big,
  // use a hidden <select> element for this so that browser autofill will work.
  // Otherwise, use <input type="hidden" />.
  return createComponent(Switch, {
    fallback: null,
    get children() {
      return [createComponent(Match, {
        get when() {
          return memo(() => selectionManager().selectionMode() === "single")() && collection().getSize() <= 300;
        },
        get children() {
          const _el$ = _tmpl$$4.cloneNode(true),
            _el$2 = _el$.firstChild,
            _el$3 = _el$2.nextSibling;
            _el$3.firstChild;
          _el$2.addEventListener("focus", () => context.triggerRef()?.focus());
          _el$2.style.setProperty("font-size", "16px");
          _el$3.addEventListener("change", e => selectionManager().setSelectedKeys(new Set([e.target.value])));
          insert(_el$3, createComponent(For, {
            get each() {
              return [...collection().getKeys()];
            },
            children: key => {
              const item = collection().getItem(key);
              if (item) {
                return (() => {
                  const _el$5 = _tmpl$2.cloneNode(true);
                  insert(_el$5, () => item.textValue);
                  effect(() => _el$5.value = item.key);
                  return _el$5;
                })();
              }
            }
          }), null);
          effect(_p$ => {
            const _v$ = visuallyHiddenStyles,
              _v$2 = modality() == null || selectionManager().isFocused() || context.isOpen() ? -1 : 0,
              _v$3 = formControlContext.isRequired(),
              _v$4 = formControlContext.isDisabled(),
              _v$5 = formControlContext.isReadOnly(),
              _v$6 = props.autoComplete,
              _v$7 = formControlContext.name(),
              _v$8 = formControlContext.isRequired(),
              _v$9 = formControlContext.isDisabled(),
              _v$10 = collection().getSize();
            _p$._v$ = style(_el$, _v$, _p$._v$);
            _v$2 !== _p$._v$2 && setAttribute(_el$2, "tabindex", _p$._v$2 = _v$2);
            _v$3 !== _p$._v$3 && (_el$2.required = _p$._v$3 = _v$3);
            _v$4 !== _p$._v$4 && (_el$2.disabled = _p$._v$4 = _v$4);
            _v$5 !== _p$._v$5 && (_el$2.readOnly = _p$._v$5 = _v$5);
            _v$6 !== _p$._v$6 && setAttribute(_el$3, "autocomplete", _p$._v$6 = _v$6);
            _v$7 !== _p$._v$7 && setAttribute(_el$3, "name", _p$._v$7 = _v$7);
            _v$8 !== _p$._v$8 && (_el$3.required = _p$._v$8 = _v$8);
            _v$9 !== _p$._v$9 && (_el$3.disabled = _p$._v$9 = _v$9);
            _v$10 !== _p$._v$10 && setAttribute(_el$3, "size", _p$._v$10 = _v$10);
            return _p$;
          }, {
            _v$: undefined,
            _v$2: undefined,
            _v$3: undefined,
            _v$4: undefined,
            _v$5: undefined,
            _v$6: undefined,
            _v$7: undefined,
            _v$8: undefined,
            _v$9: undefined,
            _v$10: undefined
          });
          effect(() => _el$3.value = selectionManager().firstSelectedKey());
          return _el$;
        }
      }), createComponent(Match, {
        get when() {
          return formControlContext.name() != null;
        },
        get children() {
          return createComponent(For, {
            get each() {
              return [...selectionManager().selectedKeys()];
            },
            children: key => (() => {
              const _el$6 = _tmpl$3.cloneNode(true);
              _el$6.value = key;
              effect(_p$ => {
                const _v$11 = props.autoComplete,
                  _v$12 = formControlContext.name(),
                  _v$13 = formControlContext.isRequired(),
                  _v$14 = formControlContext.isDisabled(),
                  _v$15 = formControlContext.isReadOnly();
                _v$11 !== _p$._v$11 && setAttribute(_el$6, "autocomplete", _p$._v$11 = _v$11);
                _v$12 !== _p$._v$12 && setAttribute(_el$6, "name", _p$._v$12 = _v$12);
                _v$13 !== _p$._v$13 && (_el$6.required = _p$._v$13 = _v$13);
                _v$14 !== _p$._v$14 && (_el$6.disabled = _p$._v$14 = _v$14);
                _v$15 !== _p$._v$15 && (_el$6.readOnly = _p$._v$15 = _v$15);
                return _p$;
              }, {
                _v$11: undefined,
                _v$12: undefined,
                _v$13: undefined,
                _v$14: undefined,
                _v$15: undefined
              });
              return _el$6;
            })()
          });
        }
      })];
    }
  });
}

/**
 * Base component for a select, provide context for its children.
 * Used to build single and multi-select.
 */
function SelectBase(props) {
  const defaultId = `select-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId,
    selectionMode: "single",
    allowDuplicateSelectionEvents: true,
    disallowEmptySelection: props.selectionMode !== "multiple",
    gutter: 8
  }, props);
  const [local, formControlProps, others] = splitProps(props, ["children", "isOpen", "defaultIsOpen", "onOpenChange", "value", "defaultValue", "onValueChange", "keyboardDelegate", "autoComplete", "allowDuplicateSelectionEvents", "disallowEmptySelection", "selectionBehavior", "selectionMode"], FORM_CONTROL_PROP_NAMES);
  const [triggerId, setTriggerId] = createSignal();
  const [valueId, setValueId] = createSignal();
  const [listboxId, setListboxId] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [listboxRef, setListboxRef] = createSignal();
  const [listboxAriaLabelledBy, setListboxAriaLabelledBy] = createSignal();
  const [focusStrategy, setFocusStrategy] = createSignal(true);
  const [items, setItems] = createSignal([]);
  const disclosureState = createDisclosureState({
    isOpen: () => local.isOpen,
    defaultIsOpen: () => local.defaultIsOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const focusTrigger = () => {
    const triggerEl = triggerRef();
    if (triggerEl) {
      focusSafely(triggerEl);
    }
  };
  const focusListbox = () => {
    const listboxEl = listboxRef();
    if (listboxEl) {
      focusSafely(listboxEl);
    }
  };
  const open = focusStrategy => {
    // Don't open if the collection is empty.
    if (listState.collection().getSize() <= 0) {
      return;
    }
    setFocusStrategy(focusStrategy);
    disclosureState.open();
    let focusedKey = listState.selectionManager().firstSelectedKey();
    if (focusedKey == null) {
      if (focusStrategy === "first") {
        focusedKey = listState.collection().getFirstKey();
      } else if (focusStrategy === "last") {
        focusedKey = listState.collection().getLastKey();
      }
    }
    focusListbox();
    listState.selectionManager().setFocused(true);
    listState.selectionManager().setFocusedKey(focusedKey);
  };
  const close = () => {
    disclosureState.close();
    listState.selectionManager().setFocused(false);
    listState.selectionManager().setFocusedKey(undefined);
    focusTrigger();
  };
  const toggle = focusStrategy => {
    if (disclosureState.isOpen()) {
      close();
    } else {
      open(focusStrategy);
    }
  };
  const listState = createListState({
    selectedKeys: () => local.value,
    defaultSelectedKeys: () => local.defaultValue,
    onSelectionChange: keys => {
      local.onValueChange?.(keys);
      if (local.selectionMode === "single") {
        close();
      }
    },
    allowDuplicateSelectionEvents: () => access(local.allowDuplicateSelectionEvents),
    disallowEmptySelection: () => access(local.disallowEmptySelection),
    selectionBehavior: () => access(local.selectionBehavior),
    selectionMode: () => local.selectionMode,
    dataSource: items
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(triggerRef, () => {
    listState.selectionManager().setSelectedKeys(local.defaultValue ?? new Selection());
  });
  const collator = createCollator({
    usage: "search",
    sensitivity: "base"
  });

  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.
  const delegate = createMemo(() => {
    const keyboardDelegate = access(local.keyboardDelegate);
    if (keyboardDelegate) {
      return keyboardDelegate;
    }
    return new ListKeyboardDelegate(listState.collection, undefined, collator);
  });
  const context = {
    isOpen: disclosureState.isOpen,
    isDisabled: () => formControlContext.isDisabled() ?? false,
    isMultiple: () => access(local.selectionMode) === "multiple",
    autoFocus: focusStrategy,
    triggerRef,
    listState: () => listState,
    keyboardDelegate: delegate,
    items,
    setItems,
    triggerId,
    valueId,
    listboxId,
    listboxAriaLabelledBy,
    setListboxAriaLabelledBy,
    setTriggerRef,
    setContentRef,
    setListboxRef,
    open,
    close,
    toggle,
    generateId: createGenerateId(() => access(formControlProps.id)),
    registerTriggerId: createRegisterId(setTriggerId),
    registerValueId: createRegisterId(setValueId),
    registerListboxId: createRegisterId(setListboxId)
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(SelectContext.Provider, {
        value: context,
        get children() {
          return createComponent(PopperRoot, mergeProps$1({
            anchorRef: triggerRef,
            contentRef: contentRef,
            sameWidth: true
          }, others, {
            get children() {
              return [createComponent(HiddenSelect, {
                get autoComplete() {
                  return local.autoComplete;
                }
              }), memo(() => local.children)];
            }
          }));
        }
      });
    }
  });
}

/**
 * Displays a list of options for the user to pick from — triggered by a button.
 */
function SelectRoot(props) {
  const [local, others] = splitProps(props, ["value", "defaultValue", "onValueChange"]);
  const [value, setValue] = createControllableSetSignal({
    value: () => local.value != null ? new Set([local.value]) : undefined,
    defaultValue: () => local.defaultValue != null ? new Set([local.defaultValue]) : undefined,
    onChange: value => local.onValueChange?.(value.values().next().value)
  });
  return createComponent(SelectBase, mergeProps$1({
    get value() {
      return value();
    },
    onValueChange: setValue,
    selectionMode: "single",
    disallowEmptySelection: true
  }, others));
}

const SelectTrigger = createPolymorphicComponent(props => {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  props = mergeDefaultProps({
    id: context.generateId("trigger")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(props, ["ref", "isDisabled", "onPressStart", "onPress", "onKeyDown", "onFocus", "onBlur"], FORM_CONTROL_FIELD_PROP_NAMES);
  const selectionManager = () => context.listState().selectionManager();
  const keyboardDelegate = () => context.keyboardDelegate();
  const isDisabled = () => local.isDisabled || context.isDisabled();
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const {
    typeSelectHandlers
  } = createTypeSelect({
    keyboardDelegate: keyboardDelegate,
    selectionManager: selectionManager,
    onTypeSelect: key => selectionManager().select(key)
  });
  const ariaLabelledBy = () => {
    return [context.listboxAriaLabelledBy(), context.valueId()].filter(Boolean).join(" ") || undefined;
  };
  const onPressStart = e => {
    local.onPressStart?.(e);

    // For consistency with native, open the menu on mouse/key down, but touch up.
    if (e.pointerType !== "touch" && e.pointerType !== "keyboard" && !isDisabled()) {
      // If opened with a screen reader, autofocus the first item.
      // Otherwise, the menu itself will be focused.
      context.toggle(e.pointerType === "virtual" ? "first" : true);
    }
  };
  const onPress = e => {
    local.onPress?.(e);
    if (e.pointerType === "touch" && !isDisabled()) {
      context.toggle(true);
    }
  };
  const onKeyDown = e => {
    callHandler(e, local.onKeyDown);
    if (isDisabled()) {
      return;
    }
    callHandler(e, typeSelectHandlers.onKeyDown);
    switch (e.key) {
      case "Enter":
      case " ":
      case "ArrowDown":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("first");
        break;
      case "ArrowUp":
        e.stopPropagation();
        e.preventDefault();
        context.toggle("last");
        break;
      case "ArrowLeft":
        {
          // prevent scrolling containers
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyAbove?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
      case "ArrowRight":
        {
          // prevent scrolling containers
          e.preventDefault();
          if (context.isMultiple()) {
            return;
          }
          const firstSelectedKey = selectionManager().firstSelectedKey();
          const key = firstSelectedKey != null ? keyboardDelegate().getKeyBelow?.(firstSelectedKey) : keyboardDelegate().getFirstKey?.();
          if (key != null) {
            selectionManager().select(key);
          }
          break;
        }
    }
  };
  const onFocus = e => {
    callHandler(e, local.onFocus);
    if (selectionManager().isFocused()) {
      return;
    }
    selectionManager().setFocused(true);
  };
  const onBlur = e => {
    callHandler(e, local.onBlur);
    if (context.isOpen()) {
      return;
    }
    selectionManager().setFocused(false);
  };
  createEffect(() => onCleanup(context.registerTriggerId(fieldProps.id())));
  createEffect(() => {
    context.setListboxAriaLabelledBy([fieldProps.ariaLabelledBy(), fieldProps.ariaLabel() && !fieldProps.ariaLabelledBy() ? fieldProps.id() : null].filter(Boolean).join(" ") || undefined);
  });
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return fieldProps.id();
    },
    get isDisabled() {
      return isDisabled();
    },
    "aria-haspopup": "listbox",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.listboxId() : undefined;
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    onPressStart: onPressStart,
    onPress: onPress,
    onKeyDown: onKeyDown,
    onFocus: onFocus,
    onBlur: onBlur
  }, () => formControlContext.dataset(), others));
});

/**
 * The part that reflects the selected value. By default, the selected item's text will be rendered.
 * If you require more control, you can instead control the select and pass your own children.
 * An optional placeholder prop is also available for when the select has no value.
 */
const SelectValue = createPolymorphicComponent(props => {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("value")
  }, props);
  const [local, others] = splitProps(props, ["as", "id", "children", "placeholder"]);
  const selectionManager = () => context.listState().selectionManager();
  const isSelectionEmpty = () => selectionManager().isEmpty();
  const valueLabels = () => {
    return [...selectionManager().selectedKeys()].map(key => context.listState().collection().getItem(key)?.label ?? key).join(", ");
  };
  createEffect(() => onCleanup(context.registerValueId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    },
    get ["data-placeholder-shown"]() {
      return isSelectionEmpty() ? "" : undefined;
    }
  }, () => formControlContext.dataset(), others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return !isSelectionEmpty();
        },
        get fallback() {
          return local.placeholder;
        },
        get children() {
          return createComponent(Show, {
            get when() {
              return local.children;
            },
            get fallback() {
              return valueLabels();
            },
            get children() {
              return createComponent(SelectValueChild, {
                state: {
                  selectedValue: () => selectionManager().selectedKeys().values().next().value
                },
                get children() {
                  return local.children;
                }
              });
            }
          });
        }
      });
    }
  }));
});
function SelectValueChild(props) {
  return children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
}

var index$9 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: SelectContent,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  Group: ListboxGroup,
  GroupLabel: ListboxGroupLabel,
  Icon: SelectIcon,
  Item: ListboxItem,
  ItemDescription: ListboxItemDescription,
  ItemIndicator: ListboxItemIndicator,
  ItemLabel: ListboxItemLabel,
  Label: SelectLabel,
  Listbox: SelectListbox,
  Portal: Portal,
  Root: SelectRoot,
  Separator: SeparatorRoot,
  Trigger: SelectTrigger,
  Value: SelectValue
});

/**
 * Displays a list of options for the user to pick multiples from — triggered by a button.
 */
function MultiSelectRoot(props) {
  return createComponent(SelectBase, mergeProps$1({
    selectionMode: "multiple",
    disallowEmptySelection: false
  }, props));
}

/**
 * The part that reflects the selected value. By default, the selected item's text will be rendered.
 * If you require more control, you can instead control the select and pass your own children.
 * An optional placeholder prop is also available for when the select has no value.
 */
const MultiSelectValue = createPolymorphicComponent(props => {
  const formControlContext = useFormControlContext();
  const context = useSelectContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("value")
  }, props);
  const [local, others] = splitProps(props, ["as", "id", "children", "placeholder"]);
  const selectionManager = () => context.listState().selectionManager();
  const isSelectionEmpty = () => selectionManager().isEmpty();
  const valueLabels = () => {
    return [...selectionManager().selectedKeys()].map(key => context.listState().collection().getItem(key)?.label ?? key).join(", ");
  };
  createEffect(() => onCleanup(context.registerValueId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    },
    get ["data-placeholder-shown"]() {
      return isSelectionEmpty() ? "" : undefined;
    }
  }, () => formControlContext.dataset(), others, {
    get children() {
      return createComponent(Show, {
        get when() {
          return !isSelectionEmpty();
        },
        get fallback() {
          return local.placeholder;
        },
        get children() {
          return createComponent(Show, {
            get when() {
              return local.children;
            },
            get fallback() {
              return valueLabels();
            },
            get children() {
              return createComponent(MultiSelectValueChild, {
                state: {
                  selectedValues: () => selectionManager().selectedKeys()
                },
                get children() {
                  return local.children;
                }
              });
            }
          });
        }
      });
    }
  }));
});
function MultiSelectValueChild(props) {
  return children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
}

var index$8 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Arrow: PopperArrow,
  Content: SelectContent,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  Group: ListboxGroup,
  GroupLabel: ListboxGroupLabel,
  Icon: SelectIcon,
  Item: ListboxItem,
  ItemDescription: ListboxItemDescription,
  ItemIndicator: ListboxItemIndicator,
  ItemLabel: ListboxItemLabel,
  Label: SelectLabel,
  Listbox: SelectListbox,
  Portal: Portal,
  Root: MultiSelectRoot,
  Separator: SeparatorRoot,
  Trigger: SelectTrigger,
  Value: MultiSelectValue
});

const PopoverContext = createContext();
function usePopoverContext() {
  const context = useContext(PopoverContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `usePopoverContext` must be used within a `Popover` component");
  }
  return context;
}

/**
 * An optional element to position the `Popover.Content` against.
 * If this part is not used, the content will position alongside the `Popover.Trigger`.
 */
const PopoverAnchor = createPolymorphicComponent(props => {
  const context = usePopoverContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(context.setDefaultAnchorRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
});

/**
 * The button that closes the popover.
 */
const PopoverCloseButton = createPolymorphicComponent(props => {
  const context = usePopoverContext();
  const [local, others] = splitProps(props, ["onPress", "aria-label"]);
  const stringFormatter = createLocalizedStringFormatter(() => COMMON_INTL_MESSAGES);
  const onPress = e => {
    local.onPress?.(e);
    context.close();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-label"]() {
      return local["aria-label"] || stringFormatter().format("dismiss");
    },
    onPress: onPress
  }, others));
});

/**
 * Contains the content to be rendered when the popover is open.
 */
const PopoverContent = createPolymorphicComponent(props => {
  let ref;
  const context = usePopoverContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("content")
  }, props);
  const [local, others] = splitProps(props, ["ref", "id", "style", "onOpenAutoFocus", "onCloseAutoFocus", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
  let isRightClickOutside = false;
  let hasInteractedOutside = false;
  const onCloseAutoFocus = e => {
    local.onCloseAutoFocus?.(e);
    if (context.isModal()) {
      e.preventDefault();
      if (!isRightClickOutside) {
        focusWithoutScrolling(context.triggerRef());
      }
    } else {
      if (!e.defaultPrevented) {
        if (!hasInteractedOutside) {
          focusWithoutScrolling(context.triggerRef());
        }

        // Always prevent autofocus because we either focus manually or want user agent focus
        e.preventDefault();
      }
      hasInteractedOutside = false;
    }
  };
  const onPointerDownOutside = e => {
    local.onPointerDownOutside?.(e);
    if (context.isModal()) {
      isRightClickOutside = e.detail.isContextMenu;
    }
  };
  const onFocusOutside = e => {
    local.onFocusOutside?.(e);

    // When focus is trapped, a `focusout` event may still happen.
    // We make sure we don't trigger our `onDismiss` in such case.
    if (context.isModal()) {
      e.preventDefault();
    }
  };
  const onInteractOutside = e => {
    local.onInteractOutside?.(e);
    if (!context.isModal() && !e.defaultPrevented) {
      hasInteractedOutside = true;
    }
  };

  // aria-hide everything except the content (better supported equivalent to setting aria-modal)
  createHideOutside({
    isDisabled: () => !(context.isOpen() && context.isModal()),
    targets: () => ref ? [ref] : []
  });
  createPreventScroll({
    isDisabled: () => !(context.isOpen() && context.isModal())
  });
  createFocusScope({
    trapFocus: () => context.isOpen() && context.isModal(),
    onMountAutoFocus: local.onOpenAutoFocus,
    onUnmountAutoFocus: onCloseAutoFocus
  }, () => ref);
  createEffect(() => onCleanup(context.registerContentId(local.id)));
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(PopperPositioner, {
        get children() {
          return createComponent(DismissableLayer, mergeProps$1({
            ref(r$) {
              const _ref$ = mergeRefs(el => {
                context.setContentRef(el);
                ref = el;
              }, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "dialog",
            get id() {
              return local.id;
            },
            tabIndex: -1,
            get isDismissed() {
              return !context.isOpen();
            },
            get disableOutsidePointerEvents() {
              return memo(() => !!context.isOpen())() && context.isModal();
            },
            get excludedElements() {
              return [context.triggerRef];
            },
            get style() {
              return {
                position: "relative",
                ...local.style
              };
            },
            get ["aria-labelledby"]() {
              return context.titleId();
            },
            get ["aria-describedby"]() {
              return context.descriptionId();
            },
            onPointerDownOutside: onPointerDownOutside,
            onFocusOutside: onFocusOutside,
            onInteractOutside: onInteractOutside,
            get onDismiss() {
              return context.close;
            }
          }, others));
        }
      });
    }
  });
});

/**
 * An optional accessible description to be announced when the popover is open.
 */
const PopoverDescription = createPolymorphicComponent(props => {
  const context = usePopoverContext();
  props = mergeDefaultProps({
    as: "p",
    id: context.generateId("description")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerDescriptionId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, others));
});

/**
 * Portals its children into the `body` when the popover is open.
 */
function PopoverPortal(props) {
  const context = usePopoverContext();
  return createComponent(Show, {
    get when() {
      return context.shouldMount();
    },
    get children() {
      return createComponent(Portal, props);
    }
  });
}

/**
 * A popover is a dialog positioned relative to an anchor element.
 */
const PopoverRoot = props => {
  const defaultId = `popover-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId,
    isModal: false
  }, props);
  const [local, others] = splitProps(props, ["id", "isOpen", "defaultIsOpen", "onOpenChange", "isModal", "forceMount", "anchorRef"]);
  const [defaultAnchorRef, setDefaultAnchorRef] = createSignal();
  const [triggerRef, setTriggerRef] = createSignal();
  const [contentRef, setContentRef] = createSignal();
  const [contentId, setContentId] = createSignal();
  const [titleId, setTitleId] = createSignal();
  const [descriptionId, setDescriptionId] = createSignal();
  const disclosureState = createDisclosureState({
    isOpen: () => local.isOpen,
    defaultIsOpen: () => local.defaultIsOpen,
    onOpenChange: isOpen => local.onOpenChange?.(isOpen)
  });
  const anchorRef = () => {
    return local.anchorRef?.() ?? defaultAnchorRef() ?? triggerRef();
  };
  const context = {
    isOpen: disclosureState.isOpen,
    isModal: () => local.isModal,
    shouldMount: () => local.forceMount || disclosureState.isOpen(),
    triggerRef,
    contentId,
    titleId,
    descriptionId,
    setDefaultAnchorRef,
    setTriggerRef,
    setContentRef,
    close: disclosureState.close,
    toggle: disclosureState.toggle,
    generateId: createGenerateId(() => local.id),
    registerContentId: createRegisterId(setContentId),
    registerTitleId: createRegisterId(setTitleId),
    registerDescriptionId: createRegisterId(setDescriptionId)
  };
  return createComponent(PopoverContext.Provider, {
    value: context,
    get children() {
      return createComponent(PopperRoot, mergeProps$1({
        anchorRef: anchorRef,
        contentRef: contentRef
      }, others));
    }
  });
};

/**
 * An accessible title to be announced when the popover is open.
 */
const PopoverTitle = createPolymorphicComponent(props => {
  const context = usePopoverContext();
  props = mergeDefaultProps({
    as: "h2",
    id: context.generateId("title")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerTitleId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, others));
});

/**
 * The button that opens the popover.
 */
const PopoverTrigger = createPolymorphicComponent(props => {
  const context = usePopoverContext();
  const [local, others] = splitProps(props, ["ref", "onPress"]);
  const onPress = e => {
    local.onPress?.(e);
    context.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(context.setTriggerRef, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    "aria-haspopup": "dialog",
    get ["aria-expanded"]() {
      return context.isOpen();
    },
    get ["aria-controls"]() {
      return memo(() => !!context.isOpen())() ? context.contentId() : undefined;
    },
    get ["data-expanded"]() {
      return context.isOpen() ? "" : undefined;
    },
    onPress: onPress
  }, others));
});

var index$7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Anchor: PopoverAnchor,
  Arrow: PopperArrow,
  CloseButton: PopoverCloseButton,
  Content: PopoverContent,
  Description: PopoverDescription,
  Portal: PopoverPortal,
  Root: PopoverRoot,
  Title: PopoverTitle,
  Trigger: PopoverTrigger
});

const ProgressContext = createContext();
function useProgressContext() {
  const context = useContext(ProgressContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useProgressContext` must be used within a `Progress.Root` component");
  }
  return context;
}

/**
 * The component that visually represents the progress value.
 * Used to visually show the fill of `Progress.Track`.
 */
const ProgressFill = createPolymorphicComponent(props => {
  const context = useProgressContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "style"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get style() {
      return {
        "--kb-progress-fill-width": context.progressFillWidth(),
        ...local.style
      };
    }
  }, () => context.dataset(), others));
});

/**
 * An accessible label that gives the user information on the progress.
 */
const ProgressLabel = createPolymorphicComponent(props => {
  const context = useProgressContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as", "id"]);
  createEffect(() => onCleanup(context.registerLabelId(local.id)));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return local.id;
    }
  }, () => context.dataset(), others));
});

/**
 * Progress show either determinate or indeterminate progress of an operation over time.
 */
const ProgressRoot = createPolymorphicComponent(props => {
  const defaultId = `progress-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId,
    value: 0,
    minValue: 0,
    maxValue: 100
  }, props);
  const [local, others] = splitProps(props, ["as", "value", "minValue", "maxValue", "isIndeterminate", "getValueLabel"]);
  const [labelId, setLabelId] = createSignal();
  const defaultFormatter = createNumberFormatter(() => ({
    style: "percent"
  }));
  const value = () => {
    return clamp(local.value, local.minValue, local.maxValue);
  };
  const valuePercent = () => {
    return (value() - local.minValue) / (local.maxValue - local.minValue);
  };
  const valueLabel = () => {
    if (local.isIndeterminate) {
      return undefined;
    }
    if (local.getValueLabel) {
      return local.getValueLabel({
        value: value(),
        min: local.minValue,
        max: local.maxValue
      });
    }
    return defaultFormatter().format(valuePercent());
  };
  const progressFillWidth = () => {
    return local.isIndeterminate ? undefined : `${Math.round(valuePercent() * 100)}%`;
  };
  const dataset = createMemo(() => {
    let dataProgress = undefined;
    if (!local.isIndeterminate) {
      dataProgress = valuePercent() === 1 ? "complete" : "loading";
    }
    return {
      "data-progress": dataProgress,
      "data-indeterminate": local.isIndeterminate ? "" : undefined
    };
  });
  const context = {
    dataset,
    value,
    valuePercent,
    valueLabel,
    labelId,
    progressFillWidth,
    generateId: createGenerateId(() => others.id),
    registerLabelId: createRegisterId(setLabelId)
  };
  return createComponent(ProgressContext.Provider, {
    value: context,
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        role: "progressbar",
        get ["aria-valuenow"]() {
          return memo(() => !!local.isIndeterminate)() ? undefined : value();
        },
        get ["aria-valuemin"]() {
          return local.minValue;
        },
        get ["aria-valuemax"]() {
          return local.maxValue;
        },
        get ["aria-valuetext"]() {
          return valueLabel();
        },
        get ["aria-labelledby"]() {
          return labelId();
        }
      }, dataset, others));
    }
  });
});

/**
 * The component that visually represents the progress track.
 * Act as a container for `Progress.Fill`.
 */
const ProgressTrack = createPolymorphicComponent(props => {
  const context = useProgressContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

/**
 * The accessible label text representing the current value in a human-readable format.
 */
const ProgressValueLabel = createPolymorphicComponent(props => {
  const context = useProgressContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get children() {
      return context.valueLabel();
    }
  }, () => context.dataset(), others));
});

var index$6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Fill: ProgressFill,
  Label: ProgressLabel,
  Root: ProgressRoot,
  Track: ProgressTrack,
  ValueLabel: ProgressValueLabel
});

const RadioGroupContext = createContext();
function useRadioGroupContext() {
  const context = useContext(RadioGroupContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupContext` must be used within a `RadioGroup` component");
  }
  return context;
}

const RadioGroupItemContext = createContext();
function useRadioGroupItemContext() {
  const context = useContext(RadioGroupItemContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useRadioGroupItemContext` must be used within a `RadioGroup.Item` component");
  }
  return context;
}

const _tmpl$$3 = /*#__PURE__*/template(`<label></label>`, 2);
/**
 * The root container for a radio button.
 */
function RadioGroupItem(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const defaultId = `${formControlContext.generateId("item")}-${createUniqueId()}`;
  props = mergeDefaultProps({
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["value", "isDisabled", ...PRESS_HANDLERS_PROP_NAMES, ...HOVER_HANDLERS_PROP_NAMES]);
  const [isFocused, setIsFocused] = createSignal(false);
  const [isFocusVisible, setIsFocusVisible] = createSignal(false);
  const isSelected = createMemo(() => {
    return radioGroupContext.isSelectedValue(local.value);
  });
  const isDisabled = createMemo(() => {
    return local.isDisabled || formControlContext.isDisabled() || false;
  });
  const {
    isPressed,
    pressHandlers
  } = createPress({
    isDisabled,
    preventFocusOnPress: () => isFocused() // For consistency with native, prevent the input blurs.
  });

  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled
  });
  const dataset = createMemo(() => ({
    "data-valid": formControlContext.dataset()["data-valid"],
    "data-invalid": formControlContext.dataset()["data-invalid"],
    "data-checked": isSelected() ? "" : undefined,
    "data-disabled": isDisabled() ? "" : undefined,
    "data-hover": isHovered() ? "" : undefined,
    "data-focus": isFocused() ? "" : undefined,
    "data-focus-visible": isFocusVisible() ? "" : undefined,
    "data-active": isPressed() ? "" : undefined
  }));
  const context = {
    value: () => local.value,
    dataset,
    isSelected,
    isDisabled,
    generateId: createGenerateId(() => others.id),
    setIsFocused,
    setIsFocusVisible
  };
  return createComponent(RadioGroupItemContext.Provider, {
    value: context,
    get children() {
      const _el$ = _tmpl$$3.cloneNode(true);
      spread(_el$, mergeProps$1(() => context.dataset(), {
        get onKeyDown() {
          return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
        },
        get onKeyUp() {
          return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
        },
        get onClick() {
          return composeEventHandlers([local.onClick, pressHandlers.onClick]);
        },
        get onPointerDown() {
          return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown]);
        },
        get onPointerUp() {
          return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
        },
        get onDragStart() {
          return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
        },
        get onPointerEnter() {
          return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
        },
        get onPointerLeave() {
          return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
        }
      }, others), false, false);
      return _el$;
    }
  });
}

/**
 * The element that visually represents a radio button.
 */
const RadioGroupItemControl = createPolymorphicComponent(props => {
  const context = useRadioGroupItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

/**
 * The visual indicator rendered when the radio item is in a checked state.
 * You can style this element directly, or you can use it as a wrapper to put an icon into, or both.
 */
const RadioGroupItemIndicator = createPolymorphicComponent(props => {
  const context = useRadioGroupItemContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("indicator")
  }, props);
  const [local, others] = splitProps(props, ["as", "forceMount"]);
  return createComponent(Show, {
    get when() {
      return local.forceMount || context.isSelected();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        }
      }, () => context.dataset(), others));
    }
  });
});

const _tmpl$$2 = /*#__PURE__*/template(`<input type="radio">`, 1);
/**
 * The native html input that is visually hidden in the radio button.
 */
function RadioGroupItemInput(props) {
  const formControlContext = useFormControlContext();
  const radioGroupContext = useRadioGroupContext();
  const radioContext = useRadioGroupItemContext();
  props = mergeDefaultProps({
    id: radioContext.generateId("input")
  }, props);
  const [local, others] = splitProps(props, ["style", "onChange", "aria-labelledby", "aria-describedby", ...PRESS_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const {
    pressHandlers
  } = createPress({
    isDisabled: radioContext.isDisabled
  });
  const {
    focusRingHandlers
  } = createFocusRing({
    onFocusChange: value => radioContext.setIsFocused(value),
    onFocusVisibleChange: value => radioContext.setIsFocusVisible(value)
  });
  const ariaLabelledBy = () => {
    return [local["aria-labelledby"],
    // If there is both an aria-label and aria-labelledby, add the input itself has an aria-labelledby
    local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined].filter(Boolean).join(" ") || undefined;
  };
  const ariaDescribedBy = () => {
    return [local["aria-describedby"], radioGroupContext.ariaDescribedBy()].filter(Boolean).join(" ") || undefined;
  };
  const onChange = e => {
    callHandler(e, local.onChange);
    e.stopPropagation();
    radioGroupContext.setSelectedValue(radioContext.value());
    const target = e.target;

    // Unlike in React, inputs `checked` state can be out of sync with our state.
    // for example a readonly `<input type="radio" />` is always "checkable".
    //
    // Also, even if an input is controlled (ex: `<input type="radio" checked={isChecked} />`,
    // clicking on the input will change its internal `checked` state.
    //
    // To prevent this, we need to force the input `checked` state to be in sync with our state.
    target.checked = radioContext.isSelected();
  };
  return (() => {
    const _el$ = _tmpl$$2.cloneNode(true);
    _el$.addEventListener("change", onChange);
    spread(_el$, mergeProps$1({
      get name() {
        return formControlContext.name();
      },
      get value() {
        return radioContext.value();
      },
      get checked() {
        return radioContext.isSelected();
      },
      get required() {
        return formControlContext.isRequired();
      },
      get disabled() {
        return radioContext.isDisabled();
      },
      get readonly() {
        return formControlContext.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-labelledby"]() {
        return ariaLabelledBy();
      },
      get ["aria-describedby"]() {
        return ariaDescribedBy();
      },
      get onKeyDown() {
        return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
      },
      get onKeyUp() {
        return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
      },
      get onClick() {
        return composeEventHandlers([local.onClick, pressHandlers.onClick]);
      },
      get onPointerDown() {
        return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown]);
      },
      get onPointerUp() {
        return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
      },
      get onMouseDown() {
        return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
      },
      get onDragStart() {
        return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
      },
      get onFocusIn() {
        return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
      },
      get onFocusOut() {
        return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
      }
    }, others), false, false);
    return _el$;
  })();
}

/**
 * The label that gives the user information on the radio button.
 */
const RadioGroupItemLabel = createPolymorphicComponent(props => {
  const context = useRadioGroupItemContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

/**
 * The label that gives the user information on the radio group.
 */
const RadioGroupLabel = createPolymorphicComponent(props => {
  return createComponent(FormControlLabel, mergeProps$1({
    as: "span"
  }, props));
});

/**
 * A set of checkable buttons, known as radio buttons, where no more than one of the buttons can be checked at a time.
 * This component is based on the [WAI-ARIA Radio Group Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/)
 */
const RadioGroupRoot = createPolymorphicComponent(props => {
  let ref;
  const defaultId = `radiogroup-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId,
    orientation: "vertical"
  }, props);
  const [local, formControlProps, others] = splitProps(props, ["as", "ref", "value", "defaultValue", "onValueChange", "orientation", "aria-labelledby", "aria-describedby"], FORM_CONTROL_PROP_NAMES);
  const [selected, setSelected] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onValueChange?.(value)
  });
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setSelected(local.defaultValue ?? ""));
  const ariaLabelledBy = () => {
    return formControlContext.getAriaLabelledBy(access(formControlProps.id), others["aria-label"], local["aria-labelledby"]);
  };
  const ariaDescribedBy = () => {
    return formControlContext.getAriaDescribedBy(local["aria-describedby"]);
  };
  const isSelectedValue = value => {
    return value === selected();
  };
  const context = {
    ariaDescribedBy,
    isSelectedValue,
    setSelectedValue: value => {
      if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
        return;
      }
      setSelected(value);

      // Sync all radio input checked state in the group with the selected value.
      // This is necessary because checked state might be out of sync
      // (ex: when using controlled radio-group).
      ref?.querySelectorAll("[type='radio']").forEach(el => {
        const radio = el;
        radio.checked = isSelectedValue(radio.value);
      });
    }
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(RadioGroupContext.Provider, {
        value: context,
        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            },
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            get id() {
              return access(formControlProps.id);
            },
            role: "radiogroup",
            get ["aria-invalid"]() {
              return formControlContext.validationState() === "invalid" || undefined;
            },
            get ["aria-required"]() {
              return formControlContext.isRequired() || undefined;
            },
            get ["aria-disabled"]() {
              return formControlContext.isDisabled() || undefined;
            },
            get ["aria-readonly"]() {
              return formControlContext.isReadOnly() || undefined;
            },
            get ["aria-orientation"]() {
              return local.orientation;
            },
            get ["aria-labelledby"]() {
              return ariaLabelledBy();
            },
            get ["aria-describedby"]() {
              return ariaDescribedBy();
            }
          }, () => formControlContext.dataset(), others));
        }
      });
    }
  });
});

var index$5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  Item: RadioGroupItem,
  ItemControl: RadioGroupItemControl,
  ItemIndicator: RadioGroupItemIndicator,
  ItemInput: RadioGroupItemInput,
  ItemLabel: RadioGroupItemLabel,
  Label: RadioGroupLabel,
  Root: RadioGroupRoot
});

/**
 * Displays one or more date grids and allows users to select a contiguous range of dates.
 */
const RangeCalendarRoot = createPolymorphicComponent(props => {
  let ref;
  const {
    locale: defaultLocale
  } = useLocale();
  props = mergeDefaultProps({
    visibleMonths: 1
  }, props);
  const [local, calendarProps, others] = splitProps(props, ["ref", "value", "defaultValue", "onValueChange", "allowsNonContiguousRanges", "locale", "visibleMonths", "minValue", "maxValue", "onBlur"], ["createCalendar", "isDateUnavailable", "isDisabled", "isReadOnly", "autoFocus", "focusedValue", "defaultFocusedValue", "onFocusChange", "validationState"]);
  const locale = () => local.locale ?? defaultLocale();
  const [selectedRange, setSelectedRange] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onValueChange?.(value)
  });
  const [anchorDate, setAnchorDateState] = createSignal();

  // Available range must be stored in a ref, so we have access to the updated version immediately in `isInvalid`.
  let availableRangeRef;
  const [availableRange, setAvailableRange] = createSignal();
  const [isDragging, setDragging] = createSignal(false);
  const alignment = createMemo(() => {
    const visibleDuration = {
      months: access(local.visibleMonths)
    };
    const value = selectedRange();
    if (value && value.start && value.end) {
      const start = alignCenter(toCalendarDate(value.start), visibleDuration, locale(), access(local.minValue), access(local.maxValue));
      const end = start.add(visibleDuration).subtract({
        days: 1
      });
      if (value.end.compare(end) > 0) {
        return "start";
      }
    }
    return "center";
  });
  const min = createMemo(() => {
    const minValue = access(local.minValue);
    const rangeStart = availableRange()?.start;
    return maxDate(minValue, rangeStart);
  });
  const max = createMemo(() => {
    const maxValue = access(local.maxValue);
    const rangeEnd = availableRange()?.end;
    return minDate(maxValue, rangeEnd);
  });
  const createCalendarStateProps = mergeProps(calendarProps, {
    value: () => selectedRange()?.start,
    locale,
    visibleMonths: () => access(local.visibleMonths),
    minValue: min,
    maxValue: max,
    selectionAlignment: alignment
  });
  const calendar = createCalendarState(createCalendarStateProps);
  const updateAvailableRange = date => {
    if (date && calendarProps.isDateUnavailable && !local.allowsNonContiguousRanges) {
      availableRangeRef = {
        start: nextUnavailableDate(date, calendar, -1),
        end: nextUnavailableDate(date, calendar, 1)
      };
      setAvailableRange(availableRangeRef);
    } else {
      availableRangeRef = undefined;
      setAvailableRange(undefined);
    }
  };
  let lastVisibleRange = calendar.visibleRange();

  // If the visible range changes, we need to update the available range.
  createEffect(() => {
    const visibleRange = calendar.visibleRange();
    if (!isEqualDay(visibleRange.start, lastVisibleRange.start) || !isEqualDay(visibleRange.end, lastVisibleRange.end)) {
      updateAvailableRange(anchorDate());
      lastVisibleRange = calendar.visibleRange();
    }
  });
  const setAnchorDate = date => {
    if (date) {
      setAnchorDateState(date);
      updateAvailableRange(date);
    } else {
      setAnchorDateState(undefined);
      updateAvailableRange(undefined);
    }
  };
  const highlightedRange = createMemo(() => {
    const anchor = anchorDate();
    const value = selectedRange();
    if (anchor) {
      return makeRange(anchor, calendar.focusedDate());
    } else if (value) {
      return makeRange(value.start, value.end);
    }
  });
  const selectDate = newDate => {
    if (access(calendarProps.isReadOnly)) {
      return;
    }
    let date = constrainValue(newDate, min(), max());
    date = previousAvailableDate(date, calendar.visibleRange().start, calendarProps.isDateUnavailable);
    if (!date) {
      return;
    }
    const anchor = anchorDate();
    const value = selectedRange();
    if (!anchor) {
      setAnchorDate(date);
    } else {
      const range = makeRange(anchor, date);
      if (range) {
        setSelectedRange({
          start: convertValue(range.start, value?.start),
          end: convertValue(range.end, value?.end)
        });
      }
      setAnchorDate(undefined);
    }
  };
  const isInvalidSelection = createMemo(() => {
    const anchor = anchorDate();
    const value = selectedRange();
    const isDateUnavailable = calendarProps.isDateUnavailable;
    if (!value || anchor) {
      return false;
    }
    if (isDateUnavailable && (isDateUnavailable(value.start) || isDateUnavailable(value.end))) {
      return true;
    }
    const minValue = access(local.minValue);
    const maxValue = access(local.maxValue);
    return isInvalid(value.start, minValue, maxValue) || isInvalid(value.end, minValue, maxValue);
  });
  const validationState = () => {
    return access(calendarProps.validationState) || (isInvalidSelection() ? "invalid" : undefined);
  };
  const state = mergeProps(calendar, {
    value: () => selectedRange(),
    setValue: setSelectedRange,
    anchorDate,
    setAnchorDate,
    highlightedRange,
    validationState,
    selectFocusedDate() {
      selectDate(calendar.focusedDate());
    },
    selectDate,
    highlightDate(date) {
      if (anchorDate()) {
        calendar.setFocusedDate(date);
      }
    },
    isSelected(date) {
      const highlighted = highlightedRange();
      return highlighted != null && date.compare(highlighted.start) >= 0 && date.compare(highlighted.end) <= 0 && !calendar.isCellDisabled(date) && !calendar.isCellUnavailable(date);
    },
    isInvalid(date) {
      return calendar.isInvalid(date) || isInvalid(date, availableRangeRef?.start, availableRangeRef?.end);
    },
    isDragging,
    setDragging
  });
  let isVirtualClick = false;

  // We need to ignore virtual pointer events from VoiceOver due to these bugs.
  // https://bugs.webkit.org/show_bug.cgi?id=222627
  // https://bugs.webkit.org/show_bug.cgi?id=223202
  // createPress also does this and waits for the following click event before firing.
  // We need to match that here otherwise this will fire before the press event in
  // Calendar.Day, causing range selection to not work properly.
  const onGlobalPointerDown = e => {
    isVirtualClick = e.width === 0 && e.height === 0;
  };

  // Stop range selection when pressing or releasing a pointer outside the calendar body,
  // except when pressing the next or previous buttons to switch months.
  const onGlobalEndDragging = e => {
    if (isVirtualClick) {
      isVirtualClick = false;
      return;
    }
    setDragging(false);
    if (!anchorDate()) {
      return;
    }
    const target = e.target;
    if (ref && contains(ref, getActiveElement()) && (!contains(ref, target) || !target.closest('button, [role="button"]'))) {
      state.selectFocusedDate();
    }
  };

  // Prevent touch scrolling while dragging
  const onTouchMove = e => {
    if (isDragging()) {
      e.preventDefault();
    }
  };
  onMount(() => {
    const window = getWindow();
    window.addEventListener("pointerdown", onGlobalPointerDown);
    window.addEventListener("pointerup", onGlobalEndDragging);
    window.addEventListener("pointercancel", onGlobalEndDragging);
    ref?.addEventListener("touchmove", onTouchMove, {
      passive: false,
      capture: true
    });
    onCleanup(() => {
      window.removeEventListener("pointerdown", onGlobalPointerDown);
      window.removeEventListener("pointerup", onGlobalEndDragging);
      window.removeEventListener("pointercancel", onGlobalEndDragging);

      // @ts-ignore
      ref?.removeEventListener("touchmove", onTouchMove, {
        passive: false,
        capture: true
      });
    });
  });

  // Also stop range selection on blur, e.g. tabbing away from the calendar.
  const onBlur = e => {
    callHandler(e, local.onBlur);
    const relatedTarget = e.relatedTarget;
    if ((!relatedTarget || !contains(ref, relatedTarget)) && anchorDate()) {
      state.selectFocusedDate();
    }
  };
  return createComponent(CalendarBase, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    state: state,
    get isDisabled() {
      return access(calendarProps.isDisabled);
    },
    onBlur: onBlur
  }, others));
});
function makeRange(start, end) {
  if (!start || !end) {
    return undefined;
  }
  if (end.compare(start) < 0) {
    [start, end] = [end, start];
  }
  return {
    start: toCalendarDate(start),
    end: toCalendarDate(end)
  };
}
function convertValue(newValue, oldValue) {
  // The display calendar should not have any effect on the emitted value.
  // Emit dates in the same calendar as the original value, if any, otherwise gregorian.
  newValue = toCalendar(newValue, oldValue?.calendar || new GregorianCalendar());

  // Preserve time if the input value had one.
  if (oldValue && "hour" in oldValue) {
    return oldValue.set(newValue);
  }
  return newValue;
}
function nextUnavailableDate(anchorDate, state, dir) {
  let nextDate = anchorDate.add({
    days: dir
  });
  while ((dir < 0 ? nextDate.compare(state.visibleRange().start) >= 0 : nextDate.compare(state.visibleRange().end) <= 0) && !state.isCellUnavailable(nextDate)) {
    nextDate = nextDate.add({
      days: dir
    });
  }
  if (state.isCellUnavailable(nextDate)) {
    return nextDate.add({
      days: -dir
    });
  }
  return undefined;
}

var index$4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Cell: CalendarCell,
  Day: CalendarDay,
  Grid: CalendarGrid,
  GridBody: CalendarGridBody,
  GridHeader: CalendarGridHeader,
  Header: CalendarHeader,
  Month: CalendarMonth,
  NextPageButton: CalendarNextPageButton,
  PrevPageButton: CalendarPrevPageButton,
  Root: RangeCalendarRoot,
  Row: CalendarRow,
  Title: CalendarTitle,
  WeekDay: CalendarWeekDay,
  WeekDays: CalendarWeekDays
});

const SwitchContext = createContext();
function useSwitchContext() {
  const context = useContext(SwitchContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useSwitchContext` must be used within a `Switch` component");
  }
  return context;
}

/**
 * The element that visually represents a switch.
 */
const SwitchControl = createPolymorphicComponent(props => {
  const context = useSwitchContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("control")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

const _tmpl$$1 = /*#__PURE__*/template(`<input type="checkbox" role="switch">`, 1);
/**
 * The native html input that is visually hidden in the switch.
 */
function SwitchInput(props) {
  const context = useSwitchContext();
  props = mergeDefaultProps({
    id: context.generateId("input")
  }, props);
  const [local, others] = splitProps(props, ["style", "onChange", "aria-labelledby", ...PRESS_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const {
    pressHandlers
  } = createPress({
    isDisabled: context.isDisabled
  });
  const {
    focusRingHandlers
  } = createFocusRing({
    onFocusChange: value => context.setIsFocused(value),
    onFocusVisibleChange: value => context.setIsFocusVisible(value)
  });
  const ariaLabelledBy = () => {
    return [local["aria-labelledby"],
    // If there is both an aria-label and aria-labelledby, add the input itself has an aria-labelledby
    local["aria-labelledby"] != null && others["aria-label"] != null ? others.id : undefined].filter(Boolean).join(" ") || undefined;
  };
  const onChange = e => {
    callHandler(e, local.onChange);
    e.stopPropagation();
    const target = e.target;
    context.setIsChecked(target.checked);

    // Unlike in React, inputs `checked` state can be out of sync with our toggle state.
    // for example a readonly `<input type="checkbox" />` is always "checkable".
    //
    // Also, even if an input is controlled (ex: `<input type="checkbox" checked={isChecked} />`,
    // clicking on the input will change its internal `checked` state.
    //
    // To prevent this, we need to force the input `checked` state to be in sync with the toggle state.
    target.checked = context.isChecked();
  };
  return (() => {
    const _el$ = _tmpl$$1.cloneNode(true);
    _el$.addEventListener("change", onChange);
    spread(_el$, mergeProps$1({
      get name() {
        return context.name();
      },
      get value() {
        return context.value();
      },
      get checked() {
        return context.isChecked();
      },
      get required() {
        return context.isRequired();
      },
      get disabled() {
        return context.isDisabled();
      },
      get readonly() {
        return context.isReadOnly();
      },
      get style() {
        return {
          ...visuallyHiddenStyles,
          ...local.style
        };
      },
      get ["aria-labelledby"]() {
        return ariaLabelledBy();
      },
      get ["aria-invalid"]() {
        return context.validationState() === "invalid" || undefined;
      },
      get ["aria-required"]() {
        return context.isRequired() || undefined;
      },
      get ["aria-disabled"]() {
        return context.isDisabled() || undefined;
      },
      get ["aria-readonly"]() {
        return context.isReadOnly() || undefined;
      },
      get onKeyDown() {
        return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
      },
      get onKeyUp() {
        return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
      },
      get onClick() {
        return composeEventHandlers([local.onClick, pressHandlers.onClick]);
      },
      get onPointerDown() {
        return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown]);
      },
      get onPointerUp() {
        return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
      },
      get onMouseDown() {
        return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
      },
      get onDragStart() {
        return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
      },
      get onFocusIn() {
        return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
      },
      get onFocusOut() {
        return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
      }
    }, others), false, false);
    return _el$;
  })();
}

/**
 * The label that gives the user information on the switch.
 */
const SwitchLabel = createPolymorphicComponent(props => {
  const context = useSwitchContext();
  props = mergeDefaultProps({
    as: "span",
    id: context.generateId("label")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

const _tmpl$ = /*#__PURE__*/template(`<label></label>`, 2);
/**
 * A control that allows users to choose one of two values: on or off.
 */
const SwitchRoot = props => {
  let ref;
  const defaultId = `switch-${createUniqueId()}`;
  props = mergeDefaultProps({
    value: "on",
    id: defaultId
  }, props);
  const [local, others] = splitProps(props, ["ref", "value", "isChecked", "defaultIsChecked", "onCheckedChange", "name", "value", "validationState", "isRequired", "isDisabled", "isReadOnly", ...PRESS_HANDLERS_PROP_NAMES, ...HOVER_HANDLERS_PROP_NAMES]);
  const [isFocused, setIsFocused] = createSignal(false);
  const [isFocusVisible, setIsFocusVisible] = createSignal(false);
  const state = createToggleState({
    isSelected: () => local.isChecked,
    defaultIsSelected: () => local.defaultIsChecked,
    onSelectedChange: selected => local.onCheckedChange?.(selected),
    isDisabled: () => local.isDisabled,
    isReadOnly: () => local.isReadOnly
  });
  createFormResetListener(() => ref, () => state.setIsSelected(local.defaultIsChecked ?? false));
  const {
    isPressed,
    pressHandlers
  } = createPress({
    isDisabled: () => local.isDisabled,
    preventFocusOnPress: () => isFocused() // For consistency with native, prevent the input blurs.
  });

  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled: () => local.isDisabled
  });
  const dataset = createMemo(() => ({
    "data-valid": local.validationState === "valid" ? "" : undefined,
    "data-invalid": local.validationState === "invalid" ? "" : undefined,
    "data-checked": state.isSelected() ? "" : undefined,
    "data-required": local.isRequired ? "" : undefined,
    "data-disabled": local.isDisabled ? "" : undefined,
    "data-readonly": local.isReadOnly ? "" : undefined,
    "data-hover": isHovered() ? "" : undefined,
    "data-focus": isFocused() ? "" : undefined,
    "data-focus-visible": isFocusVisible() ? "" : undefined,
    "data-active": isPressed() ? "" : undefined
  }));
  const context = {
    name: () => local.name ?? others.id,
    value: () => local.value,
    dataset,
    validationState: () => local.validationState,
    isChecked: () => state.isSelected(),
    isRequired: () => local.isRequired,
    isDisabled: () => local.isDisabled,
    isReadOnly: () => local.isReadOnly,
    generateId: part => `${others.id}-${part}`,
    setIsChecked: isChecked => state.setIsSelected(isChecked),
    setIsFocused,
    setIsFocusVisible
  };
  return createComponent(SwitchContext.Provider, {
    value: context,
    get children() {
      const _el$ = _tmpl$.cloneNode(true);
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && use(_ref$, _el$);
      spread(_el$, mergeProps$1({
        get onKeyDown() {
          return composeEventHandlers([local.onKeyDown, pressHandlers.onKeyDown]);
        },
        get onKeyUp() {
          return composeEventHandlers([local.onKeyUp, pressHandlers.onKeyUp]);
        },
        get onClick() {
          return composeEventHandlers([local.onClick, pressHandlers.onClick]);
        },
        get onPointerDown() {
          return composeEventHandlers([local.onPointerDown, pressHandlers.onPointerDown]);
        },
        get onPointerUp() {
          return composeEventHandlers([local.onPointerUp, pressHandlers.onPointerUp]);
        },
        get onMouseDown() {
          return composeEventHandlers([local.onMouseDown, pressHandlers.onMouseDown]);
        },
        get onDragStart() {
          return composeEventHandlers([local.onDragStart, pressHandlers.onDragStart]);
        },
        get onPointerEnter() {
          return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
        },
        get onPointerLeave() {
          return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
        }
      }, () => context.dataset(), others), false, false);
      return _el$;
    }
  });
};

/**
 * The thumb that is used to visually indicate whether the switch is on or off.
 */
const SwitchThumb = createPolymorphicComponent(props => {
  const context = useSwitchContext();
  props = mergeDefaultProps({
    as: "div",
    id: context.generateId("thumb")
  }, props);
  const [local, others] = splitProps(props, ["as"]);
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    }
  }, () => context.dataset(), others));
});

var index$3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Control: SwitchControl,
  Input: SwitchInput,
  Label: SwitchLabel,
  Root: SwitchRoot,
  Thumb: SwitchThumb
});

const TabsContext = createContext();
function useTabsContext() {
  const context = useContext(TabsContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTabsContext` must be used within a `Tabs` component");
  }
  return context;
}

/**
 * Contains the content associated with a tab trigger.
 */
const TabsContent = createPolymorphicComponent(props => {
  let ref;
  const context = useTabsContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "id", "value", "forceMount", ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const [tabIndex, setTabIndex] = createSignal(0);
  const id = () => local.id ?? context.generateContentId(local.value);
  const isSelected = () => context.listState().selectedKey() === local.value;
  const shouldMount = () => local.forceMount || isSelected();
  const {
    isFocused,
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  createEffect(on([() => ref, shouldMount], ([ref, shouldMount]) => {
    if (ref == null || !shouldMount) {
      return;
    }
    const updateTabIndex = () => {
      // Detect if there are any tabbable elements and update the tabIndex accordingly.
      const walker = getFocusableTreeWalker(ref, {
        tabbable: true
      });
      setTabIndex(walker.nextNode() ? undefined : 0);
    };
    updateTabIndex();
    const observer = new MutationObserver(updateTabIndex);

    // Update when new elements are inserted, or the tabIndex/disabled attribute updates.
    observer.observe(ref, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["tabIndex", "disabled"]
    });
    onCleanup(() => {
      observer.disconnect();
    });
  }));
  createEffect(on([() => local.value, id], ([value, id]) => {
    context.contentIdsMap().set(value, id);
  }));
  return createComponent(Show, {
    get when() {
      return shouldMount();
    },
    get children() {
      return createComponent(Dynamic, mergeProps$1({
        get component() {
          return local.as;
        },
        ref(r$) {
          const _ref$ = mergeRefs(el => ref = el, local.ref);
          typeof _ref$ === "function" && _ref$(r$);
        },
        get id() {
          return id();
        },
        role: "tabpanel",
        get tabIndex() {
          return tabIndex();
        },
        get ["aria-labelledby"]() {
          return context.triggerIdsMap().get(local.value);
        },
        get ["data-orientation"]() {
          return context.orientation();
        },
        get ["data-focus"]() {
          return isFocused() ? "" : undefined;
        },
        get ["data-focus-visible"]() {
          return isFocusVisible() ? "" : undefined;
        },
        get onFocusIn() {
          return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
        },
        get onFocusOut() {
          return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
        }
      }, others));
    }
  });
});

/**
 * The visual indicator displayed at the bottom of the tab list to indicate the selected tab.
 * It provides the base style needed to display a smooth transition to the new selected tab.
 */
const TabsIndicator = createPolymorphicComponent(props => {
  const context = useTabsContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "style"]);
  const [style, setStyle] = createSignal({
    width: undefined,
    height: undefined
  });
  const {
    direction
  } = useLocale();
  const computeStyle = () => {
    const selectedTab = context.selectedTab();
    if (selectedTab == null) {
      return;
    }
    const styleObj = {
      transform: undefined,
      width: undefined,
      height: undefined
    };

    // In RTL, calculate the transform from the right edge of the tab list
    // so that resizing the window doesn't break the TabIndicator position due to offsetLeft changes
    const offset = direction() === "rtl" ? -1 * (selectedTab.offsetParent?.offsetWidth - selectedTab.offsetWidth - selectedTab.offsetLeft) : selectedTab.offsetLeft;
    styleObj.transform = context.orientation() === "vertical" ? `translateY(${selectedTab.offsetTop}px)` : `translateX(${offset}px)`;
    if (context.orientation() === "horizontal") {
      styleObj.width = `${selectedTab.offsetWidth}px`;
    } else {
      styleObj.height = `${selectedTab.offsetHeight}px`;
    }
    setStyle(styleObj);
  };

  // For the first run, wait for all tabs to be mounted and registered in tabs DOM collection
  // before computing the style.
  onMount(() => {
    queueMicrotask(() => {
      computeStyle();
    });
  });

  // Compute style normally for subsequent runs.
  createEffect(on([context.selectedTab, context.orientation, direction], () => {
    computeStyle();
  }, {
    defer: true
  }));
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    role: "presentation",
    get style() {
      return {
        ...style(),
        ...local.style
      };
    },
    get ["data-orientation"]() {
      return context.orientation();
    }
  }, others));
});

/*!
 * Portions of this file are based on code from react-spectrum.
 * Apache License Version 2.0, Copyright 2020 Adobe.
 *
 * Credits to the React Spectrum team:
 * https://github.com/adobe/react-spectrum/blob/6b51339cca0b8344507d3c8e81e7ad05d6e75f9b/packages/@react-aria/tabs/src/TabsKeyboardDelegate.ts
 */

class TabsKeyboardDelegate {
  constructor(collection, direction, orientation) {
    _defineProperty(this, "collection", void 0);
    _defineProperty(this, "direction", void 0);
    _defineProperty(this, "orientation", void 0);
    this.collection = collection;
    this.direction = direction;
    this.orientation = orientation;
  }
  flipDirection() {
    return this.direction() === "rtl" && this.orientation() === "horizontal";
  }
  getKeyLeftOf(key) {
    if (this.flipDirection()) {
      return this.getNextKey(key);
    } else {
      if (this.orientation() === "horizontal") {
        return this.getPreviousKey(key);
      }
      return undefined;
    }
  }
  getKeyRightOf(key) {
    if (this.flipDirection()) {
      return this.getPreviousKey(key);
    } else {
      if (this.orientation() === "horizontal") {
        return this.getNextKey(key);
      }
      return undefined;
    }
  }
  getKeyAbove(key) {
    if (this.orientation() === "vertical") {
      return this.getPreviousKey(key);
    }
    return undefined;
  }
  getKeyBelow(key) {
    if (this.orientation() === "vertical") {
      return this.getNextKey(key);
    }
    return undefined;
  }
  getFirstKey() {
    let key = this.collection().getFirstKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.isDisabled) {
      key = this.getNextKey(key);
    }
    return key;
  }
  getLastKey() {
    let key = this.collection().getLastKey();
    if (key == null) {
      return;
    }
    const item = this.collection().getItem(key);
    if (item?.isDisabled) {
      key = this.getPreviousKey(key);
    }
    return key;
  }
  getNextKey(key) {
    let nextKey = key;
    let nextItem;
    do {
      nextKey = this.collection().getKeyAfter(nextKey) ?? this.collection().getFirstKey();
      if (nextKey == null) {
        return;
      }
      nextItem = this.collection().getItem(nextKey);
      if (nextItem == null) {
        return;
      }
    } while (nextItem.isDisabled);
    return nextKey;
  }
  getPreviousKey(key) {
    let previousKey = key;
    let previousItem;
    do {
      previousKey = this.collection().getKeyBefore(previousKey) ?? this.collection().getLastKey();
      if (previousKey == null) {
        return;
      }
      previousItem = this.collection().getItem(previousKey);
      if (previousItem == null) {
        return;
      }
    } while (previousItem.isDisabled);
    return previousKey;
  }
}

/**
 * Contains the tabs that are aligned along the edge of the active tab panel.
 */
const TabsList = createPolymorphicComponent(props => {
  let ref;
  const context = useTabsContext();
  props = mergeDefaultProps({
    as: "div"
  }, props);
  const [local, others] = splitProps(props, ["as", "ref", "onKeyDown", "onMouseDown", "onFocusIn", "onFocusOut"]);
  const {
    direction
  } = useLocale();
  const delegate = new TabsKeyboardDelegate(() => context.listState().collection(), direction, context.orientation);
  const selectableCollection = createSelectableCollection({
    selectionManager: () => context.listState().selectionManager(),
    keyboardDelegate: () => delegate,
    selectOnFocus: () => context.activationMode() === "automatic",
    shouldFocusWrap: false,
    // handled by the keyboard delegate
    disallowEmptySelection: true
  }, () => ref);
  createEffect(() => {
    if (ref == null) {
      return;
    }
    const selectedTab = ref.querySelector(`[data-key="${context.listState().selectedKey()}"]`);
    if (selectedTab != null) {
      context.setSelectedTab(selectedTab);
    }
  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    role: "tablist",
    get ["aria-orientation"]() {
      return context.orientation();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get onKeyDown() {
      return composeEventHandlers([local.onKeyDown, selectableCollection.handlers.onKeyDown]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableCollection.handlers.onMouseDown]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, selectableCollection.handlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, selectableCollection.handlers.onFocusOut]);
    }
  }, others));
});

/**
 * A set of layered sections of content, known as tab panels, that display one panel of content at a time.
 * `Tabs` contains all the parts of a tabs component and provide context for its children.
 */
const TabsRoot = createPolymorphicComponent(props => {
  const defaultId = `tabs-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId,
    orientation: "horizontal",
    activationMode: "automatic"
  }, props);
  const [local, others] = splitProps(props, ["as", "value", "defaultValue", "onValueChange", "orientation", "activationMode", "isDisabled"]);
  const [items, setItems] = createSignal([]);
  const [selectedTab, setSelectedTab] = createSignal();
  const {
    DomCollectionProvider
  } = createDomCollection({
    items,
    onItemsChange: setItems
  });
  const listState = createSingleSelectListState({
    selectedKey: () => local.value,
    defaultSelectedKey: () => local.defaultValue,
    onSelectionChange: key => local.onValueChange?.(String(key)),
    dataSource: items
  });
  let lastSelectedKey = listState.selectedKey();
  createEffect(on([() => listState.selectionManager(), () => listState.collection(), () => listState.selectedKey()], ([selectionManager, collection, currentSelectedKey]) => {
    let selectedKey = currentSelectedKey;

    // Ensure a tab is always selected (in case no selected key was specified or if selected item was deleted from collection)
    if (selectionManager.isEmpty() || selectedKey == null || !collection.getItem(selectedKey)) {
      selectedKey = collection.getFirstKey();
      let selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;

      // loop over tabs until we find one that isn't disabled and select that
      while (selectedItem?.isDisabled && selectedItem.key !== collection.getLastKey()) {
        selectedKey = collection.getKeyAfter(selectedItem.key);
        selectedItem = selectedKey != null ? collection.getItem(selectedKey) : undefined;
      }

      // if this check is true, then every item is disabled, it makes more sense to default to the first key than the last
      if (selectedItem?.isDisabled && selectedKey === collection.getLastKey()) {
        selectedKey = collection.getFirstKey();
      }

      // directly set selection because replace/toggle selection won't consider disabled keys
      if (selectedKey != null) {
        selectionManager.setSelectedKeys([selectedKey]);
      }
    }

    // If there isn't a focused key yet or the tabs doesn't have focus and the selected key changes,
    // change focused key to the selected key if it exists.
    if (selectionManager.focusedKey() == null || !selectionManager.isFocused() && selectedKey !== lastSelectedKey) {
      selectionManager.setFocusedKey(selectedKey);
    }
    lastSelectedKey = selectedKey;
  }));

  // associated value/trigger ids
  const triggerIdsMap = new Map();

  // associated value/content ids
  const contentIdsMap = new Map();
  const context = {
    isDisabled: () => local.isDisabled ?? false,
    orientation: () => local.orientation,
    activationMode: () => local.activationMode,
    triggerIdsMap: () => triggerIdsMap,
    contentIdsMap: () => contentIdsMap,
    listState: () => listState,
    selectedTab,
    setSelectedTab,
    generateTriggerId: value => `${others.id}-trigger-${value}`,
    generateContentId: value => `${others.id}-content-${value}`
  };
  return createComponent(DomCollectionProvider, {
    get children() {
      return createComponent(TabsContext.Provider, {
        value: context,
        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            },
            get ["data-orientation"]() {
              return context.orientation();
            }
          }, others));
        }
      });
    }
  });
});

/**
 * The button that activates its associated tab panel.
 */
const TabsTrigger = createPolymorphicComponent(props => {
  let ref;
  const context = useTabsContext();
  props = mergeDefaultProps({
    as: "button",
    type: "button"
  }, props);
  const [local, others] = splitProps(props, ["ref", "id", "value", "isDisabled", "onPressStart", "onPressUp", "onPress", "onLongPress", "onFocus", "onMouseDown", "onDragStart", ...HOVER_HANDLERS_PROP_NAMES, ...FOCUS_RING_HANDLERS_PROP_NAMES]);
  const id = () => local.id ?? context.generateTriggerId(local.value);
  const isFocused = () => context.listState().selectionManager().focusedKey() === local.value;
  const isDisabled = () => local.isDisabled || context.isDisabled();
  const contentId = () => context.contentIdsMap().get(local.value);
  createDomCollectionItem({
    getItem: () => ({
      ref: () => ref,
      key: local.value,
      label: "",
      // not applicable here
      textValue: "",
      // not applicable here
      isDisabled: isDisabled()
    })
  });
  const selectableItem = createSelectableItem({
    key: () => local.value,
    selectionManager: () => context.listState().selectionManager(),
    isDisabled
  }, () => ref);
  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled
  });
  const {
    isFocusVisible,
    focusRingHandlers
  } = createFocusRing();
  createEffect(on([() => local.value, id], ([value, id]) => {
    context.triggerIdsMap().set(value, id);
  }));
  return createComponent(Pressable, mergeProps$1({
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    },
    get id() {
      return id();
    },
    role: "tab",
    get tabIndex() {
      return memo(() => !!!isDisabled())() ? selectableItem.tabIndex() : undefined;
    },
    get isDisabled() {
      return isDisabled();
    },
    get preventFocusOnPress() {
      return selectableItem.preventFocusOnPress();
    },
    get ["aria-selected"]() {
      return selectableItem.isSelected();
    },
    get ["aria-controls"]() {
      return memo(() => !!selectableItem.isSelected())() ? contentId() : undefined;
    },
    get ["data-key"]() {
      return selectableItem.dataKey();
    },
    get ["data-orientation"]() {
      return context.orientation();
    },
    get ["data-selected"]() {
      return selectableItem.isSelected() ? "" : undefined;
    },
    get ["data-hover"]() {
      return isHovered() ? "" : undefined;
    },
    get ["data-focus"]() {
      return isFocused() ? "" : undefined;
    },
    get ["data-focus-visible"]() {
      return isFocusVisible() ? "" : undefined;
    },
    get onFocus() {
      return composeEventHandlers([local.onFocus, selectableItem.onFocus]);
    },
    get onPressStart() {
      return composeEventHandlers([local.onPressStart, selectableItem.onPressStart]);
    },
    get onPressUp() {
      return composeEventHandlers([local.onPressUp, selectableItem.onPressUp]);
    },
    get onPress() {
      return composeEventHandlers([local.onPress, selectableItem.onPress]);
    },
    get onLongPress() {
      return composeEventHandlers([local.onLongPress, selectableItem.onLongPress]);
    },
    get onMouseDown() {
      return composeEventHandlers([local.onMouseDown, selectableItem.onMouseDown]);
    },
    get onDragStart() {
      return composeEventHandlers([local.onDragStart, selectableItem.onDragStart]);
    },
    get onPointerEnter() {
      return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
    },
    get onPointerLeave() {
      return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
    }
  }, others));
});

var index$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Content: TabsContent,
  Indicator: TabsIndicator,
  List: TabsList,
  Root: TabsRoot,
  Trigger: TabsTrigger
});

const TextFieldContext = createContext();
function useTextFieldContext() {
  const context = useContext(TextFieldContext);
  if (context === undefined) {
    throw new Error("[kobalte]: `useTextFieldContext` must be used within a `TextField` component");
  }
  return context;
}

/**
 * The native html input of the textfield.
 */
function TextFieldInput(props) {
  return createComponent(TextFieldInputBase, mergeProps$1({
    type: "text"
  }, props));
}
const TextFieldInputBase = createPolymorphicComponent(props => {
  const formControlContext = useFormControlContext();
  const context = useTextFieldContext();
  props = mergeDefaultProps({
    as: "input",
    id: context.generateId("input")
  }, props);
  const [local, formControlFieldProps, others] = splitProps(props, ["as", "onInput", ...FOCUS_RING_HANDLERS_PROP_NAMES], FORM_CONTROL_FIELD_PROP_NAMES);
  const {
    fieldProps
  } = createFormControlField(formControlFieldProps);
  const {
    focusRingHandlers
  } = createFocusRing({
    isTextInput: true,
    onFocusChange: value => context.setIsFocused(value),
    onFocusVisibleChange: value => context.setIsFocusVisible(value)
  });
  return createComponent(Dynamic, mergeProps$1({
    get component() {
      return local.as;
    },
    get id() {
      return fieldProps.id();
    },
    get name() {
      return formControlContext.name();
    },
    get value() {
      return context.value();
    },
    get required() {
      return formControlContext.isRequired();
    },
    get disabled() {
      return formControlContext.isDisabled();
    },
    get readonly() {
      return formControlContext.isReadOnly();
    },
    get ["aria-label"]() {
      return fieldProps.ariaLabel();
    },
    get ["aria-labelledby"]() {
      return fieldProps.ariaLabelledBy();
    },
    get ["aria-describedby"]() {
      return fieldProps.ariaDescribedBy();
    },
    get ["aria-invalid"]() {
      return formControlContext.validationState() === "invalid" || undefined;
    },
    get ["aria-required"]() {
      return formControlContext.isRequired() || undefined;
    },
    get ["aria-disabled"]() {
      return formControlContext.isDisabled() || undefined;
    },
    get ["aria-readonly"]() {
      return formControlContext.isReadOnly() || undefined;
    },
    get onInput() {
      return composeEventHandlers([local.onInput, context.onInput]);
    },
    get onFocusIn() {
      return composeEventHandlers([local.onFocusIn, focusRingHandlers.onFocusIn]);
    },
    get onFocusOut() {
      return composeEventHandlers([local.onFocusOut, focusRingHandlers.onFocusOut]);
    }
  }, () => formControlContext.dataset(), () => context.dataset(), others));
});

/**
 * A text input that allow users to input custom text entries with a keyboard.
 */
const TextFieldRoot = createPolymorphicComponent(props => {
  let ref;
  const defaultId = `textfield-${createUniqueId()}`;
  props = mergeDefaultProps({
    as: "div",
    id: defaultId
  }, props);
  const [local, formControlProps, others] = splitProps(props, ["as", "ref", "value", "defaultValue", "onValueChange", ...HOVER_HANDLERS_PROP_NAMES], FORM_CONTROL_PROP_NAMES);
  const [value, setValue] = createControllableSignal({
    value: () => local.value,
    defaultValue: () => local.defaultValue,
    onChange: value => local.onValueChange?.(value)
  });
  const [isFocused, setIsFocused] = createSignal(false);
  const [isFocusVisible, setIsFocusVisible] = createSignal(false);
  const {
    formControlContext
  } = createFormControl(formControlProps);
  createFormResetListener(() => ref, () => setValue(local.defaultValue ?? ""));
  const {
    isHovered,
    hoverHandlers
  } = createHover({
    isDisabled: () => access(formControlProps.isDisabled)
  });
  const onInput = e => {
    if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
      return;
    }
    const target = e.target;
    setValue(target.value);

    // Unlike in React, inputs `value` can be out of sync with our value state.
    // even if an input is controlled (ex: `<input value="foo" />`,
    // typing on the input will change its internal `value`.
    //
    // To prevent this, we need to force the input `value` to be in sync with the textfield value state.
    target.value = value() ?? "";
  };
  const dataset = createMemo(() => ({
    "data-hover": isHovered() ? "" : undefined,
    "data-focus": isFocused() ? "" : undefined,
    "data-focus-visible": isFocusVisible() ? "" : undefined
  }));
  const context = {
    dataset,
    value,
    generateId: createGenerateId(() => access(formControlProps.id)),
    setIsFocused,
    setIsFocusVisible,
    onInput
  };
  return createComponent(FormControlContext.Provider, {
    value: formControlContext,
    get children() {
      return createComponent(TextFieldContext.Provider, {
        value: context,
        get children() {
          return createComponent(Dynamic, mergeProps$1({
            get component() {
              return local.as;
            },
            ref(r$) {
              const _ref$ = mergeRefs(el => ref = el, local.ref);
              typeof _ref$ === "function" && _ref$(r$);
            },
            role: "group",
            get onPointerEnter() {
              return composeEventHandlers([local.onPointerEnter, hoverHandlers.onPointerEnter]);
            },
            get onPointerLeave() {
              return composeEventHandlers([local.onPointerLeave, hoverHandlers.onPointerLeave]);
            }
          }, () => formControlContext.dataset(), dataset, others));
        }
      });
    }
  });
});

/**
 * The native html textarea of the textfield.
 */
function TextFieldTextArea(props) {
  let ref;
  const context = useTextFieldContext();
  props = mergeDefaultProps({
    id: context.generateId("textarea")
  }, props);
  const [local, others] = splitProps(props, ["ref", "autoResize"]);
  createEffect(on([() => ref, () => local.autoResize, () => context.value()], ([ref, autoResize]) => {
    if (!ref || !autoResize) {
      return;
    }
    adjustHeight(ref);
  }));
  return createComponent(TextFieldInputBase, mergeProps$1({
    as: "textarea",
    ref(r$) {
      const _ref$ = mergeRefs(el => ref = el, local.ref);
      typeof _ref$ === "function" && _ref$(r$);
    }
  }, others));
}

/**
 * Adjust the height of the textarea based on its text value.
 */
function adjustHeight(el) {
  const prevAlignment = el.style.alignSelf;
  const prevOverflow = el.style.overflow;

  // Firefox scroll position is lost when `overflow: 'hidden'` is applied, so we skip applying it.
  // The measure/applied height is also incorrect/reset if we turn on and off
  // overflow: hidden in Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1787062
  const isFirefox = ("MozAppearance" in el.style);
  if (!isFirefox) {
    el.style.overflow = "hidden";
  }
  el.style.alignSelf = "start";
  el.style.height = "auto";

  // offsetHeight - clientHeight accounts for the border/padding.
  el.style.height = `${el.scrollHeight + (el.offsetHeight - el.clientHeight)}px`;
  el.style.overflow = prevOverflow;
  el.style.alignSelf = prevAlignment;
}

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Description: FormControlDescription,
  ErrorMessage: FormControlErrorMessage,
  Input: TextFieldInput,
  Label: FormControlLabel,
  Root: TextFieldRoot,
  TextArea: TextFieldTextArea
});

/**
 * A two-state button that allow users to toggle a selection on or off.
 * This component is based on the [WAI-ARIA Button Pattern](https://www.w3.org/WAI/ARIA/apg/patterns/button/)
 */
const ToggleButtonRoot = createPolymorphicComponent(props => {
  const [local, others] = splitProps(props, ["children", "isPressed", "defaultIsPressed", "onPressedChange", "onPress"]);
  const state = createToggleState({
    isSelected: () => local.isPressed,
    defaultIsSelected: () => local.defaultIsPressed,
    onSelectedChange: selected => local.onPressedChange?.(selected),
    isDisabled: () => others.isDisabled
  });
  const onPress = e => {
    local.onPress?.(e);
    state.toggle();
  };
  return createComponent(ButtonRoot, mergeProps$1({
    get ["aria-pressed"]() {
      return state.isSelected();
    },
    get ["data-pressed"]() {
      return state.isSelected() ? "" : undefined;
    },
    onPress: onPress
  }, others, {
    get children() {
      return createComponent(ToggleButtonRootChild, {
        get state() {
          return {
            isPressed: state.isSelected
          };
        },
        get children() {
          return local.children;
        }
      });
    }
  }));
});
function ToggleButtonRootChild(props) {
  return children(() => {
    const body = props.children;
    return isFunction(body) ? body(props.state) : body;
  });
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Root: ToggleButtonRoot
});

export { index$m as Accordion, index$l as Alert, index$j as Breadcrumbs, index$o as Button, COLOR_MODE_STORAGE_KEY, COMMON_INTL_MESSAGES, CREATE_LONG_PRESS_PROP_NAMES, CREATE_PRESS_PROP_NAMES, index$i as Calendar, index$h as Checkbox, index$n as Collapsible, ColorModeContext, ColorModeProvider, ColorModeScript, index$f as ContextMenu, index$e as Dialog, index$d as DropdownMenu, FOCUS_RING_HANDLERS_PROP_NAMES, FORM_CONTROL_FIELD_PROP_NAMES, FORM_CONTROL_PROP_NAMES, FormControlContext, FormControlDescription, FormControlErrorMessage, FormControlLabel, HOVER_HANDLERS_PROP_NAMES, index$c as HoverCard, I18nProvider, index$b as Image, index$k as Link, ListCollection, ListKeyboardDelegate, index$a as Listbox, index$8 as MultiSelect, PRESS_HANDLERS_PROP_NAMES, index$7 as Popover, index$6 as Progress, RTL_LANGS, index$5 as RadioGroup, index$4 as RangeCalendar, index$9 as Select, Selection, SelectionManager, index$g as Separator, index$3 as Switch, index$2 as Tabs, index$1 as TextField, index as ToggleButton, announce, ariaHideOutside, clearAnnouncer, cookieStorageManager, cookieStorageManagerSSR, createCollator, createCollection, createControllableArraySignal, createControllableBooleanSignal, createControllableSetSignal, createControllableSignal, createCookieStorageManager, createDateFormatter, createDefaultLocale, createDisclosureState, createEscapeKeyDown, createFilter, createFocusRing, createFocusScope, createFocusVisible, createFocusVisibleListener, createFormControl, createFormControlField, createFormResetListener, createHideOutside, createHover, createInteractOutside, createInteractionModality, createListState, createLocalStorageManager, createLocalizedStringFormatter, createLongPress, createMultipleSelectionState, createNumberFormatter, createPresence, createPress, createPreventScroll, createRegisterId, createSelectableCollection, createSelectableItem, createSelectableList, createSingleSelectListState, createTagName, createToggleState, createTransition, createTypeSelect, destroyAnnouncer, focusSafely, getDefaultLocale, getInteractionModality, getReadingDirection, isKeyboardFocusVisible, isRTL, localStorageManager, setInteractionModality, useColorMode, useColorModeValue, useFormControlContext, useLocale };
//# sourceMappingURL=index.js.map
