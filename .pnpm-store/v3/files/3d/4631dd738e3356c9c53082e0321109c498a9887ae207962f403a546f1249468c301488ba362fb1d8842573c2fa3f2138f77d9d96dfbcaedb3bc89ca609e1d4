import { access, composeEventHandlers, createGenerateId, createPolymorphicComponent, mergeDefaultProps, mergeRefs, } from "@kobalte/utils";
import { createMemo, createSignal, createUniqueId, splitProps } from "solid-js";
import { Dynamic } from "solid-js/web";
import { createFormControl, FORM_CONTROL_PROP_NAMES, FormControlContext } from "../form-control";
import { createControllableSignal, createFormResetListener, createHover, HOVER_HANDLERS_PROP_NAMES, } from "../primitives";
import { TextFieldContext } from "./text-field-context";
/**
 * A text input that allow users to input custom text entries with a keyboard.
 */
export const TextFieldRoot = createPolymorphicComponent(props => {
    let ref;
    const defaultId = `textfield-${createUniqueId()}`;
    props = mergeDefaultProps({
        as: "div",
        id: defaultId,
    }, props);
    const [local, formControlProps, others] = splitProps(props, ["as", "ref", "value", "defaultValue", "onValueChange", ...HOVER_HANDLERS_PROP_NAMES], FORM_CONTROL_PROP_NAMES);
    const [value, setValue] = createControllableSignal({
        value: () => local.value,
        defaultValue: () => local.defaultValue,
        onChange: value => local.onValueChange?.(value),
    });
    const [isFocused, setIsFocused] = createSignal(false);
    const [isFocusVisible, setIsFocusVisible] = createSignal(false);
    const { formControlContext } = createFormControl(formControlProps);
    createFormResetListener(() => ref, () => setValue(local.defaultValue ?? ""));
    const { isHovered, hoverHandlers } = createHover({
        isDisabled: () => access(formControlProps.isDisabled),
    });
    const onInput = e => {
        if (formControlContext.isReadOnly() || formControlContext.isDisabled()) {
            return;
        }
        const target = e.target;
        setValue(target.value);
        // Unlike in React, inputs `value` can be out of sync with our value state.
        // even if an input is controlled (ex: `<input value="foo" />`,
        // typing on the input will change its internal `value`.
        //
        // To prevent this, we need to force the input `value` to be in sync with the textfield value state.
        target.value = value() ?? "";
    };
    const dataset = createMemo(() => ({
        "data-hover": isHovered() ? "" : undefined,
        "data-focus": isFocused() ? "" : undefined,
        "data-focus-visible": isFocusVisible() ? "" : undefined,
    }));
    const context = {
        dataset,
        value,
        generateId: createGenerateId(() => access(formControlProps.id)),
        setIsFocused,
        setIsFocusVisible,
        onInput,
    };
    return (<FormControlContext.Provider value={formControlContext}>
      <TextFieldContext.Provider value={context}>
        <Dynamic component={local.as} ref={mergeRefs(el => (ref = el), local.ref)} role="group" onPointerEnter={composeEventHandlers([
            local.onPointerEnter,
            hoverHandlers.onPointerEnter,
        ])} onPointerLeave={composeEventHandlers([
            local.onPointerLeave,
            hoverHandlers.onPointerLeave,
        ])} {...formControlContext.dataset()} {...dataset()} {...others}/>
      </TextFieldContext.Provider>
    </FormControlContext.Provider>);
});
